/* automatically generated by rust-bindgen 0.72.1 */
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(unused)]

pub const LOSCFG_COMPILER_CLANG_LLVM: u32 = 1;
pub const LOSCFG_LLVM_TARGET: &[u8; 16] = b"arm-liteos-ohos\0";
pub const LOSCFG_COMPILE_OPTIMIZE: u32 = 1;
pub const LOSCFG_COMPILE_OPTIMIZE_SIZE: u32 = 1;
pub const LOSCFG_COMPILE_LTO: u32 = 1;
pub const LOSCFG_PLATFORM: &[u8; 12] = b"hi3516dv300\0";
pub const LOSCFG_PRODUCT_NAME: &[u8; 15] = b"hispark_taurus\0";
pub const LOSCFG_DEVICE_COMPANY: &[u8; 10] = b"hisilicon\0";
pub const LOSCFG_PLATFORM_HI3516DV300: u32 = 1;
pub const LOSCFG_PRODUCT_HISPARK_TAURUS: u32 = 1;
pub const LOSCFG_BOARD_CONFIG_PATH: &[u8; 53] =
    b"device/board/hisilicon/hispark_taurus/liteos_a/board\0";
pub const LOSCFG_HRTIMER_ENABLE: u32 = 1;
pub const LOSCFG_ARCH_ARM: u32 = 1;
pub const LOSCFG_ARCH_ARM_AARCH32: u32 = 1;
pub const LOSCFG_ARCH_ARM_V7A: u32 = 1;
pub const LOSCFG_ARCH_ARM_VER: &[u8; 8] = b"armv7-a\0";
pub const LOSCFG_ARCH_FPU_VFP_V4: u32 = 1;
pub const LOSCFG_ARCH_FPU_VFP_D32: u32 = 1;
pub const LOSCFG_ARCH_FPU_VFP_NEON: u32 = 1;
pub const LOSCFG_ARCH_FPU: &[u8; 11] = b"neon-vfpv4\0";
pub const LOSCFG_ARCH_CORTEX_A7: u32 = 1;
pub const LOSCFG_ARCH_CPU: &[u8; 10] = b"cortex-a7\0";
pub const LOSCFG_ARCH_GIC_V2: u32 = 1;
pub const LOSCFG_IRQ_USE_STANDALONE_STACK: u32 = 1;
pub const LOSCFG_KERNEL_SMP: u32 = 1;
pub const LOSCFG_KERNEL_SMP_CORE_NUM: u32 = 2;
pub const LOSCFG_KERNEL_SMP_LOCKDEP: u32 = 1;
pub const LOSCFG_KERNEL_SMP_TASK_SYNC: u32 = 1;
pub const LOSCFG_KERNEL_MMU: u32 = 1;
pub const LOSCFG_KERNEL_VM: u32 = 1;
pub const LOSCFG_KERNEL_SYSCALL: u32 = 1;
pub const LOSCFG_KERNEL_EXTKERNEL: u32 = 1;
pub const LOSCFG_KERNEL_CPPSUPPORT: u32 = 1;
pub const LOSCFG_KERNEL_CPUP: u32 = 1;
pub const LOSCFG_CPUP_INCLUDE_IRQ: u32 = 1;
pub const LOSCFG_KERNEL_DYNLOAD: u32 = 1;
pub const LOSCFG_ASLR: u32 = 1;
pub const LOSCFG_KERNEL_PM: u32 = 1;
pub const LOSCFG_KERNEL_VDSO: u32 = 1;
pub const LOSCFG_KERNEL_SHM: u32 = 1;
pub const LOSCFG_KERNEL_LITEIPC: u32 = 1;
pub const LOSCFG_KERNEL_PIPE: u32 = 1;
pub const LOSCFG_BASE_CORE_HILOG: u32 = 1;
pub const LOSCFG_HIDUMPER: u32 = 1;
pub const LOSCFG_HILOG: u32 = 1;
pub const LOSCFG_HILOG_BUFFER_SIZE: u32 = 4096;
pub const LOSCFG_LIB_LIBC: u32 = 1;
pub const LOSCFG_LIBC_MUSL: u32 = 1;
pub const LOSCFG_LIB_ZLIB: u32 = 1;
pub const LOSCFG_COMPAT_POSIX: u32 = 1;
pub const LOSCFG_COMPAT_BSD: u32 = 1;
pub const LOSCFG_COMPAT_LINUXKPI: u32 = 1;
pub const LOSCFG_FS_VFS: u32 = 1;
pub const LOSCFG_FS_VFS_BLOCK_DEVICE: u32 = 1;
pub const LOSCFG_FILE_MODE: u32 = 1;
pub const LOSCFG_MAX_VNODE_SIZE: u32 = 512;
pub const LOSCFG_MAX_PATH_CACHE_SIZE: u32 = 512;
pub const LOSCFG_FS_FAT: u32 = 1;
pub const LOSCFG_FS_FAT_CACHE: u32 = 1;
pub const LOSCFG_FS_FAT_CHINESE: u32 = 1;
pub const LOSCFG_FS_FAT_VIRTUAL_PARTITION: u32 = 1;
pub const LOSCFG_FS_FAT_VOLUMES: u32 = 16;
pub const LOSCFG_FS_FAT_DISK: u32 = 1;
pub const LOSCFG_FS_RAMFS: u32 = 1;
pub const LOSCFG_FS_NFS: u32 = 1;
pub const LOSCFG_FS_PROC: u32 = 1;
pub const LOSCFG_PLATFORM_ROOTFS: u32 = 1;
pub const LOSCFG_STORAGE_EMMC: u32 = 1;
pub const LOSCFG_BOOTENV_ADDR: u32 = 512;
pub const LOSCFG_NET_LWIP_SACK: u32 = 1;
pub const LOSCFG_NET_LWIP_SACK_2_1: u32 = 1;
pub const LOSCFG_PLATFORM_ADAPT: u32 = 1;
pub const LOSCFG_ENABLE_OOM_LOOP_TASK: u32 = 1;
pub const LOSCFG_ENABLE_MAGICKEY: u32 = 1;
pub const LOSCFG_DEBUG_VERSION: u32 = 1;
pub const LOSCFG_SHELL: u32 = 1;
pub const LOSCFG_SHELL_LK: u32 = 1;
pub const LOSCFG_SHELL_DMESG: u32 = 1;
pub const LOSCFG_NET_LWIP_SACK_TFTP: u32 = 1;
pub const LOSCFG_NET_TELNET: u32 = 1;
pub const LOSCFG_SHELL_CMD_DEBUG: u32 = 1;
pub const LOSCFG_DRIVERS: u32 = 1;
pub const LOSCFG_DRIVERS_USB: u32 = 1;
pub const LOSCFG_DRIVERS_USB_HOST_DRIVER: u32 = 1;
pub const LOSCFG_DRIVERS_USB_HOST_XHCI: u32 = 1;
pub const LOSCFG_DRIVERS_USB_DEVICE_CLASS_DRIVERS: u32 = 1;
pub const LOSCFG_DRIVERS_USB_MASS_STORAGE: u32 = 1;
pub const LOSCFG_DRIVERS_USB_RNDIS_HOST: u32 = 1;
pub const LOSCFG_DRIVERS_USB_4G_MODEM: u32 = 1;
pub const LOSCFG_DRIVERS_USB_SERIAL: u32 = 1;
pub const LOSCFG_DRIVERS_USB_ETHERNET: u32 = 1;
pub const LOSCFG_DRIVERS_USB_WIRELESS: u32 = 1;
pub const LOSCFG_DRIVERS_USB_HID_CLASS: u32 = 1;
pub const LOSCFG_DRIVERS_HDF: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_GPIO: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_PIN: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_I2C: u32 = 1;
pub const LOSCFG_USER_I2C_SUPPORT: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_REGULATOR: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_ADC: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_DAC: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_I3C: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_MMC: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_EMMC: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_PWM: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_RTC: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_SDIO: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_MIPI_DSI: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_MIPI_CSI: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_HISI_SDK: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_SPI: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_I2S: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_HDMI: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_PCIE: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_WATCHDOG: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_TRACE: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_DUMPER: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_TIMER: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_CAN: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_STORAGE: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_TEST: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_USB: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_DISP: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_DUAL_LCD_ICN9700_ST7701SN: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_INPUT: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_TP_5P5_GT911: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_SENSOR: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_DSOFTBUS: u32 = 1;
pub const LOSCFG_DSOFTBUS_WLAN_PARAM_MONITOR: u32 = 1;
pub const LOSCFG_DSOFTBUS_LWIP_MONITOR: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_LIGHT: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_VIBRATOR: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_VIBRATOR_LINEAR: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_USB_DDK_DEVICE: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_USB_COMPOSITE: u32 = 1;
pub const LOSCFG_DRIVERS_USB3_DEVICE_CONTROLLER: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_USB_DEVICE_DEMO_TEST: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_USB_DDK_HOST: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_USB_PNP_NOTIFY: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_USB_HOST_DEMO_TEST: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_AUDIO: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_AUDIO_CODEC_HI3516: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_AUDIO_CODEC_TF9879: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_NETWORK: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_WIFI: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_WIFI_BUS: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_WLAN_SDIO: u32 = 1;
pub const LOSCFG_DRIVERS_HDF_PLATFORM_UART: u32 = 1;
pub const LOSCFG_DRIVERS_NETDEV: u32 = 1;
pub const LOSCFG_DRIVERS_HIETH_SF: u32 = 1;
pub const LOSCFG_DRIVERS_MMC: u32 = 1;
pub const LOSCFG_DRIVERS_SD: u32 = 1;
pub const LOSCFG_DRIVERS_EMMC: u32 = 1;
pub const LOSCFG_DRIVERS_EMMC_HS200: u32 = 1;
pub const LOSCFG_DRIVERS_MTD: u32 = 1;
pub const LOSCFG_DRIVERS_MTD_SPI_NOR: u32 = 1;
pub const LOSCFG_DRIVERS_MTD_SPI_NOR_HIFMC100: u32 = 1;
pub const LOSCFG_DRIVERS_HI3881: u32 = 1;
pub const LOSCFG_DRIVERS_MEM: u32 = 1;
pub const LOSCFG_DRIVERS_QUICKSTART: u32 = 1;
pub const LOSCFG_DRIVERS_RANDOM: u32 = 1;
pub const LOSCFG_HW_RANDOM_ENABLE: u32 = 1;
pub const LOSCFG_DRIVERS_VIDEO: u32 = 1;
pub const LOSCFG_DRIVERS_HIEVENT: u32 = 1;
pub const LOSCFG_SECURITY: u32 = 1;
pub const LOSCFG_SECURITY_CAPABILITY: u32 = 1;
pub const LOSCFG_SECURITY_VID: u32 = 1;
pub const LOSCFG_CC_STACKPROTECTOR_STRONG: u32 = 1;
pub const YES: u32 = 1;
pub const NO: u32 = 0;
pub const CPU_SETSIZE: u32 = 32;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const BIG_ENDIAN: u32 = 4321;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const NUM_SIGNAL_ACTIONS: u32 = 16;
pub const SI_ASYNCNL: i32 = -60;
pub const SI_TKILL: i32 = -6;
pub const SI_SIGIO: i32 = -5;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SI_TIMER: i32 = -2;
pub const SI_QUEUE: u32 = 2;
pub const SI_USER: u32 = 1;
pub const SI_KERNEL: u32 = 128;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_SIGINFO: u32 = 2;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_RESTORER: u32 = 67108864;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const _NSIG: u32 = 65;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_MTEAERR: u32 = 8;
pub const SEGV_MTESERR: u32 = 9;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const SA_UNSUPPORTED: u32 = 1024;
pub const SA_EXPOSE_TAGBITS: u32 = 2048;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const SIGRTMIN: u32 = 35;
pub const SIGRTMAX: u32 = 64;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const NSIG: u32 = 65;
pub const SYS_SECCOMP: u32 = 1;
pub const SYS_USER_DISPATCH: u32 = 2;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const OS_LITTLE_ENDIAN: u32 = 4660;
pub const OS_BIG_ENDIAN: u32 = 17185;
pub const OS_BYTE_ORDER: u32 = 4660;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const LOS_OK: u32 = 0;
pub const LOS_NOK: u32 = 1;
pub const LOS_EPERM: u32 = 1;
pub const LOS_ESRCH: u32 = 3;
pub const LOS_EINTR: u32 = 4;
pub const LOS_EBADF: u32 = 9;
pub const LOS_ECHILD: u32 = 10;
pub const LOS_EAGAIN: u32 = 11;
pub const LOS_ENOMEM: u32 = 12;
pub const LOS_EACCES: u32 = 13;
pub const LOS_EFAULT: u32 = 14;
pub const LOS_EBUSY: u32 = 16;
pub const LOS_EINVAL: u32 = 22;
pub const LOS_EDEADLK: u32 = 35;
pub const LOS_EOPNOTSUPP: u32 = 95;
pub const LOS_ETIMEDOUT: u32 = 110;
pub const OS_FAIL: u32 = 1;
pub const OS_64BIT_MAX: i32 = -1;
pub const LOSARC_ALIGNMENT: u32 = 8;
pub const LOSARC_P2ALIGNMENT: u32 = 2;
pub const LOS_ERRNO_OS_ID: u32 = 0;
pub const LOS_ERRTYPE_NORMAL: u32 = 0;
pub const LOS_ERRTYPE_WARN: u32 = 16777216;
pub const LOS_ERRTYPE_ERROR: u32 = 33554432;
pub const LOS_ERRTYPE_FATAL: u32 = 50331648;
pub const OS_SYS_CLOCK: u32 = 50000000;
pub const REG_SC_CTRL: u32 = 0;
pub const CRG_REG_ADDR: u32 = 302055424;
pub const CACHE_ALIGNED_SIZE: u32 = 64;
pub const DDR_MEM_ADDR: u32 = 2147483648;
pub const DDR_MEM_SIZE: u32 = 536870912;
pub const PERIPH_PMM_BASE: u32 = 268435456;
pub const PERIPH_PMM_SIZE: u32 = 268435456;
pub const SYS_MEM_SIZE_DEFAULT: u32 = 133169152;
pub const OS_HWI_MAX_NUM: u32 = 128;
pub const OS_HWI_MAX: u32 = 127;
pub const OS_HWI_MIN: u32 = 0;
pub const OS_USER_HWI_MAX: u32 = 127;
pub const OS_USER_HWI_MIN: u32 = 0;
pub const NUM_HAL_INTERRUPT_CNTPSIRQ: u32 = 29;
pub const NUM_HAL_INTERRUPT_CNTPNSIRQ: u32 = 30;
pub const OS_TICK_INT_NUM: u32 = 29;
pub const NUM_HAL_INTERRUPT_TIMER7: u32 = 36;
pub const NUM_HAL_INTERRUPT_UART0: u32 = 38;
pub const NUM_HAL_INTERRUPT_TEE_SPI_NOTIFY: u32 = 105;
pub const GICD_OFFSET: u32 = 4096;
pub const GICC_OFFSET: u32 = 8192;
pub const NUM_HAL_INTERRUPT_HRTIMER: u32 = 36;
pub const TIMER_LOAD: u32 = 0;
pub const TIMER_VALUE: u32 = 4;
pub const TIMER_CONTROL: u32 = 8;
pub const TIMER_INT_CLR: u32 = 12;
pub const UART_REG_ADDR: u32 = 302645248;
pub const UART0_REG_PBASE: u32 = 302645248;
pub const TTY_DEVICE: &[u8; 15] = b"/dev/uartdev-0\0";
pub const NUM_HAL_INTERRUPT_UART: u32 = 38;
pub const LOSCFG_BASE_CORE_TSK_LIMIT: u32 = 256;
pub const KERNEL_VADDR_BASE: u32 = 1073741824;
pub const KERNEL_VADDR_SIZE: u32 = 536870912;
pub const SYS_MEM_BASE: u32 = 2147483648;
pub const SYS_MEM_END: u32 = 2280652800;
pub const UNCACHED_VMM_SIZE: u32 = 536870912;
pub const VMALLOC_SIZE: u32 = 134217728;
pub const OS_TIME_TIMER_CLOCK: u32 = 50000000;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND: u32 = 1000;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND_MINI: u32 = 1000;
pub const LOSCFG_BASE_CORE_ADJ_PER_SECOND: u32 = 500;
pub const SCHED_CLOCK_INTETRVAL_TICKS: u32 = 1000;
pub const LOSCFG_PLATFORM_HWI_LIMIT: u32 = 96;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO: u32 = 10;
pub const LOSCFG_BASE_CORE_PROCESS_LIMIT: u32 = 64;
pub const LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT: u32 = 20000;
pub const LOSCFG_BASE_IPC_SEM_LIMIT: u32 = 1024;
pub const OS_SEM_COUNT_MAX: u32 = 65534;
pub const LOSCFG_BASE_IPC_QUEUE_LIMIT: u32 = 1024;
pub const LOSCFG_BASE_CORE_SWTMR: u32 = 1;
pub const LOSCFG_BASE_CORE_SWTMR_LIMIT: u32 = 1024;
pub const OS_SWTMR_MAX_TIMERID: u32 = 64512;
pub const OS_SWTMR_HANDLE_QUEUE_SIZE: u32 = 1024;
pub const LOSCFG_KERNEL_CORE_NUM: u32 = 2;
pub const LOSCFG_KERNEL_CPU_MASK: u32 = 3;
pub const KERNEL_NAME: &[u8; 14] = b"Huawei LiteOS\0";
pub const KERNEL_NODE_NAME: &[u8; 10] = b"hisilicon\0";
pub const KERNEL_SEP: &[u8; 2] = b" \0";
pub const KERNEL_MAJOR: u32 = 2;
pub const KERNEL_MINOR: u32 = 0;
pub const KERNEL_PATCH: u32 = 0;
pub const KERNEL_ITRE: u32 = 37;
pub const LOSCFG_KERNEL_CONTAINER_DEFAULT_LIMIT: u32 = 10;
pub const PATH_MAX: u32 = 256;
pub const CONFIG_FS_FAT_SECTOR_PER_BLOCK: u32 = 64;
pub const CONFIG_FS_FAT_READ_NUMS: u32 = 7;
pub const CONFIG_FS_FAT_BLOCK_NUMS: u32 = 28;
pub const CONFIG_FS_FLASH_BLOCK_NUM: u32 = 1;
pub const CONFIG_FS_MAX_LNK_CNT: u32 = 40;
pub const CONFIG_NFS_MACHINE_NAME: &[u8; 4] = b"IPC\0";
pub const CONFIG_NFS_MACHINE_NAME_SIZE: u32 = 3;
pub const CONFIG_NFILE_STREAMS: u32 = 1;
pub const CONFIG_STDIO_BUFFER_SIZE: u32 = 0;
pub const CONFIG_NUNGET_CHARS: u32 = 0;
pub const MIN_START_FD: u32 = 3;
pub const LWIP_SOCKET_SELECT: u32 = 0;
pub const LWIP_SOCKET_POLL: u32 = 1;
pub const MEMP_NUM_NETDB: u32 = 8;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_SOF_BROADCAST: u32 = 1;
pub const IP_SOF_BROADCAST_RECV: u32 = 1;
pub const LWIP_MULTICAST_PING: u32 = 1;
pub const LWIP_RAW: u32 = 1;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 64;
pub const TCP_LISTEN_BACKLOG: u32 = 1;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 16;
pub const LWIP_WND_SCALE: u32 = 1;
pub const TCP_RCV_SCALE: u32 = 7;
pub const LWIP_NETIF_HOSTNAME: u32 = 1;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 1;
pub const LWIP_NETCONN_FULLDUPLEX: u32 = 1;
pub const LWIP_COMPAT_SOCKETS: u32 = 2;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 0;
pub const LWIP_TCP_KEEPALIVE: u32 = 1;
pub const RECV_BUFSIZE_DEFAULT: u32 = 65535;
pub const SO_REUSE_RXTOALL: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 1;
pub const LWIP_IPV6: u32 = 1;
pub const LWIP_IPV6_NUM_ADDRESSES: u32 = 5;
pub const LWIP_ND6_NUM_PREFIXES: u32 = 10;
pub const LWIP_IPV6_DHCP6: u32 = 1;
pub const LWIP_IPV6_DHCP6_STATEFUL: u32 = 1;
pub const ARP_QUEUEING: u32 = 1;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 32;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 128;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 128;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 128;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 1;
pub const ETH_PAD_SIZE: u32 = 2;
pub const LWIP_DHCP: u32 = 1;
pub const LWIP_DNS: u32 = 1;
pub const LWIP_ETHERNET: u32 = 1;
pub const LWIP_HAVE_LOOPIF: u32 = 1;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_NETIF_API: u32 = 1;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 1;
pub const LWIP_NETIF_EXT_STATUS_CALLBACK: u32 = 1;
pub const LWIP_NETIF_LOOPBACK: u32 = 1;
pub const LWIP_SO_RCVBUF: u32 = 1;
pub const LWIP_SO_RCVTIMEO: u32 = 1;
pub const LWIP_SO_SNDTIMEO: u32 = 1;
pub const LWIP_STATS_DISPLAY: u32 = 1;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 64;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 512;
pub const MEM_SIZE: u32 = 4194304;
pub const PBUF_POOL_BUFSIZE: u32 = 1550;
pub const PBUF_POOL_SIZE: u32 = 64;
pub const SO_REUSE: u32 = 1;
pub const TCPIP_MBOX_SIZE: u32 = 512;
pub const TCPIP_THREAD_PRIO: u32 = 5;
pub const TCPIP_THREAD_STACKSIZE: u32 = 24576;
pub const TCP_MAXRTX: u32 = 64;
pub const TCP_MSS: u32 = 1400;
pub const TCP_SND_BUF: u32 = 65535;
pub const TCP_SND_QUEUELEN: u32 = 374;
pub const TCP_TTL: u32 = 255;
pub const TCP_WND: u32 = 32768;
pub const UDP_TTL: u32 = 255;
pub const IP_FORWARD: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const LWIP_NETCONN: u32 = 1;
pub const LWIP_SOCKET: u32 = 1;
pub const LWIP_STATS: u32 = 1;
pub const LWIP_TCP: u32 = 1;
pub const LWIP_UDP: u32 = 1;
pub const NO_SYS: u32 = 0;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const IP_FRAG_MAX_MTU: u32 = 1500;
pub const LWIP_CONFIG_NUM_SOCKETS: u32 = 128;
pub const IP_REASS_MAX_MEM_SIZE: u32 = 1048576;
pub const LWIP_NETIF_PROMISC: u32 = 1;
pub const LWIP_DHCPS: u32 = 1;
pub const LWIP_ENABLE_NET_CAPABILITY: u32 = 1;
pub const LWIP_ENABLE_CAP_NET_BROADCAST: u32 = 0;
pub const CONFIG_NSOCKET_DESCRIPTORS: u32 = 128;
pub const CONFIG_NFILE_DESCRIPTORS: u32 = 512;
pub const CONFIG_NET_SENDFILE: u32 = 1;
pub const CONFIG_NET_TCP: u32 = 1;
pub const NR_OPEN_DEFAULT: u32 = 512;
pub const CONFIG_NTIME_DESCRIPTORS: u32 = 0;
pub const CONFIG_NQUEUE_DESCRIPTORS: u32 = 256;
pub const CONFIG_EPOLL_DESCRIPTORS: u32 = 32;
pub const DEFAULT_DIR_MODE: u32 = 511;
pub const DEFAULT_FILE_MODE: u32 = 438;
pub const MAX_DIRENT_NUM: u32 = 14;
pub const HDF_BSP_ERR_START: i32 = -100;
pub const HDF_DEV_ERR_START: i32 = -200;
pub const HDF_WAIT_FOREVER: u32 = 4294967295;
pub const HDF_KILO_UNIT: u32 = 1000;
pub const HDF_LIBRARY_DIR: &[u8; 9] = b"/usr/lib\0";
pub const HDF_ETC_DIR: &[u8; 5] = b"/etc\0";
pub const HDF_CONFIG_DIR: &[u8; 5] = b"/etc\0";
pub const HDF_CHIP_PROD_CONFIG_DIR: &[u8; 5] = b"/etc\0";
pub const HOSTID_BITS: u32 = 8;
pub const DEVICEID_BITS: u32 = 16;
pub const DEVNODEID_BITS: u32 = 8;
pub const DEVNODEID_MASK: u32 = 255;
pub const DEVICEID_MASK: u32 = 65535;
pub const MAX_PRIORITY_NUM: u32 = 200;
pub const HDF_SYSEVENT: u32 = 64222;
pub const HDF_SYSEVENT_CLASS_POWER: u32 = 1;
pub const HDF_SYSEVENT_CLASS_MODULE: u32 = 2;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 20;
pub const TMP_MAX: u32 = 308915776;
pub const L_tmpnam: u32 = 4096;
pub const L_ctermid: u32 = 20;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_cuserid: u32 = 20;
pub const LOG_DOMAIN: u32 = 0;
pub const DOMAIN_LENGTH: u32 = 5;
pub const DOMAIN_FILTER: u32 = 1048575;
pub const DEV_SVCMGR_NODE: &[u8; 11] = b"devsvc_mgr\0";
pub const DEV_NODE_PATH: &[u8; 10] = b"/dev/hdf/\0";
pub const DEV_PATH: &[u8; 6] = b"/dev/\0";
pub const DEV_MGR_NODE: &[u8; 8] = b"dev_mgr\0";
pub const MAX_MODE_SIZE: u32 = 511;
pub const DEV_NODE_PATH_MODE: u32 = 488;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __ll: ::core::ffi::c_longlong,
    pub __ld: f64,
}
pub type size_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [::core::ffi::c_ulong; 1usize],
}
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i32;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u32;
pub type uint_fast32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_struct;
pub type time_t = ::core::ffi::c_longlong;
pub type suseconds_t = ::core::ffi::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_attr_s {
    pub detachstate: ::core::ffi::c_uint,
    pub schedpolicy: ::core::ffi::c_uint,
    pub schedparam: sched_param,
    pub inheritsched: ::core::ffi::c_uint,
    pub scope: ::core::ffi::c_uint,
    pub stackaddr_set: ::core::ffi::c_uint,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize_set: ::core::ffi::c_uint,
    pub stacksize: size_t,
    pub cpuset: cpu_set_t,
}
pub type pthread_attr_t = __pthread_attr_s;
pub type ssize_t = ::core::ffi::c_int;
pub type register_t = ::core::ffi::c_int;
pub type u_int64_t = ::core::ffi::c_ulonglong;
pub type mode_t = ::core::ffi::c_uint;
pub type nlink_t = ::core::ffi::c_uint;
pub type off_t = ::core::ffi::c_longlong;
pub type loff_t = ::core::ffi::c_longlong;
pub type off64_t = off_t;
pub type ino_t = ::core::ffi::c_ulonglong;
pub type dev_t = ::core::ffi::c_ulonglong;
pub type blksize_t = ::core::ffi::c_long;
pub type blkcnt_t = ::core::ffi::c_longlong;
pub type fsblkcnt_t = ::core::ffi::c_ulonglong;
pub type fsfilcnt_t = ::core::ffi::c_ulonglong;
pub type timer_t = *mut ::core::ffi::c_void;
pub type clockid_t = ::core::ffi::c_int;
pub type clock_t = ::core::ffi::c_long;
pub type pid_t = ::core::ffi::c_int;
pub type id_t = ::core::ffi::c_uint;
pub type uid_t = ::core::ffi::c_uint;
pub type gid_t = ::core::ffi::c_uint;
pub type key_t = ::core::ffi::c_int;
pub type useconds_t = ::core::ffi::c_uint;
pub type pthread_t = ::core::ffi::c_long;
pub type pthread_once_t = ::core::ffi::c_int;
pub type pthread_key_t = ::core::ffi::c_int;
pub type pthread_condattr_t = ::core::ffi::c_int;
pub type u_int8_t = ::core::ffi::c_uchar;
pub type u_int16_t = ::core::ffi::c_ushort;
pub type u_int32_t = ::core::ffi::c_uint;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type ushort = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type uint = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type ulong = ::core::ffi::c_ulong;
pub type quad_t = ::core::ffi::c_longlong;
pub type u_quad_t = ::core::ffi::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: ::core::ffi::c_longlong,
    pub tv_usec: ::core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: ::core::ffi::c_longlong,
    pub tv_nsec: ::core::ffi::c_longlong,
}
pub type sigset_t = ::core::ffi::c_ulonglong;
pub type stack_t = sigaltstack;
pub type greg_t = ::core::ffi::c_int;
pub type gregset_t = [::core::ffi::c_int; 18usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub trap_no: ::core::ffi::c_ulong,
    pub error_code: ::core::ffi::c_ulong,
    pub oldmask: ::core::ffi::c_ulong,
    pub arm_r0: ::core::ffi::c_ulong,
    pub arm_r1: ::core::ffi::c_ulong,
    pub arm_r2: ::core::ffi::c_ulong,
    pub arm_r3: ::core::ffi::c_ulong,
    pub arm_r4: ::core::ffi::c_ulong,
    pub arm_r5: ::core::ffi::c_ulong,
    pub arm_r6: ::core::ffi::c_ulong,
    pub arm_r7: ::core::ffi::c_ulong,
    pub arm_r8: ::core::ffi::c_ulong,
    pub arm_r9: ::core::ffi::c_ulong,
    pub arm_r10: ::core::ffi::c_ulong,
    pub arm_fp: ::core::ffi::c_ulong,
    pub arm_ip: ::core::ffi::c_ulong,
    pub arm_sp: ::core::ffi::c_ulong,
    pub arm_lr: ::core::ffi::c_ulong,
    pub arm_pc: ::core::ffi::c_ulong,
    pub arm_cpsr: ::core::ffi::c_ulong,
    pub fault_address: ::core::ffi::c_ulong,
}
pub type mcontext_t = sigcontext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_flags: ::core::ffi::c_int,
    pub ss_size: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext {
    pub uc_flags: ::core::ffi::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub uc_regspace: [::core::ffi::c_ulonglong; 64usize],
}
pub type ucontext_t = ucontext;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::core::ffi::c_int,
    pub sival_ptr: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::core::ffi::c_int,
    pub si_errno: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub __si_fields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub __pad: [::core::ffi::c_char; 116usize],
    pub __si_common: siginfo_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub __first: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __second: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __piduid: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __timer: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: pid_t,
    pub si_uid: uid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub si_timerid: ::core::ffi::c_int,
    pub si_overrun: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub si_value: sigval,
    pub __sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub si_status: ::core::ffi::c_int,
    pub si_utime: clock_t,
    pub si_stime: clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub sa_sigactionhandler: sigaction__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_flags: ::core::ffi::c_int,
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub sa_sigaction: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::core::ffi::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::core::ffi::c_void,
        ),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_notify: ::core::ffi::c_int,
    pub __sev_fields: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub __pad: [::core::ffi::c_char; 52usize],
    pub sigev_notify_thread_id: pid_t,
    pub __sev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub sigev_notify_function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
pub type sig_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
pub type sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
pub type sig_atomic_t = ::core::ffi::c_int;
pub type UINT8 = ::core::ffi::c_uchar;
pub type UINT16 = ::core::ffi::c_ushort;
pub type UINT32 = ::core::ffi::c_uint;
pub type INT8 = ::core::ffi::c_schar;
pub type INT16 = ::core::ffi::c_short;
pub type INT32 = ::core::ffi::c_int;
pub type FLOAT = f32;
pub type DOUBLE = f64;
pub type CHAR = ::core::ffi::c_char;
pub type UINT64 = ::core::ffi::c_ulonglong;
pub type INT64 = ::core::ffi::c_longlong;
pub type UINTPTR = ::core::ffi::c_uint;
pub type INTPTR = ::core::ffi::c_int;
pub type AARCHPTR = UINTPTR;
pub type BOOL = size_t;
pub type status_t = ::core::ffi::c_int;
pub type vaddr_t = ::core::ffi::c_ulong;
pub type PADDR_T = ::core::ffi::c_ulong;
pub type VADDR_T = ::core::ffi::c_ulong;
pub type paddr_t = ::core::ffi::c_ulong;
pub type DMA_ADDR_T = ::core::ffi::c_ulong;
pub type ADDR_T = ::core::ffi::c_ulong;
pub type VM_OFFSET_T = ::core::ffi::c_ulong;
pub type PTE_T = ::core::ffi::c_ulong;
pub type ULONG_T = ::core::ffi::c_uint;
pub type STATUS_T = ::core::ffi::c_int;
pub type LOS_ERRORHANDLE_FUNC = ::core::option::Option<
    unsafe extern "C" fn(
        fileName: *mut CHAR,
        lineNo: UINT32,
        errorNo: UINT32,
        paraLen: UINT32,
        para: *mut ::core::ffi::c_void,
    ),
>;
pub const LOS_MOD_SYS: LOS_MOUDLE_ID = 0;
pub const LOS_MOD_MEM: LOS_MOUDLE_ID = 1;
pub const LOS_MOD_TSK: LOS_MOUDLE_ID = 2;
pub const LOS_MOD_SWTMR: LOS_MOUDLE_ID = 3;
pub const LOS_MOD_TICK: LOS_MOUDLE_ID = 4;
pub const LOS_MOD_MSG: LOS_MOUDLE_ID = 5;
pub const LOS_MOD_QUE: LOS_MOUDLE_ID = 6;
pub const LOS_MOD_SEM: LOS_MOUDLE_ID = 7;
pub const LOS_MOD_MBOX: LOS_MOUDLE_ID = 8;
pub const LOS_MOD_HWI: LOS_MOUDLE_ID = 9;
pub const LOS_MOD_HWWDG: LOS_MOUDLE_ID = 10;
pub const LOS_MOD_CACHE: LOS_MOUDLE_ID = 11;
pub const LOS_MOD_HWTMR: LOS_MOUDLE_ID = 12;
pub const LOS_MOD_MMU: LOS_MOUDLE_ID = 13;
pub const LOS_MOD_LOG: LOS_MOUDLE_ID = 14;
pub const LOS_MOD_ERR: LOS_MOUDLE_ID = 15;
pub const LOS_MOD_EXC: LOS_MOUDLE_ID = 16;
pub const LOS_MOD_CSTK: LOS_MOUDLE_ID = 17;
pub const LOS_MOD_MPU: LOS_MOUDLE_ID = 18;
pub const LOS_MOD_NMHWI: LOS_MOUDLE_ID = 19;
pub const LOS_MOD_TRACE: LOS_MOUDLE_ID = 20;
pub const LOS_MOD_KNLSTAT: LOS_MOUDLE_ID = 21;
pub const LOS_MOD_EVTTIME: LOS_MOUDLE_ID = 22;
pub const LOS_MOD_THRDCPUP: LOS_MOUDLE_ID = 23;
pub const LOS_MOD_IPC: LOS_MOUDLE_ID = 24;
pub const LOS_MOD_STKMON: LOS_MOUDLE_ID = 25;
pub const LOS_MOD_TIMER: LOS_MOUDLE_ID = 26;
pub const LOS_MOD_RESLEAKMON: LOS_MOUDLE_ID = 27;
pub const LOS_MOD_EVENT: LOS_MOUDLE_ID = 28;
pub const LOS_MOD_MUX: LOS_MOUDLE_ID = 29;
pub const LOS_MOD_CPUP: LOS_MOUDLE_ID = 30;
pub const LOS_MOD_HOOK: LOS_MOUDLE_ID = 31;
pub const LOS_MOD_PERF: LOS_MOUDLE_ID = 32;
pub const LOS_MOD_PM: LOS_MOUDLE_ID = 33;
pub const LOS_MOD_SHELL: LOS_MOUDLE_ID = 49;
pub const LOS_MOD_DRIVER: LOS_MOUDLE_ID = 65;
pub const LOS_MOD_BUTT: LOS_MOUDLE_ID = 66;
pub type LOS_MOUDLE_ID = ::core::ffi::c_uint;
unsafe extern "C" {
    pub static mut g_sysClock: UINT32;
}
unsafe extern "C" {
    pub static mut g_tickPerSecond: UINT32;
}
unsafe extern "C" {
    pub static mut __int_stack_start: CHAR;
}
unsafe extern "C" {
    pub static mut __rodata_start: CHAR;
}
unsafe extern "C" {
    pub static mut __rodata_end: CHAR;
}
unsafe extern "C" {
    pub static mut __bss_start: CHAR;
}
unsafe extern "C" {
    pub static mut __bss_end: CHAR;
}
unsafe extern "C" {
    pub static mut __text_start: CHAR;
}
unsafe extern "C" {
    pub static mut __text_end: CHAR;
}
unsafe extern "C" {
    pub static mut __ram_data_start: CHAR;
}
unsafe extern "C" {
    pub static mut __ram_data_end: CHAR;
}
unsafe extern "C" {
    pub static mut __heap_start: UINT32;
}
unsafe extern "C" {
    pub static mut __heap_end: UINT32;
}
pub type SystemRebootFunc = ::core::option::Option<unsafe extern "C" fn()>;
pub type fd_mask = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [::core::ffi::c_ulong; 28usize],
}
pub const HDF_SUCCESS: HDF_STATUS = 0;
pub const HDF_FAILURE: HDF_STATUS = -1;
pub const HDF_ERR_NOT_SUPPORT: HDF_STATUS = -2;
pub const HDF_ERR_INVALID_PARAM: HDF_STATUS = -3;
pub const HDF_ERR_INVALID_OBJECT: HDF_STATUS = -4;
pub const HDF_ERR_MALLOC_FAIL: HDF_STATUS = -6;
pub const HDF_ERR_TIMEOUT: HDF_STATUS = -7;
pub const HDF_ERR_THREAD_CREATE_FAIL: HDF_STATUS = -10;
pub const HDF_ERR_QUEUE_FULL: HDF_STATUS = -15;
pub const HDF_ERR_DEVICE_BUSY: HDF_STATUS = -16;
pub const HDF_ERR_IO: HDF_STATUS = -17;
pub const HDF_ERR_BAD_FD: HDF_STATUS = -18;
pub const HDF_ERR_NOPERM: HDF_STATUS = -19;
pub const HDF_ERR_OUT_OF_RANGE: HDF_STATUS = -20;
pub const HDF_BSP_ERR_OP: HDF_STATUS = -101;
pub const HDF_ERR_BSP_PLT_API_ERR: HDF_STATUS = -102;
pub const HDF_PAL_ERR_DEV_CREATE: HDF_STATUS = -103;
pub const HDF_PAL_ERR_INNER: HDF_STATUS = -104;
pub const HDF_DEV_ERR_NO_MEMORY: HDF_STATUS = -201;
pub const HDF_DEV_ERR_NO_DEVICE: HDF_STATUS = -202;
pub const HDF_DEV_ERR_NO_DEVICE_SERVICE: HDF_STATUS = -203;
pub const HDF_DEV_ERR_DEV_INIT_FAIL: HDF_STATUS = -204;
pub const HDF_DEV_ERR_PUBLISH_FAIL: HDF_STATUS = -205;
pub const HDF_DEV_ERR_ATTACHDEV_FAIL: HDF_STATUS = -206;
pub const HDF_DEV_ERR_NODATA: HDF_STATUS = -207;
pub const HDF_DEV_ERR_NORANGE: HDF_STATUS = -208;
pub const HDF_DEV_ERR_OP: HDF_STATUS = -210;
pub const HDF_DEV_ERR_NETDOWN: HDF_STATUS = -211;
pub type HDF_STATUS = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DListHead {
    pub next: *mut DListHead,
    pub prev: *mut DListHead,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfObject {
    pub objectId: i32,
}
pub type devid_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IHdfDevice {
    pub object: HdfObject,
    pub Attach: ::core::option::Option<
        unsafe extern "C" fn(
            device: *mut IHdfDevice,
            deviceNode: *mut HdfDeviceNode,
        ) -> ::core::ffi::c_int,
    >,
    pub Detach: ::core::option::Option<
        unsafe extern "C" fn(
            device: *mut IHdfDevice,
            deviceNode: *mut HdfDeviceNode,
        ) -> ::core::ffi::c_int,
    >,
    pub GetDeviceNode: ::core::option::Option<
        unsafe extern "C" fn(device: *mut IHdfDevice, devid: devid_t) -> *mut HdfDeviceNode,
    >,
    pub DetachWithDevid: ::core::option::Option<
        unsafe extern "C" fn(device: *mut IHdfDevice, devid: devid_t) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDevice {
    pub super_: IHdfDevice,
    pub node: DListHead,
    pub devNodes: DListHead,
    pub deviceId: devid_t,
    pub devidIndex: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSListNode {
    pub next: *mut HdfSListNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSList {
    pub root: *mut HdfSListNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSListIterator {
    pub stepOnNext: ::core::ffi::c_int,
    pub prev: *mut HdfSListNode,
    pub curr: *mut HdfSListNode,
}
pub type HdfSListDeleter = ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfSListNode)>;
pub type HdfSListSearchComparer =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfSListNode, arg2: u32) -> bool>;
pub type HdfSListAddComparer = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut HdfSListNode, arg2: *mut HdfSListNode) -> bool,
>;
pub const HDF_SERVICE_UNUSABLE: _bindgen_ty_1 = 0;
pub const HDF_SERVICE_USABLE: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
pub const HDF_DEV_LOCAL_SERVICE: _bindgen_ty_2 = 0;
pub const HDF_DEV_REMOTE_SERVICE: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceInfo {
    pub node: HdfSListNode,
    pub isDynamic: bool,
    pub status: u16,
    pub deviceType: u16,
    pub deviceId: u32,
    pub policy: u16,
    pub priority: u16,
    pub preload: u16,
    pub permission: u16,
    pub moduleName: *const ::core::ffi::c_char,
    pub svcName: *const ::core::ffi::c_char,
    pub deviceMatchAttr: *const ::core::ffi::c_char,
    pub deviceName: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfPrivateInfo {
    pub length: u32,
    pub data: *const ::core::ffi::c_void,
}
pub type char16_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSBuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSBufImpl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfRemoteService {
    _unused: [u8; 0],
}
pub const SBUF_RAW: HdfSbufType = 0;
pub const SBUF_IPC: HdfSbufType = 1;
pub const SBUF_IPC_HW: HdfSbufType = 2;
pub const SBUF_TYPE_MAX: HdfSbufType = 3;
pub type HdfSbufType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDevHostService {
    pub object: HdfObject,
    pub AddDevice: ::core::option::Option<
        unsafe extern "C" fn(
            hostService: *mut IDevHostService,
            devInfo: *const HdfDeviceInfo,
        ) -> ::core::ffi::c_int,
    >,
    pub DelDevice: ::core::option::Option<
        unsafe extern "C" fn(
            hostService: *mut IDevHostService,
            devId: devid_t,
        ) -> ::core::ffi::c_int,
    >,
    pub StartService: ::core::option::Option<
        unsafe extern "C" fn(hostService: *mut IDevHostService) -> ::core::ffi::c_int,
    >,
    pub PmNotify: ::core::option::Option<
        unsafe extern "C" fn(service: *mut IDevHostService, powerState: u32) -> ::core::ffi::c_int,
    >,
    pub Dump: ::core::option::Option<
        unsafe extern "C" fn(
            hostService: *mut IDevHostService,
            data: *mut HdfSBuf,
            reply: *mut HdfSBuf,
        ) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IHdfDeviceToken {
    pub object: HdfObject,
    pub devid: devid_t,
    pub servName: *const ::core::ffi::c_char,
    pub deviceName: *const ::core::ffi::c_char,
}
pub const DEVICE_CLASS_DEFAULT: DeviceClass = 1;
pub const DEVICE_CLASS_PLAT: DeviceClass = 2;
pub const DEVICE_CLASS_SENSOR: DeviceClass = 4;
pub const DEVICE_CLASS_INPUT: DeviceClass = 8;
pub const DEVICE_CLASS_DISPLAY: DeviceClass = 16;
pub const DEVICE_CLASS_AUDIO: DeviceClass = 32;
pub const DEVICE_CLASS_CAMERA: DeviceClass = 64;
pub const DEVICE_CLASS_USB: DeviceClass = 128;
pub const DEVICE_CLASS_USERAUTH: DeviceClass = 256;
pub const DEVICE_CLASS_HIMEDIACOMM: DeviceClass = 512;
pub const DEVICE_CLASS_MAX: DeviceClass = 1024;
pub type DeviceClass = ::core::ffi::c_uint;
pub type OnEventReceived = ::core::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::core::ffi::c_void,
        id: u32,
        data: *mut HdfSBuf,
    ) -> ::core::ffi::c_int,
>;
pub type OnDevEventReceive = ::core::option::Option<
    unsafe extern "C" fn(
        listener: *mut HdfDevEventlistener,
        service: *mut HdfIoService,
        id: u32,
        data: *mut HdfSBuf,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDevEventlistener {
    pub callBack: OnEventReceived,
    pub onReceive: OnDevEventReceive,
    pub listNode: DListHead,
    pub priv_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfIoDispatcher {
    pub Dispatch: ::core::option::Option<
        unsafe extern "C" fn(
            service: *mut HdfObject,
            cmdId: ::core::ffi::c_int,
            data: *mut HdfSBuf,
            reply: *mut HdfSBuf,
        ) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfIoService {
    pub object: HdfObject,
    pub target: *mut HdfObject,
    pub dispatcher: *mut HdfIoDispatcher,
    pub priv_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfIoServiceGroup {
    pub object: HdfObject,
}
pub const SERVICE_POLICY_NONE: ServicePolicy = 0;
pub const SERVICE_POLICY_PUBLIC: ServicePolicy = 1;
pub const SERVICE_POLICY_CAPACITY: ServicePolicy = 2;
pub const SERVICE_POLICY_FRIENDLY: ServicePolicy = 3;
pub const SERVICE_POLICY_PRIVATE: ServicePolicy = 4;
pub const SERVICE_POLICY_INVALID: ServicePolicy = 5;
pub type ServicePolicy = ::core::ffi::c_uint;
pub const DEVICE_PRELOAD_ENABLE: DevicePreload = 0;
pub const DEVICE_PRELOAD_ENABLE_STEP2: DevicePreload = 1;
pub const DEVICE_PRELOAD_DISABLE: DevicePreload = 2;
pub const DEVICE_PRELOAD_INVALID: DevicePreload = 3;
pub type DevicePreload = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceObject {
    pub service: *mut IDeviceIoService,
    pub property: *mut DeviceResourceNode,
    pub deviceClass: DeviceClass,
    pub priv_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceIoClient {
    pub device: *mut HdfDeviceObject,
    pub priv_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDeviceIoService {
    pub object: HdfObject,
    pub Open: ::core::option::Option<unsafe extern "C" fn(client: *mut HdfDeviceIoClient) -> i32>,
    pub Dispatch: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut HdfDeviceIoClient,
            cmdId: ::core::ffi::c_int,
            data: *mut HdfSBuf,
            reply: *mut HdfSBuf,
        ) -> i32,
    >,
    pub Release: ::core::option::Option<unsafe extern "C" fn(client: *mut HdfDeviceIoClient)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubscriberCallback {
    pub deviceObject: *mut HdfDeviceObject,
    pub OnServiceConnected: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject, service: *const HdfObject) -> i32,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDriverEntry {
    pub moduleVersion: i32,
    pub moduleName: *const ::core::ffi::c_char,
    pub Bind:
        ::core::option::Option<unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> i32>,
    pub Init:
        ::core::option::Option<unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> i32>,
    pub Release: ::core::option::Option<unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject)>,
}
pub const POWER_STATE_DOZE_RESUME: HdfPowerState = 0;
pub const POWER_STATE_DOZE_SUSPEND: HdfPowerState = 1;
pub const POWER_STATE_RESUME: HdfPowerState = 2;
pub const POWER_STATE_SUSPEND: HdfPowerState = 3;
pub const POWER_STATE_MAX: HdfPowerState = 4;
pub type HdfPowerState = ::core::ffi::c_uint;
pub const PSM_STATE_IDLE: HdfPsmState = 0;
pub const PSM_STATE_ACTIVE: HdfPsmState = 1;
pub const PSM_STATE_INACTIVE: HdfPsmState = 2;
pub type HdfPsmState = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPowerStateToken {
    pub AcquireWakeLock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut IPowerStateToken)>,
    pub ReleaseWakeLock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut IPowerStateToken)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDevmgrService {
    pub base: HdfObject,
    pub object: HdfDeviceObject,
    pub AttachDeviceHost: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            arg2: u16,
            arg3: *mut IDevHostService,
        ) -> ::core::ffi::c_int,
    >,
    pub AttachDevice: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            arg2: *mut IHdfDeviceToken,
        ) -> ::core::ffi::c_int,
    >,
    pub DetachDevice: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevmgrService, arg2: devid_t) -> ::core::ffi::c_int,
    >,
    pub LoadDevice: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            arg2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    pub UnloadDevice: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            arg2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    pub StartService: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevmgrService) -> ::core::ffi::c_int,
    >,
    pub PowerStateChange: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            pEvent: HdfPowerState,
        ) -> ::core::ffi::c_int,
    >,
    pub ListAllDevice: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevmgrService, arg2: *mut HdfSBuf) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DevSvcRecord {
    pub entry: DListHead,
    pub key: u32,
    pub value: *mut HdfDeviceObject,
    pub servName: *const ::core::ffi::c_char,
    pub servInfo: *const ::core::ffi::c_char,
    pub devClass: u16,
    pub devId: devid_t,
    pub interfaceDesc: *const ::core::ffi::c_char,
}
pub const HDF_OBJECT_ID_DEVMGR_SERVICE: _bindgen_ty_3 = 0;
pub const HDF_OBJECT_ID_DEVSVC_MANAGER: _bindgen_ty_3 = 1;
pub const HDF_OBJECT_ID_DEVHOST_SERVICE: _bindgen_ty_3 = 2;
pub const HDF_OBJECT_ID_DRIVER_INSTALLER: _bindgen_ty_3 = 3;
pub const HDF_OBJECT_ID_DRIVER_LOADER: _bindgen_ty_3 = 4;
pub const HDF_OBJECT_ID_DEVICE: _bindgen_ty_3 = 5;
pub const HDF_OBJECT_ID_DEVICE_TOKEN: _bindgen_ty_3 = 6;
pub const HDF_OBJECT_ID_DEVICE_SERVICE: _bindgen_ty_3 = 7;
pub const HDF_OBJECT_ID_REMOTE_SERVICE: _bindgen_ty_3 = 8;
pub const HDF_OBJECT_ID_MAX: _bindgen_ty_3 = 9;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfObjectCreator {
    pub Create: ::core::option::Option<unsafe extern "C" fn() -> *mut HdfObject>,
    pub Release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfObject)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDriver {
    pub entry: *const HdfDriverEntry,
    pub type_: u16,
    pub bus: u16,
    pub node: DListHead,
    pub priv_: *mut ::core::ffi::c_void,
}
pub const KEVENT_POWER_SUSPEND: PowerKeventId = 0;
pub const KEVENT_POWER_DISPLAY_OFF: PowerKeventId = 1;
pub const KEVENT_POWER_RESUME: PowerKeventId = 2;
pub const KEVENT_POWER_DISPLAY_ON: PowerKeventId = 3;
pub const KEVENT_POWER_EVENT_MAX: PowerKeventId = 4;
pub type PowerKeventId = ::core::ffi::c_uint;
pub const KEVENT_MODULE_INSTALL: DriverModuleKeventId = 0;
pub const KEVENT_MODULE_REMOVE: DriverModuleKeventId = 1;
pub const KEVENT_MODULE_EVENT_MAX: DriverModuleKeventId = 2;
pub type DriverModuleKeventId = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSysEvent {
    pub eventClass: u64,
    pub syncToken: u64,
    pub eventid: u32,
    pub reserved: u32,
}
pub type HdfSysEventNotifierFn = ::core::option::Option<
    unsafe extern "C" fn(
        self_: *mut HdfSysEventNotifyNode,
        eventClass: u64,
        event: u32,
        content: *const ::core::ffi::c_char,
    ) -> i32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSysEventNotifyNode {
    pub callback: HdfSysEventNotifierFn,
    pub listNode: DListHead,
    pub classFilter: u64,
}
pub const HDF_POWER_SYS_CTRL: PowerManagementMode = 0;
pub const HDF_POWER_DYNAMIC_CTRL: PowerManagementMode = 1;
pub const HDF_POWER_MODE_MAX: PowerManagementMode = 2;
pub type PowerManagementMode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPowerEventListener {
    pub DozeResume: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> ::core::ffi::c_int,
    >,
    pub DozeSuspend: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> ::core::ffi::c_int,
    >,
    pub Resume: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> ::core::ffi::c_int,
    >,
    pub Suspend: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DevHostService {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDeviceNode {
    pub object: HdfObject,
    pub PublishService: ::core::option::Option<
        unsafe extern "C" fn(devNode: *mut HdfDeviceNode) -> ::core::ffi::c_int,
    >,
    pub RemoveService: ::core::option::Option<
        unsafe extern "C" fn(devNode: *mut HdfDeviceNode) -> ::core::ffi::c_int,
    >,
    pub LaunchNode: ::core::option::Option<
        unsafe extern "C" fn(devNode: *mut HdfDeviceNode) -> ::core::ffi::c_int,
    >,
    pub UnlaunchNode: ::core::option::Option<unsafe extern "C" fn(devNode: *mut HdfDeviceNode)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceNode {
    pub super_: IDeviceNode,
    pub entry: DListHead,
    pub powerToken: *mut PowerStateToken,
    pub hostService: *mut DevHostService,
    pub deviceObject: HdfDeviceObject,
    pub token: *mut IHdfDeviceToken,
    pub driver: *mut HdfDriver,
    pub device: *mut HdfDevice,
    pub servName: *mut ::core::ffi::c_char,
    pub servInfo: *const ::core::ffi::c_char,
    pub driverName: *mut ::core::ffi::c_char,
    pub devId: devid_t,
    pub policy: u16,
    pub permission: u16,
    pub devStatus: u8,
    pub servStatus: bool,
    pub interfaceDesc: *mut ::core::ffi::c_char,
}
pub const DEVNODE_NONE: DevNodeStaus = 0;
pub const DEVNODE_INITED: DevNodeStaus = 1;
pub const DEVNODE_LAUNCHED: DevNodeStaus = 2;
pub type DevNodeStaus = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfServiceInfo {
    pub servName: *const ::core::ffi::c_char,
    pub servInfo: *const ::core::ffi::c_char,
    pub devClass: u16,
    pub devId: devid_t,
    pub interfaceDesc: *const ::core::ffi::c_char,
}
pub const SERVIE_STATUS_START: ServiceStatusType = 0;
pub const SERVIE_STATUS_CHANGE: ServiceStatusType = 1;
pub const SERVIE_STATUS_STOP: ServiceStatusType = 2;
pub const SERVIE_STATUS_REGISTER: ServiceStatusType = 3;
pub const SERVIE_STATUS_MAX: ServiceStatusType = 4;
pub type ServiceStatusType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ServiceStatus {
    pub serviceName: *const ::core::ffi::c_char,
    pub deviceClass: u16,
    pub status: u16,
    pub info: *const ::core::ffi::c_char,
}
pub type OnServiceStatusReceived = ::core::option::Option<
    unsafe extern "C" fn(listener: *mut ServiceStatusListener, status: *mut ServiceStatus),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ServiceStatusListener {
    pub callback: OnServiceStatusReceived,
    pub priv_: *mut ::core::ffi::c_void,
}
pub const SERVIE_STATUS_LISTENER_NOTIFY: ServiceStatusListenerCmd = 0;
pub const SERVIE_STATUS_LISTENER_MAX: ServiceStatusListenerCmd = 1;
pub type ServiceStatusListenerCmd = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ServStatListenerHolder {
    pub listenClass: u16,
    pub node: DListHead,
    pub index: u64,
    pub NotifyStatus: ::core::option::Option<
        unsafe extern "C" fn(
            holder: *mut ServStatListenerHolder,
            status: *mut ServiceStatus,
        ) -> i32,
    >,
    pub Recycle: ::core::option::Option<unsafe extern "C" fn(holder: *mut ServStatListenerHolder)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDevSvcManager {
    pub object: HdfObject,
    pub StartService: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevSvcManager) -> ::core::ffi::c_int,
    >,
    pub AddService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *mut HdfDeviceObject,
            arg3: *const HdfServiceInfo,
        ) -> ::core::ffi::c_int,
    >,
    pub UpdateService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *mut HdfDeviceObject,
            arg3: *const HdfServiceInfo,
        ) -> ::core::ffi::c_int,
    >,
    pub SubscribeService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
            arg3: SubscriberCallback,
        ) -> ::core::ffi::c_int,
    >,
    pub UnsubscribeService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    pub GetService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
        ) -> *mut HdfObject,
    >,
    pub GetObject: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
        ) -> *mut HdfDeviceObject,
    >,
    pub RemoveService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
            arg3: *const HdfDeviceObject,
        ),
    >,
    pub RegsterServListener: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *mut ServStatListenerHolder,
        ) -> ::core::ffi::c_int,
    >,
    pub UnregsterServListener: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevSvcManager, arg2: *mut ServStatListenerHolder),
    >,
    pub ListAllService:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut IDevSvcManager, arg2: *mut HdfSBuf)>,
    pub ListServiceByInterfaceDesc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
            arg3: *mut HdfSBuf,
        ) -> ::core::ffi::c_int,
    >,
}
pub type va_list = u32;
pub type __isoc_va_list = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _G_fpos64_t {
    pub __opaque: [::core::ffi::c_char; 16usize],
    pub __lldata: ::core::ffi::c_longlong,
    pub __align: f64,
}
pub type fpos_t = _G_fpos64_t;
unsafe extern "C" {
}
unsafe extern "C" {
}
unsafe extern "C" {
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_char,
        arg3: size_t,
    ) -> ssize_t,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_char,
        arg3: size_t,
    ) -> ssize_t,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut off_t,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type cookie_close_function_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub const HILOG_MODULE_HIVIEW: HiLogModuleType = 0;
pub const HILOG_MODULE_SAMGR: HiLogModuleType = 1;
pub const HILOG_MODULE_ACE: HiLogModuleType = 2;
pub const HILOG_MODULE_GRAPHIC: HiLogModuleType = 3;
pub const HILOG_MODULE_APP: HiLogModuleType = 4;
pub const HILOG_MODULE_MAX: HiLogModuleType = 5;
pub type HiLogModuleType = ::core::ffi::c_uint;
pub const LOG_TYPE_MIN: LogType = 0;
pub const LOG_INIT: LogType = 1;
pub const LOG_CORE: LogType = 3;
pub const LOG_TYPE_MAX: LogType = 4;
pub type LogType = ::core::ffi::c_uint;
pub const LOG_DEBUG: LogLevel = 3;
pub const LOG_INFO: LogLevel = 4;
pub const LOG_WARN: LogLevel = 5;
pub const LOG_ERROR: LogLevel = 6;
pub const LOG_FATAL: LogLevel = 7;
pub type LogLevel = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDevHostMgr {
    pub hosts: DListHead,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfHostType {
    pub devHostName: *const ::core::ffi::c_char,
    pub priority: u16,
    pub devices: DListHead,
    pub hostEntry: DListHead,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceType {
    pub deviceNodes: DListHead,
    pub deviceEntry: DListHead,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceNodeType {
    pub policy: u16,
    pub priority: u16,
    pub preload: u16,
    pub permission: u16,
    pub moduleName: *const ::core::ffi::c_char,
    pub svcName: *const ::core::ffi::c_char,
    pub deviceName: *const ::core::ffi::c_char,
    pub deviceMatchAttr: *const ::core::ffi::c_char,
    pub deviceNodeEntry: DListHead,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapNode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Map {
    pub nodes: *mut *mut MapNode,
    pub nodeSize: u32,
    pub bucketSize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OsalMutex {
    pub realMutex: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DevHostServiceClnt {
    pub node: DListHead,
    pub devices: HdfSList,
    pub unloadDevInfos: HdfSList,
    pub dynamicDevInfos: HdfSList,
    pub deviceHashMap: *mut Map,
    pub hostService: *mut IDevHostService,
    pub hostLock: OsalMutex,
    pub devCount: u16,
    pub hostId: u16,
    pub hostPid: ::core::ffi::c_int,
    pub hostName: *const ::core::ffi::c_char,
    pub stopFlag: bool,
}
pub const SVCMGR_REGISTER_LISTENER: SvcMgrIoCmd = 0;
pub const SVCMGR_UNREGISTER_LISTENER: SvcMgrIoCmd = 1;
pub type SvcMgrIoCmd = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISvcMgrIoservice {
    pub RegisterServiceStatusListener: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut ISvcMgrIoservice,
            listener: *mut ServiceStatusListener,
            deviceClass: u16,
        ) -> i32,
    >,
    pub UnregisterServiceStatusListener: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut ISvcMgrIoservice,
            listener: *mut ServiceStatusListener,
        ) -> i32,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IoServiceStatusListener {
    pub svcstatListener: ServiceStatusListener,
    pub ioservListener: HdfDevEventlistener,
    pub node: DListHead,
    pub deviceClass: u16,
}
pub const DEVMGR_LOAD_SERVICE: DevMgrCmd = 0;
pub const DEVMGR_UNLOAD_SERVICE: DevMgrCmd = 1;
pub const DEVMGR_GET_SERVICE: DevMgrCmd = 2;
pub const DEVMGR_LIST_ALL_SERVICE: DevMgrCmd = 3;
pub const DEVMGR_LIST_ALL_DEVICE: DevMgrCmd = 4;
pub type DevMgrCmd = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfWriteReadBuf {
    pub writeSize: u32,
    pub writeConsumed: u32,
    pub writeBuffer: u64,
    pub readSize: u32,
    pub readConsumed: u32,
    pub readBuffer: u64,
    pub cmdCode: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceResourceNode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PowerStateToken {
    pub _address: u8,
}

// ============================================================
// C2R: TU-pinned type supplements (from stage1 `.i` truth)
// ============================================================
pub mod __c2r_tu_types_src_svcmgr_ioservice {
    include!("__c2r_generated/tu_types_src_svcmgr_ioservice.rs");
}
pub use __c2r_tu_types_src_svcmgr_ioservice::{SvcMgrIoservice};


// --- POSIX Thread Types ---
#[repr(C)]
pub struct pthread_mutex_t { _opaque: [u8; 40] }
#[repr(C)]
pub struct pthread_cond_t { _opaque: [u8; 48] }
#[repr(C)]
pub struct pthread_rwlock_t { _opaque: [u8; 56] }


// ============================================================
// Common Constants ()
// ============================================================

pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = unsafe { ::core::mem::zeroed() };
pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = unsafe { ::core::mem::zeroed() };
pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = unsafe { ::core::mem::zeroed() };
pub const PTHREAD_ONCE_INIT: pthread_once_t = unsafe { ::core::mem::zeroed() };
pub const __PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = unsafe { ::core::mem::zeroed() };
pub const __PTHREAD_COND_INITIALIZER: pthread_cond_t = unsafe { ::core::mem::zeroed() };
pub const __PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = unsafe { ::core::mem::zeroed() };
pub const __PTHREAD_ONCE_INIT: pthread_once_t = unsafe { ::core::mem::zeroed() };
pub const EINVAL: i32 = 22;
pub const ENOMEM: i32 = 12;
pub const ENOENT: i32 = 2;
pub const EEXIST: i32 = 17;
pub const EBUSY: i32 = 16;
pub const EAGAIN: i32 = 11;
pub const ETIMEDOUT: i32 = 110;
pub const ENODEV: i32 = 19;
pub const EFAULT: i32 = 14;
pub const ENOSYS: i32 = 38;
pub const ERANGE: i32 = 34;
pub const ENOTCONN: i32 = 107;
pub const SOFTBUS_OK: i32 = 0;
pub const SOFTBUS_ERR: i32 = -1;
pub const SOFTBUS_NOT_IMPLEMENT: i32 = -2;
pub const SOFTBUS_INVALID_PARAM: i32 = -3;
pub const SOFTBUS_MEM_ERR: i32 = -4;
pub const SOFTBUS_MALLOC_ERR: i32 = -5;
pub const SOFTBUS_PERMISSION_DENIED: i32 = -6;
pub const SOFTBUS_NETWORK_ERR: i32 = -7;
pub const LOS_ERRNO_BASE: u32 = 0x02000000;
pub const AUDIO_FORMAT_TYPE_PCM_16_BIT: i32 = 1;
pub const AUDIO_FORMAT_TYPE_PCM_8_BIT: i32 = 0;
pub const AUDIO_FORMAT_TYPE_PCM_24_BIT: i32 = 2;
pub const AUDIO_FORMAT_TYPE_PCM_32_BIT: i32 = 3;
