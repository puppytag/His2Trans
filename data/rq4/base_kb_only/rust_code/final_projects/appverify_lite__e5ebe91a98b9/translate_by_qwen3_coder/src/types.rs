/* automatically generated by rust-bindgen 0.72.1 */
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(unused)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const YES: u32 = 1;
pub const NO: u32 = 0;
pub const CPU_SETSIZE: u32 = 32;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const MBEDTLS_VERSION_MAJOR: u32 = 3;
pub const MBEDTLS_VERSION_MINOR: u32 = 6;
pub const MBEDTLS_VERSION_PATCH: u32 = 0;
pub const MBEDTLS_VERSION_NUMBER: u32 = 50724864;
pub const MBEDTLS_VERSION_STRING: &[u8; 6] = b"3.6.0\0";
pub const MBEDTLS_VERSION_STRING_FULL: &[u8; 15] = b"Mbed TLS 3.6.0\0";
pub const MBEDTLS_SSL_MAX_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 16384;
pub const PSA_WANT_ALG_MD5: u32 = 1;
pub const PSA_WANT_ALG_SHA_1: u32 = 1;
pub const PSA_WANT_ALG_SHA_224: u32 = 1;
pub const PSA_WANT_ALG_SHA_256: u32 = 1;
pub const PSA_WANT_ALG_SHA_384: u32 = 1;
pub const PSA_WANT_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_ALG_SHA3_224: u32 = 1;
pub const PSA_WANT_ALG_SHA3_256: u32 = 1;
pub const PSA_WANT_ALG_SHA3_384: u32 = 1;
pub const PSA_WANT_ALG_SHA3_512: u32 = 1;
pub const PSA_WANT_ECC_BRAINPOOL_P_R1_256: u32 = 1;
pub const PSA_WANT_ECC_BRAINPOOL_P_R1_384: u32 = 1;
pub const PSA_WANT_ECC_BRAINPOOL_P_R1_512: u32 = 1;
pub const PSA_WANT_ECC_MONTGOMERY_255: u32 = 1;
pub const PSA_WANT_ECC_MONTGOMERY_448: u32 = 1;
pub const PSA_WANT_ECC_SECP_R1_192: u32 = 1;
pub const PSA_WANT_ECC_SECP_R1_224: u32 = 1;
pub const PSA_WANT_ECC_SECP_R1_256: u32 = 1;
pub const PSA_WANT_ECC_SECP_R1_384: u32 = 1;
pub const PSA_WANT_ECC_SECP_R1_521: u32 = 1;
pub const PSA_WANT_ECC_SECP_K1_192: u32 = 1;
pub const PSA_WANT_ECC_SECP_K1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CMAC: u32 = 1;
pub const PSA_WANT_ALG_CMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDH: u32 = 1;
pub const PSA_WANT_ALG_ECDH: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA_ANY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_BASIC: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_IMPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_EXPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_GENERATE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_DERIVE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_BASIC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_IMPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_EXPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_GENERATE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_DERIVE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_GCM: u32 = 1;
pub const PSA_WANT_ALG_GCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HMAC: u32 = 1;
pub const PSA_WANT_ALG_HMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF: u32 = 1;
pub const PSA_WANT_ALG_HKDF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXTRACT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXPAND: u32 = 1;
pub const PSA_WANT_KEY_TYPE_HMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PRF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_MD5: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_PAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_JPAKE: u32 = 1;
pub const PSA_WANT_ALG_JPAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN_RAW: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_OAEP: u32 = 1;
pub const PSA_WANT_ALG_RSA_OAEP: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS: u32 = 1;
pub const PSA_WANT_ALG_RSA_PSS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_GENERATE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_GENERATE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_BASIC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_IMPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_IMPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_EXPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_1: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_512: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA3_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA3_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA3_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA3_512: u32 = 1;
pub const PSA_WANT_KEY_TYPE_AES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_AES: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ARIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ARIA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_KEY_TYPE_CHACHA20: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_CHACHA20: u32 = 1;
pub const PSA_WANT_ALG_STREAM_CIPHER: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_STREAM_CIPHER: u32 = 1;
pub const PSA_WANT_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_CBC_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7: u32 = 1;
pub const PSA_WANT_ALG_CBC_PKCS7: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_ECB_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CFB: u32 = 1;
pub const PSA_WANT_ALG_CFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CTR: u32 = 1;
pub const PSA_WANT_ALG_CTR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_OFB: u32 = 1;
pub const PSA_WANT_ALG_OFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_512: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_255: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_448: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_521: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_256: u32 = 1;
pub const PSA_WANT_ALG_SOME_PAKE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DERIVE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD_HASH: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RAW_DATA: u32 = 1;
pub const OS_LITTLE_ENDIAN: u32 = 4660;
pub const OS_BIG_ENDIAN: u32 = 17185;
pub const OS_BYTE_ORDER: u32 = 4660;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const LOS_OK: u32 = 0;
pub const LOS_NOK: u32 = 1;
pub const LOS_EPERM: u32 = 1;
pub const LOS_ESRCH: u32 = 3;
pub const LOS_EINTR: u32 = 4;
pub const LOS_EBADF: u32 = 9;
pub const LOS_ECHILD: u32 = 10;
pub const LOS_EAGAIN: u32 = 11;
pub const LOS_ENOMEM: u32 = 12;
pub const LOS_EACCES: u32 = 13;
pub const LOS_EFAULT: u32 = 14;
pub const LOS_EBUSY: u32 = 16;
pub const LOS_EINVAL: u32 = 22;
pub const LOS_EDEADLK: u32 = 35;
pub const LOS_EOPNOTSUPP: u32 = 95;
pub const LOS_ETIMEDOUT: u32 = 110;
pub const OS_FAIL: u32 = 1;
pub const OS_64BIT_MAX: i32 = -1;
pub const LOSARC_ALIGNMENT: u32 = 8;
pub const LOSARC_P2ALIGNMENT: u32 = 2;
pub const LOS_ERRNO_OS_ID: u32 = 0;
pub const LOS_ERRTYPE_NORMAL: u32 = 0;
pub const LOS_ERRTYPE_WARN: u32 = 16777216;
pub const LOS_ERRTYPE_ERROR: u32 = 33554432;
pub const LOS_ERRTYPE_FATAL: u32 = 50331648;
pub const OS_SYS_CLOCK: u32 = 50000000;
pub const REG_SC_CTRL: u32 = 0;
pub const CRG_REG_ADDR: u32 = 302055424;
pub const CACHE_ALIGNED_SIZE: u32 = 64;
pub const DDR_MEM_ADDR: u32 = 2147483648;
pub const DDR_MEM_SIZE: u32 = 536870912;
pub const PERIPH_PMM_BASE: u32 = 268435456;
pub const PERIPH_PMM_SIZE: u32 = 268435456;
pub const SYS_MEM_SIZE_DEFAULT: u32 = 133169152;
pub const OS_HWI_MAX_NUM: u32 = 128;
pub const OS_HWI_MAX: u32 = 127;
pub const OS_HWI_MIN: u32 = 0;
pub const OS_USER_HWI_MAX: u32 = 127;
pub const OS_USER_HWI_MIN: u32 = 0;
pub const NUM_HAL_INTERRUPT_CNTPSIRQ: u32 = 29;
pub const NUM_HAL_INTERRUPT_CNTPNSIRQ: u32 = 30;
pub const OS_TICK_INT_NUM: u32 = 29;
pub const NUM_HAL_INTERRUPT_TIMER7: u32 = 36;
pub const NUM_HAL_INTERRUPT_UART0: u32 = 38;
pub const NUM_HAL_INTERRUPT_TEE_SPI_NOTIFY: u32 = 105;
pub const GICD_OFFSET: u32 = 4096;
pub const GICC_OFFSET: u32 = 8192;
pub const NUM_HAL_INTERRUPT_HRTIMER: u32 = 36;
pub const TIMER_LOAD: u32 = 0;
pub const TIMER_VALUE: u32 = 4;
pub const TIMER_CONTROL: u32 = 8;
pub const TIMER_INT_CLR: u32 = 12;
pub const UART_REG_ADDR: u32 = 302645248;
pub const UART0_REG_PBASE: u32 = 302645248;
pub const TTY_DEVICE: &[u8; 15] = b"/dev/uartdev-0\0";
pub const NUM_HAL_INTERRUPT_UART: u32 = 38;
pub const KERNEL_VADDR_BASE: u32 = 2147483648;
pub const KERNEL_VADDR_SIZE: u32 = 536870912;
pub const SYS_MEM_BASE: u32 = 2147483648;
pub const SYS_MEM_END: u32 = 2280652800;
pub const UNCACHED_VMM_SIZE: u32 = 536870912;
pub const VMALLOC_SIZE: u32 = 134217728;
pub const PERIPH_DEVICE_BASE: u32 = 268435456;
pub const PERIPH_CACHED_BASE: u32 = 268435456;
pub const PERIPH_UNCACHED_BASE: u32 = 268435456;
pub const OS_TIME_TIMER_CLOCK: u32 = 50000000;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND: u32 = 1000;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND_MINI: u32 = 1000;
pub const LOSCFG_BASE_CORE_ADJ_PER_SECOND: u32 = 500;
pub const SCHED_CLOCK_INTETRVAL_TICKS: u32 = 1000;
pub const LOSCFG_PLATFORM_HWI_LIMIT: u32 = 96;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO: u32 = 10;
pub const LOSCFG_BASE_CORE_TSK_LIMIT: u32 = 128;
pub const LOSCFG_BASE_CORE_PROCESS_LIMIT: u32 = 64;
pub const LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT: u32 = 20000;
pub const LOSCFG_BASE_IPC_SEM_LIMIT: u32 = 1024;
pub const OS_SEM_COUNT_MAX: u32 = 65534;
pub const LOSCFG_BASE_IPC_QUEUE_LIMIT: u32 = 1024;
pub const LOSCFG_BASE_CORE_SWTMR: u32 = 1;
pub const LOSCFG_BASE_CORE_SWTMR_LIMIT: u32 = 1024;
pub const OS_SWTMR_MAX_TIMERID: u32 = 64512;
pub const OS_SWTMR_HANDLE_QUEUE_SIZE: u32 = 1024;
pub const LOSCFG_KERNEL_CORE_NUM: u32 = 1;
pub const LOSCFG_KERNEL_CPU_MASK: u32 = 1;
pub const KERNEL_NAME: &[u8; 14] = b"Huawei LiteOS\0";
pub const KERNEL_NODE_NAME: &[u8; 10] = b"hisilicon\0";
pub const KERNEL_SEP: &[u8; 2] = b" \0";
pub const KERNEL_MAJOR: u32 = 2;
pub const KERNEL_MINOR: u32 = 0;
pub const KERNEL_PATCH: u32 = 0;
pub const KERNEL_ITRE: u32 = 37;
pub const LOSCFG_KERNEL_CONTAINER_DEFAULT_LIMIT: u32 = 10;
pub const PAGE_SIZE: u32 = 4096;
pub const PAGESIZE: u32 = 4096;
pub const _POSIX_GETGR_R_SIZE_MAX: u32 = 0;
pub const _POSIX_GETPW_R_SIZE_MAX: u32 = 0;
pub const GETGR_R_SIZE_MAX: u32 = 0;
pub const GETPW_R_SIZE_MAX: u32 = 0;
pub const _LITEOS_MQ_OPEN_MAX: u32 = 1024;
pub const MQ_OPEN_MAX: u32 = 1024;
pub const PTHREAD_THREADS_MAX: u32 = 129;
pub const TIMERS: u32 = 1;
pub const LINK_MAX: u32 = 8;
pub const RTSIG_MAX: u32 = 8;
pub const STREAM_MAX: u32 = 8;
pub const SIGQUEUE_MAX: u32 = 32;
pub const FILESYSTEM_TYPE_MAX: u32 = 32;
pub const CHAR_MIN: u32 = 0;
pub const CHAR_MAX: u32 = 255;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const MB_LEN_MAX: u32 = 4;
pub const PIPE_BUF: u32 = 4096;
pub const FILESIZEBITS: u32 = 64;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 256;
pub const CONFIG_PATH_MAX: u32 = 256;
pub const CONFIG_NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 32;
pub const ARG_MAX: u32 = 4096;
pub const IOV_MAX: u32 = 1024;
pub const SYMLOOP_MAX: u32 = 40;
pub const WORD_BIT: u32 = 32;
pub const SSIZE_MAX: u32 = 2147483647;
pub const TZNAME_MAX: u32 = 6;
pub const TTY_NAME_MAX: u32 = 32;
pub const HOST_NAME_MAX: u32 = 255;
pub const LONG_BIT: u32 = 32;
pub const PTHREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const SEM_VALUE_MAX: u32 = 65534;
pub const SEM_NSEMS_MAX: u32 = 1024;
pub const DELAYTIMER_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 4096;
pub const RE_DUP_MAX: u32 = 255;
pub const NL_ARGMAX: u32 = 9;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const NL_LANGMAX: u32 = 32;
pub const NL_NMAX: u32 = 16;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const CHILD_MAX: u32 = 6;
pub const OPEN_MAX: u32 = 256;
pub const MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const MBEDTLS_ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const MBEDTLS_ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const MBEDTLS_ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const MBEDTLS_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_MD_MAX_BLOCK_SIZE: u32 = 144;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 20;
pub const TMP_MAX: u32 = 308915776;
pub const L_tmpnam: u32 = 4096;
pub const L_ctermid: u32 = 20;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_cuserid: u32 = 20;
pub const MBEDTLS_ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const MBEDTLS_ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const MBEDTLS_ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const MBEDTLS_ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const MBEDTLS_ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const MBEDTLS_ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MBEDTLS_MPI_MAX_LIMBS: u32 = 10000;
pub const MBEDTLS_MPI_WINDOW_SIZE: u32 = 3;
pub const MBEDTLS_MPI_MAX_SIZE: u32 = 1024;
pub const MBEDTLS_MPI_MAX_BITS: u32 = 8192;
pub const MBEDTLS_MPI_MAX_BITS_SCALE100: u32 = 819200;
pub const MBEDTLS_LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MBEDTLS_MPI_RW_BUFFER_SIZE: u32 = 2484;
pub const MBEDTLS_MPI_UINT_MAX: u32 = 4294967295;
pub const MBEDTLS_ERR_RSA_BAD_INPUT_DATA: i32 = -16512;
pub const MBEDTLS_ERR_RSA_INVALID_PADDING: i32 = -16640;
pub const MBEDTLS_ERR_RSA_KEY_GEN_FAILED: i32 = -16768;
pub const MBEDTLS_ERR_RSA_KEY_CHECK_FAILED: i32 = -16896;
pub const MBEDTLS_ERR_RSA_PUBLIC_FAILED: i32 = -17024;
pub const MBEDTLS_ERR_RSA_PRIVATE_FAILED: i32 = -17152;
pub const MBEDTLS_ERR_RSA_VERIFY_FAILED: i32 = -17280;
pub const MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE: i32 = -17408;
pub const MBEDTLS_ERR_RSA_RNG_FAILED: i32 = -17536;
pub const MBEDTLS_RSA_PKCS_V15: u32 = 0;
pub const MBEDTLS_RSA_PKCS_V21: u32 = 1;
pub const MBEDTLS_RSA_SIGN: u32 = 1;
pub const MBEDTLS_RSA_CRYPT: u32 = 2;
pub const MBEDTLS_RSA_SALT_LEN_ANY: i32 = -1;
pub const MBEDTLS_RSA_GEN_KEY_MIN_BITS: u32 = 1024;
pub const MBEDTLS_ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const MBEDTLS_ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const MBEDTLS_ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const MBEDTLS_ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const MBEDTLS_ERR_ECP_INVALID_KEY: i32 = -19584;
pub const MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const MBEDTLS_ERR_ECP_IN_PROGRESS: i32 = -19200;
pub const MBEDTLS_ECP_DP_MAX: u32 = 14;
pub const MBEDTLS_ECP_WINDOW_SIZE: u32 = 4;
pub const MBEDTLS_ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const MBEDTLS_ECP_MAX_BITS: u32 = 521;
pub const MBEDTLS_ECP_MAX_BYTES: u32 = 66;
pub const MBEDTLS_ECP_MAX_PT_LEN: u32 = 133;
pub const MBEDTLS_ECP_OPS_CHK: u32 = 3;
pub const MBEDTLS_ECP_OPS_DBL: u32 = 8;
pub const MBEDTLS_ECP_OPS_ADD: u32 = 11;
pub const MBEDTLS_ECP_OPS_INV: u32 = 120;
pub const MBEDTLS_ECP_PF_UNCOMPRESSED: u32 = 0;
pub const MBEDTLS_ECP_PF_COMPRESSED: u32 = 1;
pub const MBEDTLS_ECP_TLS_NAMED_CURVE: u32 = 3;
pub const PSA_CRYPTO_API_VERSION_MAJOR: u32 = 1;
pub const PSA_CRYPTO_API_VERSION_MINOR: u32 = 0;
pub const PSA_MAC_TRUNCATION_OFFSET: u32 = 16;
pub const PSA_AEAD_TAG_LENGTH_OFFSET: u32 = 16;
pub const PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED: u32 = 4294967295;
pub const PSA_HMAC_MAX_HASH_BLOCK_SIZE: u32 = 144;
pub const PSA_HASH_MAX_SIZE: u32 = 64;
pub const PSA_MAC_MAX_SIZE: u32 = 64;
pub const PSA_AEAD_TAG_MAX_SIZE: u32 = 16;
pub const PSA_VENDOR_RSA_MAX_KEY_BITS: u32 = 4096;
pub const PSA_VENDOR_RSA_GENERATE_MIN_KEY_BITS: u32 = 1024;
pub const PSA_VENDOR_FFDH_MAX_KEY_BITS: u32 = 0;
pub const PSA_VENDOR_ECC_MAX_CURVE_BITS: u32 = 521;
pub const PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE: u32 = 128;
pub const PSA_TLS12_ECJPAKE_TO_PMS_INPUT_SIZE: u32 = 65;
pub const PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE: u32 = 32;
pub const PSA_VENDOR_PBKDF2_MAX_ITERATIONS: u32 = 4294967295;
pub const PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_NONCE_MAX_SIZE: u32 = 13;
pub const PSA_AEAD_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_SIGNATURE_MAX_SIZE: u32 = 1;
pub const PSA_EXPORT_KEY_PAIR_MAX_SIZE: u32 = 1;
pub const PSA_EXPORT_PUBLIC_KEY_MAX_SIZE: u32 = 1;
pub const PSA_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE: u32 = 1;
pub const PSA_CIPHER_IV_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const MBEDTLS_ERR_SHA1_BAD_INPUT_DATA: i32 = -115;
pub const MBEDTLS_ERR_SHA256_BAD_INPUT_DATA: i32 = -116;
pub const MBEDTLS_ERR_SHA512_BAD_INPUT_DATA: i32 = -117;
pub const MBEDTLS_ERR_SHA3_BAD_INPUT_DATA: i32 = -118;
pub const MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const MBEDTLS_ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const MBEDTLS_ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const MBEDTLS_ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const MBEDTLS_ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const MBEDTLS_CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const MBEDTLS_CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MBEDTLS_MAX_IV_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_BLOCK_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_KEY_LENGTH: u32 = 64;
pub const MBEDTLS_KEY_BITLEN_SHIFT: u32 = 6;
pub const MBEDTLS_IV_SIZE_SHIFT: u32 = 2;
pub const MBEDTLS_PSA_BUILTIN_CIPHER: u32 = 1;
pub const MBEDTLS_AES_BLOCK_SIZE: u32 = 16;
pub const MBEDTLS_DES3_BLOCK_SIZE: u32 = 8;
pub const MBEDTLS_CMAC_MAX_BLOCK_SIZE: u32 = 16;
pub const MBEDTLS_CIPHER_BLKSIZE_MAX: u32 = 16;
pub const MBEDTLS_GCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_GCM_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_GCM_AUTH_FAILED: i32 = -18;
pub const MBEDTLS_ERR_GCM_BAD_INPUT: i32 = -20;
pub const MBEDTLS_ERR_GCM_BUFFER_TOO_SMALL: i32 = -22;
pub const MBEDTLS_GCM_HTABLE_SIZE: u32 = 16;
pub const MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA: i32 = -87;
pub const MBEDTLS_ERR_CHACHAPOLY_BAD_STATE: i32 = -84;
pub const MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED: i32 = -86;
pub const MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA: i32 = -81;
pub const MBEDTLS_PSA_BUILTIN_AEAD: u32 = 1;
pub const MBEDTLS_PSA_JPAKE_BUFFER_SIZE: u32 = 336;
pub const PSA_MAX_KEY_BITS: u32 = 65528;
pub const PSA_CRYPTO_ITS_RANDOM_SEED_UID: u32 = 4294967122;
pub const MBEDTLS_PSA_KEY_SLOT_COUNT: u32 = 32;
pub const PSA_PAKE_OPERATION_STAGE_SETUP: u32 = 0;
pub const PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS: u32 = 1;
pub const PSA_PAKE_OPERATION_STAGE_COMPUTATION: u32 = 2;
pub const PSA_PAKE_OUTPUT_MAX_SIZE: u32 = 65;
pub const PSA_PAKE_INPUT_MAX_SIZE: u32 = 65;
pub const MBEDTLS_ERR_PK_ALLOC_FAILED: i32 = -16256;
pub const MBEDTLS_ERR_PK_TYPE_MISMATCH: i32 = -16128;
pub const MBEDTLS_ERR_PK_BAD_INPUT_DATA: i32 = -16000;
pub const MBEDTLS_ERR_PK_FILE_IO_ERROR: i32 = -15872;
pub const MBEDTLS_ERR_PK_KEY_INVALID_VERSION: i32 = -15744;
pub const MBEDTLS_ERR_PK_KEY_INVALID_FORMAT: i32 = -15616;
pub const MBEDTLS_ERR_PK_UNKNOWN_PK_ALG: i32 = -15488;
pub const MBEDTLS_ERR_PK_PASSWORD_REQUIRED: i32 = -15360;
pub const MBEDTLS_ERR_PK_PASSWORD_MISMATCH: i32 = -15232;
pub const MBEDTLS_ERR_PK_INVALID_PUBKEY: i32 = -15104;
pub const MBEDTLS_ERR_PK_INVALID_ALG: i32 = -14976;
pub const MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE: i32 = -14848;
pub const MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE: i32 = -14720;
pub const MBEDTLS_ERR_PK_SIG_LEN_MISMATCH: i32 = -14592;
pub const MBEDTLS_ERR_PK_BUFFER_TOO_SMALL: i32 = -14464;
pub const MBEDTLS_PK_SIGNATURE_MAX_SIZE: u32 = 0;
pub const MBEDTLS_PK_DEBUG_MAX_ITEMS: u32 = 3;
pub const FILE_OPEN_FAIL_ERROR_NUM: i32 = -1;
pub const INQUIRY_UDID_OK: u32 = 0;
pub const INQUIRY_UDID_ERROR: i32 = -1;
pub const LOG_DOMAIN: u32 = 0;
pub const DOMAIN_LENGTH: u32 = 5;
pub const DOMAIN_FILTER: u32 = 1048575;
pub const HILOG_DRIVER: &[u8; 11] = b"/dev/hilog\0";
pub const NANOSEC_PER_MIRCOSEC: u32 = 1000000;
pub const LOG_TAG: &[u8; 10] = b"appverify\0";
pub const MAX_PRINT_LEN: u32 = 1024;
pub const DOUBLE_SIZE: u32 = 2;
pub const MAX_CHARACTER: u32 = 9;
pub const BYTE_BITS: u32 = 8;
pub const MAX_MALLOC_SIZE: u32 = 1048576;
pub const MAX_HASH_SIZE: u32 = 64;
pub const HAP_SIG_BLOCK_MAGIC_HI_OLD: u64 = 3617552046287187010;
pub const HAP_SIG_BLOCK_MAGIC_LO_OLD: u64 = 2334950737560224072;
pub const HAP_SIG_BLOCK_MAGIC_HI: u64 = 4497797983070462062;
pub const HAP_SIG_BLOCK_MAGIC_LO: u64 = 7451613641622775868;
pub const HAP_SIG_BLOCK_MIN_SIZE: u32 = 32;
pub const UINT16_MAX_VALUE: u32 = 65535;
pub const HAP_EOCD_MAGIC: u32 = 101010256;
pub const HAP_FIRST_LEVEL_CHUNK_PREFIX: u32 = 90;
pub const HAP_SECOND_LEVEL_CHUNK_PREFIX: u32 = 165;
pub const VERSION_FOR_NEW_MAGIC_NUM: u32 = 3;
pub const APP_STORE: &[u8; 17] = b"Huawei App Store\0";
pub const DEBUG_TYPE: &[u8; 6] = b"debug\0";
pub const RELEASE_TYPE: &[u8; 8] = b"release\0";
pub const MAX_UDID_NUM: u32 = 100;
pub const UDID_VERIFY_BYTES: u32 = 64;
pub const HW_SH_VERSION_LEN: u32 = 4;
pub const HW_SH_RESERVE_LEN: u32 = 4;
pub const CONTENT_VERSION_LEN: u32 = 4;
pub const SHA256_SIZE: u32 = 32;
pub const SHA384_SIZE: u32 = 48;
pub const SHA512_SIZE: u32 = 64;
pub const BUF_LEN: u32 = 1024;
pub const BUF_1M: u32 = 1048576;
pub const MAX_PROFILE_SIZE: u32 = 1048576;
pub const MAX_BLOCK_NUM: u32 = 1024;
pub const NORMAL_HASH_SIZE: u32 = 32;
pub const MAX_KEY_PAIR_SIZE: u32 = 4096;
pub const MAX_PK_BUF: u32 = 2068;
pub const CERT_MAX_NAME_LEN: u32 = 512;
pub const CERT_TYPE_APPGALLARY: u32 = 0;
pub const CERT_TYPE_SYETEM: u32 = 1;
pub const CERT_TYPE_OTHER: u32 = 2;
pub const CERT_MAX_DEPTH: u32 = 3;
pub const ALGORITHM_MASK: u32 = 15;
pub const ALGORITHM_SHA256: u32 = 1;
pub const ALGORITHM_SHA384: u32 = 2;
pub const ALGORITHM_SHA512: u32 = 3;
pub const ALGORITHM_PKCS1_SHA256: u32 = 4;
pub const ALGORITHM_PKCS1_SHA384: u32 = 5;
pub const ALGORITHM_PKCS1_SHA512: u32 = 6;
pub const HAP_DIGEST_PRIFIX_LEN: u32 = 5;
pub const MAX_OID_LENGTH: u32 = 128;
pub const HASH_BLOB_LEN: u32 = 1048576;
pub const ONCE_READ_LEN: u32 = 65536;
pub const MBEDTLS_ERR_ASN1_OUT_OF_DATA: i32 = -96;
pub const MBEDTLS_ERR_ASN1_UNEXPECTED_TAG: i32 = -98;
pub const MBEDTLS_ERR_ASN1_INVALID_LENGTH: i32 = -100;
pub const MBEDTLS_ERR_ASN1_LENGTH_MISMATCH: i32 = -102;
pub const MBEDTLS_ERR_ASN1_INVALID_DATA: i32 = -104;
pub const MBEDTLS_ERR_ASN1_ALLOC_FAILED: i32 = -106;
pub const MBEDTLS_ERR_ASN1_BUF_TOO_SMALL: i32 = -108;
pub const MBEDTLS_ASN1_BOOLEAN: u32 = 1;
pub const MBEDTLS_ASN1_INTEGER: u32 = 2;
pub const MBEDTLS_ASN1_BIT_STRING: u32 = 3;
pub const MBEDTLS_ASN1_OCTET_STRING: u32 = 4;
pub const MBEDTLS_ASN1_NULL: u32 = 5;
pub const MBEDTLS_ASN1_OID: u32 = 6;
pub const MBEDTLS_ASN1_ENUMERATED: u32 = 10;
pub const MBEDTLS_ASN1_UTF8_STRING: u32 = 12;
pub const MBEDTLS_ASN1_SEQUENCE: u32 = 16;
pub const MBEDTLS_ASN1_SET: u32 = 17;
pub const MBEDTLS_ASN1_PRINTABLE_STRING: u32 = 19;
pub const MBEDTLS_ASN1_T61_STRING: u32 = 20;
pub const MBEDTLS_ASN1_IA5_STRING: u32 = 22;
pub const MBEDTLS_ASN1_UTC_TIME: u32 = 23;
pub const MBEDTLS_ASN1_GENERALIZED_TIME: u32 = 24;
pub const MBEDTLS_ASN1_UNIVERSAL_STRING: u32 = 28;
pub const MBEDTLS_ASN1_BMP_STRING: u32 = 30;
pub const MBEDTLS_ASN1_PRIMITIVE: u32 = 0;
pub const MBEDTLS_ASN1_CONSTRUCTED: u32 = 32;
pub const MBEDTLS_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const MBEDTLS_ASN1_TAG_CLASS_MASK: u32 = 192;
pub const MBEDTLS_ASN1_TAG_PC_MASK: u32 = 32;
pub const MBEDTLS_ASN1_TAG_VALUE_MASK: u32 = 31;
pub const MBEDTLS_X509_MAX_INTERMEDIATE_CA: u32 = 8;
pub const MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE: i32 = -8320;
pub const MBEDTLS_ERR_X509_UNKNOWN_OID: i32 = -8448;
pub const MBEDTLS_ERR_X509_INVALID_FORMAT: i32 = -8576;
pub const MBEDTLS_ERR_X509_INVALID_VERSION: i32 = -8704;
pub const MBEDTLS_ERR_X509_INVALID_SERIAL: i32 = -8832;
pub const MBEDTLS_ERR_X509_INVALID_ALG: i32 = -8960;
pub const MBEDTLS_ERR_X509_INVALID_NAME: i32 = -9088;
pub const MBEDTLS_ERR_X509_INVALID_DATE: i32 = -9216;
pub const MBEDTLS_ERR_X509_INVALID_SIGNATURE: i32 = -9344;
pub const MBEDTLS_ERR_X509_INVALID_EXTENSIONS: i32 = -9472;
pub const MBEDTLS_ERR_X509_UNKNOWN_VERSION: i32 = -9600;
pub const MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG: i32 = -9728;
pub const MBEDTLS_ERR_X509_SIG_MISMATCH: i32 = -9856;
pub const MBEDTLS_ERR_X509_CERT_VERIFY_FAILED: i32 = -9984;
pub const MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT: i32 = -10112;
pub const MBEDTLS_ERR_X509_BAD_INPUT_DATA: i32 = -10240;
pub const MBEDTLS_ERR_X509_ALLOC_FAILED: i32 = -10368;
pub const MBEDTLS_ERR_X509_FILE_IO_ERROR: i32 = -10496;
pub const MBEDTLS_ERR_X509_BUFFER_TOO_SMALL: i32 = -10624;
pub const MBEDTLS_ERR_X509_FATAL_ERROR: i32 = -12288;
pub const MBEDTLS_X509_BADCERT_EXPIRED: u32 = 1;
pub const MBEDTLS_X509_BADCERT_REVOKED: u32 = 2;
pub const MBEDTLS_X509_BADCERT_CN_MISMATCH: u32 = 4;
pub const MBEDTLS_X509_BADCERT_NOT_TRUSTED: u32 = 8;
pub const MBEDTLS_X509_BADCRL_NOT_TRUSTED: u32 = 16;
pub const MBEDTLS_X509_BADCRL_EXPIRED: u32 = 32;
pub const MBEDTLS_X509_BADCERT_MISSING: u32 = 64;
pub const MBEDTLS_X509_BADCERT_SKIP_VERIFY: u32 = 128;
pub const MBEDTLS_X509_BADCERT_OTHER: u32 = 256;
pub const MBEDTLS_X509_BADCERT_FUTURE: u32 = 512;
pub const MBEDTLS_X509_BADCRL_FUTURE: u32 = 1024;
pub const MBEDTLS_X509_BADCERT_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_X509_BADCERT_EXT_KEY_USAGE: u32 = 4096;
pub const MBEDTLS_X509_BADCERT_NS_CERT_TYPE: u32 = 8192;
pub const MBEDTLS_X509_BADCERT_BAD_MD: u32 = 16384;
pub const MBEDTLS_X509_BADCERT_BAD_PK: u32 = 32768;
pub const MBEDTLS_X509_BADCERT_BAD_KEY: u32 = 65536;
pub const MBEDTLS_X509_BADCRL_BAD_MD: u32 = 131072;
pub const MBEDTLS_X509_BADCRL_BAD_PK: u32 = 262144;
pub const MBEDTLS_X509_BADCRL_BAD_KEY: u32 = 524288;
pub const MBEDTLS_X509_SAN_OTHER_NAME: u32 = 0;
pub const MBEDTLS_X509_SAN_RFC822_NAME: u32 = 1;
pub const MBEDTLS_X509_SAN_DNS_NAME: u32 = 2;
pub const MBEDTLS_X509_SAN_X400_ADDRESS_NAME: u32 = 3;
pub const MBEDTLS_X509_SAN_DIRECTORY_NAME: u32 = 4;
pub const MBEDTLS_X509_SAN_EDI_PARTY_NAME: u32 = 5;
pub const MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER: u32 = 6;
pub const MBEDTLS_X509_SAN_IP_ADDRESS: u32 = 7;
pub const MBEDTLS_X509_SAN_REGISTERED_ID: u32 = 8;
pub const MBEDTLS_X509_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const MBEDTLS_X509_KU_NON_REPUDIATION: u32 = 64;
pub const MBEDTLS_X509_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const MBEDTLS_X509_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const MBEDTLS_X509_KU_KEY_AGREEMENT: u32 = 8;
pub const MBEDTLS_X509_KU_KEY_CERT_SIGN: u32 = 4;
pub const MBEDTLS_X509_KU_CRL_SIGN: u32 = 2;
pub const MBEDTLS_X509_KU_ENCIPHER_ONLY: u32 = 1;
pub const MBEDTLS_X509_KU_DECIPHER_ONLY: u32 = 32768;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT: u32 = 128;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER: u32 = 64;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL: u32 = 32;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING: u32 = 16;
pub const MBEDTLS_X509_NS_CERT_TYPE_RESERVED: u32 = 8;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CA: u32 = 4;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA: u32 = 2;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: u32 = 1;
pub const MBEDTLS_X509_FORMAT_DER: u32 = 1;
pub const MBEDTLS_X509_FORMAT_PEM: u32 = 2;
pub const MBEDTLS_X509_MAX_DN_NAME_SIZE: u32 = 256;
pub const MBEDTLS_X509_CRT_VERSION_1: u32 = 0;
pub const MBEDTLS_X509_CRT_VERSION_2: u32 = 1;
pub const MBEDTLS_X509_CRT_VERSION_3: u32 = 2;
pub const MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN: u32 = 20;
pub const MBEDTLS_X509_RFC5280_UTC_TIME_LEN: u32 = 15;
pub const MBEDTLS_X509_MAX_FILE_PATH_LEN: u32 = 512;
pub const MBEDTLS_X509_MAX_VERIFY_CHAIN_SIZE: u32 = 10;
pub const MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT: i32 = -4224;
pub const MBEDTLS_ERR_PEM_INVALID_DATA: i32 = -4352;
pub const MBEDTLS_ERR_PEM_ALLOC_FAILED: i32 = -4480;
pub const MBEDTLS_ERR_PEM_INVALID_ENC_IV: i32 = -4608;
pub const MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG: i32 = -4736;
pub const MBEDTLS_ERR_PEM_PASSWORD_REQUIRED: i32 = -4864;
pub const MBEDTLS_ERR_PEM_PASSWORD_MISMATCH: i32 = -4992;
pub const MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE: i32 = -5120;
pub const MBEDTLS_ERR_PEM_BAD_INPUT_DATA: i32 = -5248;
pub const MBEDTLS_ERR_OID_NOT_FOUND: i32 = -46;
pub const MBEDTLS_ERR_OID_BUF_TOO_SMALL: i32 = -11;
pub const MBEDTLS_OID_X509_EXT_AUTHORITY_KEY_IDENTIFIER: u32 = 1;
pub const MBEDTLS_OID_X509_EXT_SUBJECT_KEY_IDENTIFIER: u32 = 2;
pub const MBEDTLS_OID_X509_EXT_KEY_USAGE: u32 = 4;
pub const MBEDTLS_OID_X509_EXT_CERTIFICATE_POLICIES: u32 = 8;
pub const MBEDTLS_OID_X509_EXT_POLICY_MAPPINGS: u32 = 16;
pub const MBEDTLS_OID_X509_EXT_SUBJECT_ALT_NAME: u32 = 32;
pub const MBEDTLS_OID_X509_EXT_ISSUER_ALT_NAME: u32 = 64;
pub const MBEDTLS_OID_X509_EXT_SUBJECT_DIRECTORY_ATTRS: u32 = 128;
pub const MBEDTLS_OID_X509_EXT_BASIC_CONSTRAINTS: u32 = 256;
pub const MBEDTLS_OID_X509_EXT_NAME_CONSTRAINTS: u32 = 512;
pub const MBEDTLS_OID_X509_EXT_POLICY_CONSTRAINTS: u32 = 1024;
pub const MBEDTLS_OID_X509_EXT_EXTENDED_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_OID_X509_EXT_CRL_DISTRIBUTION_POINTS: u32 = 4096;
pub const MBEDTLS_OID_X509_EXT_INIHIBIT_ANYPOLICY: u32 = 8192;
pub const MBEDTLS_OID_X509_EXT_FRESHEST_CRL: u32 = 16384;
pub const MBEDTLS_OID_X509_EXT_NS_CERT_TYPE: u32 = 65536;
pub const MBEDTLS_OID_MAX_COMPONENTS: u32 = 128;
pub const MBEDTLS_OID_ISO_MEMBER_BODIES: &[u8; 2] = b"*\0";
pub const MBEDTLS_OID_ISO_IDENTIFIED_ORG: &[u8; 2] = b"+\0";
pub const MBEDTLS_OID_ISO_CCITT_DS: &[u8; 2] = b"U\0";
pub const MBEDTLS_OID_ISO_ITU_COUNTRY: &[u8; 2] = b"`\0";
pub const MBEDTLS_OID_COUNTRY_US: &[u8; 3] = b"\x86H\0";
pub const MBEDTLS_OID_ORG_RSA_DATA_SECURITY: &[u8; 4] = b"\x86\xF7\r\0";
pub const MBEDTLS_OID_RSA_COMPANY: &[u8; 7] = b"*\x86H\x86\xF7\r\0";
pub const MBEDTLS_OID_ORG_ANSI_X9_62: &[u8; 3] = b"\xCE=\0";
pub const MBEDTLS_OID_ANSI_X9_62: &[u8; 6] = b"*\x86H\xCE=\0";
pub const MBEDTLS_OID_ORG_DOD: &[u8; 2] = b"\x06\0";
pub const MBEDTLS_OID_ORG_OIW: &[u8; 2] = b"\x0E\0";
pub const MBEDTLS_OID_OIW_SECSIG: &[u8; 3] = b"\x0E\x03\0";
pub const MBEDTLS_OID_OIW_SECSIG_ALG: &[u8; 4] = b"\x0E\x03\x02\0";
pub const MBEDTLS_OID_OIW_SECSIG_SHA1: &[u8; 5] = b"\x0E\x03\x02\x1A\0";
pub const MBEDTLS_OID_ORG_THAWTE: &[u8; 2] = b"e\0";
pub const MBEDTLS_OID_THAWTE: &[u8; 3] = b"+e\0";
pub const MBEDTLS_OID_ORG_CERTICOM: &[u8; 3] = b"\x81\x04\0";
pub const MBEDTLS_OID_CERTICOM: &[u8; 4] = b"+\x81\x04\0";
pub const MBEDTLS_OID_ORG_TELETRUST: &[u8; 2] = b"$\0";
pub const MBEDTLS_OID_TELETRUST: &[u8; 3] = b"+$\0";
pub const MBEDTLS_OID_ORGANIZATION: &[u8; 2] = b"\x01\0";
pub const MBEDTLS_OID_ISO_ITU_US_ORG: &[u8; 5] = b"`\x86H\x01\0";
pub const MBEDTLS_OID_ORG_GOV: &[u8; 2] = b"e\0";
pub const MBEDTLS_OID_GOV: &[u8; 6] = b"`\x86H\x01e\0";
pub const MBEDTLS_OID_ORG_NETSCAPE: &[u8; 4] = b"\x86\xF8B\0";
pub const MBEDTLS_OID_NETSCAPE: &[u8; 8] = b"`\x86H\x01\x86\xF8B\0";
pub const MBEDTLS_OID_ID_CE: &[u8; 3] = b"U\x1D\0";
pub const MBEDTLS_OID_NIST_ALG: &[u8; 8] = b"`\x86H\x01e\x03\x04\0";
pub const MBEDTLS_OID_INTERNET: &[u8; 4] = b"+\x06\x01\0";
pub const MBEDTLS_OID_PKIX: &[u8; 7] = b"+\x06\x01\x05\x05\x07\0";
pub const MBEDTLS_OID_AT: &[u8; 3] = b"U\x04\0";
pub const MBEDTLS_OID_AT_CN: &[u8; 4] = b"U\x04\x03\0";
pub const MBEDTLS_OID_AT_SUR_NAME: &[u8; 4] = b"U\x04\x04\0";
pub const MBEDTLS_OID_AT_SERIAL_NUMBER: &[u8; 4] = b"U\x04\x05\0";
pub const MBEDTLS_OID_AT_COUNTRY: &[u8; 4] = b"U\x04\x06\0";
pub const MBEDTLS_OID_AT_LOCALITY: &[u8; 4] = b"U\x04\x07\0";
pub const MBEDTLS_OID_AT_STATE: &[u8; 4] = b"U\x04\x08\0";
pub const MBEDTLS_OID_AT_ORGANIZATION: &[u8; 4] = b"U\x04\n\0";
pub const MBEDTLS_OID_AT_ORG_UNIT: &[u8; 4] = b"U\x04\x0B\0";
pub const MBEDTLS_OID_AT_TITLE: &[u8; 4] = b"U\x04\x0C\0";
pub const MBEDTLS_OID_AT_POSTAL_ADDRESS: &[u8; 4] = b"U\x04\x10\0";
pub const MBEDTLS_OID_AT_POSTAL_CODE: &[u8; 4] = b"U\x04\x11\0";
pub const MBEDTLS_OID_AT_GIVEN_NAME: &[u8; 4] = b"U\x04*\0";
pub const MBEDTLS_OID_AT_INITIALS: &[u8; 4] = b"U\x04+\0";
pub const MBEDTLS_OID_AT_GENERATION_QUALIFIER: &[u8; 4] = b"U\x04,\0";
pub const MBEDTLS_OID_AT_UNIQUE_IDENTIFIER: &[u8; 4] = b"U\x04-\0";
pub const MBEDTLS_OID_AT_DN_QUALIFIER: &[u8; 4] = b"U\x04.\0";
pub const MBEDTLS_OID_AT_PSEUDONYM: &[u8; 4] = b"U\x04A\0";
pub const MBEDTLS_OID_UID: &[u8; 11] = b"\t\x92&\x89\x93\xF2,d\x01\x01\0";
pub const MBEDTLS_OID_DOMAIN_COMPONENT: &[u8; 11] = b"\t\x92&\x89\x93\xF2,d\x01\x19\0";
pub const MBEDTLS_OID_AUTHORITY_KEY_IDENTIFIER: &[u8; 4] = b"U\x1D#\0";
pub const MBEDTLS_OID_SUBJECT_KEY_IDENTIFIER: &[u8; 4] = b"U\x1D\x0E\0";
pub const MBEDTLS_OID_KEY_USAGE: &[u8; 4] = b"U\x1D\x0F\0";
pub const MBEDTLS_OID_CERTIFICATE_POLICIES: &[u8; 4] = b"U\x1D \0";
pub const MBEDTLS_OID_POLICY_MAPPINGS: &[u8; 4] = b"U\x1D!\0";
pub const MBEDTLS_OID_SUBJECT_ALT_NAME: &[u8; 4] = b"U\x1D\x11\0";
pub const MBEDTLS_OID_ISSUER_ALT_NAME: &[u8; 4] = b"U\x1D\x12\0";
pub const MBEDTLS_OID_SUBJECT_DIRECTORY_ATTRS: &[u8; 4] = b"U\x1D\t\0";
pub const MBEDTLS_OID_BASIC_CONSTRAINTS: &[u8; 4] = b"U\x1D\x13\0";
pub const MBEDTLS_OID_NAME_CONSTRAINTS: &[u8; 4] = b"U\x1D\x1E\0";
pub const MBEDTLS_OID_POLICY_CONSTRAINTS: &[u8; 4] = b"U\x1D$\0";
pub const MBEDTLS_OID_EXTENDED_KEY_USAGE: &[u8; 4] = b"U\x1D%\0";
pub const MBEDTLS_OID_CRL_DISTRIBUTION_POINTS: &[u8; 4] = b"U\x1D\x1F\0";
pub const MBEDTLS_OID_INIHIBIT_ANYPOLICY: &[u8; 4] = b"U\x1D6\0";
pub const MBEDTLS_OID_FRESHEST_CRL: &[u8; 4] = b"U\x1D.\0";
pub const MBEDTLS_OID_ANY_POLICY: &[u8; 5] = b"U\x1D \0\0";
pub const MBEDTLS_OID_NS_CERT: &[u8; 9] = b"`\x86H\x01\x86\xF8B\x01\0";
pub const MBEDTLS_OID_NS_CERT_TYPE: &[u8; 10] = b"`\x86H\x01\x86\xF8B\x01\x01\0";
pub const MBEDTLS_OID_NS_BASE_URL: &[u8; 10] = b"`\x86H\x01\x86\xF8B\x01\x02\0";
pub const MBEDTLS_OID_NS_REVOCATION_URL: &[u8; 10] = b"`\x86H\x01\x86\xF8B\x01\x03\0";
pub const MBEDTLS_OID_NS_CA_REVOCATION_URL: &[u8; 10] = b"`\x86H\x01\x86\xF8B\x01\x04\0";
pub const MBEDTLS_OID_NS_RENEWAL_URL: &[u8; 10] = b"`\x86H\x01\x86\xF8B\x01\x07\0";
pub const MBEDTLS_OID_NS_CA_POLICY_URL: &[u8; 10] = b"`\x86H\x01\x86\xF8B\x01\x08\0";
pub const MBEDTLS_OID_NS_SSL_SERVER_NAME: &[u8; 10] = b"`\x86H\x01\x86\xF8B\x01\x0C\0";
pub const MBEDTLS_OID_NS_COMMENT: &[u8; 10] = b"`\x86H\x01\x86\xF8B\x01\r\0";
pub const MBEDTLS_OID_NS_DATA_TYPE: &[u8; 9] = b"`\x86H\x01\x86\xF8B\x02\0";
pub const MBEDTLS_OID_NS_CERT_SEQUENCE: &[u8; 10] = b"`\x86H\x01\x86\xF8B\x02\x05\0";
pub const MBEDTLS_OID_PRIVATE_KEY_USAGE_PERIOD: &[u8; 4] = b"U\x1D\x10\0";
pub const MBEDTLS_OID_CRL_NUMBER: &[u8; 4] = b"U\x1D\x14\0";
pub const MBEDTLS_OID_ANY_EXTENDED_KEY_USAGE: &[u8; 5] = b"U\x1D%\0\0";
pub const MBEDTLS_OID_KP: &[u8; 8] = b"+\x06\x01\x05\x05\x07\x03\0";
pub const MBEDTLS_OID_SERVER_AUTH: &[u8; 9] = b"+\x06\x01\x05\x05\x07\x03\x01\0";
pub const MBEDTLS_OID_CLIENT_AUTH: &[u8; 9] = b"+\x06\x01\x05\x05\x07\x03\x02\0";
pub const MBEDTLS_OID_CODE_SIGNING: &[u8; 9] = b"+\x06\x01\x05\x05\x07\x03\x03\0";
pub const MBEDTLS_OID_EMAIL_PROTECTION: &[u8; 9] = b"+\x06\x01\x05\x05\x07\x03\x04\0";
pub const MBEDTLS_OID_TIME_STAMPING: &[u8; 9] = b"+\x06\x01\x05\x05\x07\x03\x08\0";
pub const MBEDTLS_OID_OCSP_SIGNING: &[u8; 9] = b"+\x06\x01\x05\x05\x07\x03\t\0";
pub const MBEDTLS_OID_WISUN_FAN: &[u8; 10] = b"+\x06\x01\x04\x01\x82\xE4%\x01\0";
pub const MBEDTLS_OID_ON: &[u8; 8] = b"+\x06\x01\x05\x05\x07\x08\0";
pub const MBEDTLS_OID_ON_HW_MODULE_NAME: &[u8; 9] = b"+\x06\x01\x05\x05\x07\x08\x04\0";
pub const MBEDTLS_OID_PKCS: &[u8; 8] = b"*\x86H\x86\xF7\r\x01\0";
pub const MBEDTLS_OID_PKCS1: &[u8; 9] = b"*\x86H\x86\xF7\r\x01\x01\0";
pub const MBEDTLS_OID_PKCS5: &[u8; 9] = b"*\x86H\x86\xF7\r\x01\x05\0";
pub const MBEDTLS_OID_PKCS7: &[u8; 9] = b"*\x86H\x86\xF7\r\x01\x07\0";
pub const MBEDTLS_OID_PKCS9: &[u8; 9] = b"*\x86H\x86\xF7\r\x01\t\0";
pub const MBEDTLS_OID_PKCS12: &[u8; 9] = b"*\x86H\x86\xF7\r\x01\x0C\0";
pub const MBEDTLS_OID_PKCS1_RSA: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x01\x01\0";
pub const MBEDTLS_OID_PKCS1_MD5: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x01\x04\0";
pub const MBEDTLS_OID_PKCS1_SHA1: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x01\x05\0";
pub const MBEDTLS_OID_PKCS1_SHA224: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x01\x0E\0";
pub const MBEDTLS_OID_PKCS1_SHA256: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x01\x0B\0";
pub const MBEDTLS_OID_PKCS1_SHA384: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x01\x0C\0";
pub const MBEDTLS_OID_PKCS1_SHA512: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x01\r\0";
pub const MBEDTLS_OID_RSA_SHA_OBS: &[u8; 6] = b"+\x0E\x03\x02\x1D\0";
pub const MBEDTLS_OID_PKCS9_EMAIL: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\t\x01\0";
pub const MBEDTLS_OID_RSASSA_PSS: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x01\n\0";
pub const MBEDTLS_OID_MGF1: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x01\x08\0";
pub const MBEDTLS_OID_DIGEST_ALG_MD5: &[u8; 9] = b"*\x86H\x86\xF7\r\x02\x05\0";
pub const MBEDTLS_OID_DIGEST_ALG_SHA1: &[u8; 6] = b"+\x0E\x03\x02\x1A\0";
pub const MBEDTLS_OID_DIGEST_ALG_SHA224: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\x04\0";
pub const MBEDTLS_OID_DIGEST_ALG_SHA256: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\x01\0";
pub const MBEDTLS_OID_DIGEST_ALG_SHA384: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\x02\0";
pub const MBEDTLS_OID_DIGEST_ALG_SHA512: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\x03\0";
pub const MBEDTLS_OID_DIGEST_ALG_RIPEMD160: &[u8; 6] = b"+$\x03\x02\x01\0";
pub const MBEDTLS_OID_DIGEST_ALG_SHA3_224: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\x07\0";
pub const MBEDTLS_OID_DIGEST_ALG_SHA3_256: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\x08\0";
pub const MBEDTLS_OID_DIGEST_ALG_SHA3_384: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\t\0";
pub const MBEDTLS_OID_DIGEST_ALG_SHA3_512: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\n\0";
pub const MBEDTLS_OID_HMAC_SHA1: &[u8; 9] = b"*\x86H\x86\xF7\r\x02\x07\0";
pub const MBEDTLS_OID_HMAC_SHA224: &[u8; 9] = b"*\x86H\x86\xF7\r\x02\x08\0";
pub const MBEDTLS_OID_HMAC_SHA256: &[u8; 9] = b"*\x86H\x86\xF7\r\x02\t\0";
pub const MBEDTLS_OID_HMAC_SHA384: &[u8; 9] = b"*\x86H\x86\xF7\r\x02\n\0";
pub const MBEDTLS_OID_HMAC_SHA512: &[u8; 9] = b"*\x86H\x86\xF7\r\x02\x0B\0";
pub const MBEDTLS_OID_HMAC_SHA3_224: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\r\0";
pub const MBEDTLS_OID_HMAC_SHA3_256: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\x0E\0";
pub const MBEDTLS_OID_HMAC_SHA3_384: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\x0F\0";
pub const MBEDTLS_OID_HMAC_SHA3_512: &[u8; 10] = b"`\x86H\x01e\x03\x04\x02\x10\0";
pub const MBEDTLS_OID_HMAC_RIPEMD160: &[u8; 9] = b"+\x06\x01\x05\x05\x08\x01\x04\0";
pub const MBEDTLS_OID_DES_CBC: &[u8; 6] = b"+\x0E\x03\x02\x07\0";
pub const MBEDTLS_OID_DES_EDE3_CBC: &[u8; 9] = b"*\x86H\x86\xF7\r\x03\x07\0";
pub const MBEDTLS_OID_AES: &[u8; 9] = b"`\x86H\x01e\x03\x04\x01\0";
pub const MBEDTLS_OID_AES_128_CBC: &[u8; 10] = b"`\x86H\x01e\x03\x04\x01\x02\0";
pub const MBEDTLS_OID_AES_192_CBC: &[u8; 10] = b"`\x86H\x01e\x03\x04\x01\x16\0";
pub const MBEDTLS_OID_AES_256_CBC: &[u8; 10] = b"`\x86H\x01e\x03\x04\x01*\0";
pub const MBEDTLS_OID_AES128_KW: &[u8; 10] = b"`\x86H\x01e\x03\x04\x01\x05\0";
pub const MBEDTLS_OID_AES128_KWP: &[u8; 10] = b"`\x86H\x01e\x03\x04\x01\x08\0";
pub const MBEDTLS_OID_AES192_KW: &[u8; 10] = b"`\x86H\x01e\x03\x04\x01\x19\0";
pub const MBEDTLS_OID_AES192_KWP: &[u8; 10] = b"`\x86H\x01e\x03\x04\x01\x1C\0";
pub const MBEDTLS_OID_AES256_KW: &[u8; 10] = b"`\x86H\x01e\x03\x04\x01-\0";
pub const MBEDTLS_OID_AES256_KWP: &[u8; 10] = b"`\x86H\x01e\x03\x04\x010\0";
pub const MBEDTLS_OID_PKCS5_PBKDF2: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x05\x0C\0";
pub const MBEDTLS_OID_PKCS5_PBES2: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x05\r\0";
pub const MBEDTLS_OID_PKCS5_PBMAC1: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x05\x0E\0";
pub const MBEDTLS_OID_PKCS5_PBE_MD5_DES_CBC: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x05\x03\0";
pub const MBEDTLS_OID_PKCS5_PBE_MD5_RC2_CBC: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x05\x06\0";
pub const MBEDTLS_OID_PKCS5_PBE_SHA1_DES_CBC: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x05\n\0";
pub const MBEDTLS_OID_PKCS5_PBE_SHA1_RC2_CBC: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x05\x0B\0";
pub const MBEDTLS_OID_PKCS7_DATA: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x07\x01\0";
pub const MBEDTLS_OID_PKCS7_SIGNED_DATA: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x07\x02\0";
pub const MBEDTLS_OID_PKCS7_ENVELOPED_DATA: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x07\x03\0";
pub const MBEDTLS_OID_PKCS7_SIGNED_AND_ENVELOPED_DATA: &[u8; 10] =
    b"*\x86H\x86\xF7\r\x01\x07\x04\0";
pub const MBEDTLS_OID_PKCS7_DIGESTED_DATA: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x07\x05\0";
pub const MBEDTLS_OID_PKCS7_ENCRYPTED_DATA: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x07\x06\0";
pub const MBEDTLS_OID_PKCS9_CSR_EXT_REQ: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\t\x0E\0";
pub const MBEDTLS_OID_PKCS12_PBE: &[u8; 10] = b"*\x86H\x86\xF7\r\x01\x0C\x01\0";
pub const MBEDTLS_OID_PKCS12_PBE_SHA1_DES3_EDE_CBC: &[u8; 11] =
    b"*\x86H\x86\xF7\r\x01\x0C\x01\x03\0";
pub const MBEDTLS_OID_PKCS12_PBE_SHA1_DES2_EDE_CBC: &[u8; 11] =
    b"*\x86H\x86\xF7\r\x01\x0C\x01\x04\0";
pub const MBEDTLS_OID_PKCS12_PBE_SHA1_RC2_128_CBC: &[u8; 11] =
    b"*\x86H\x86\xF7\r\x01\x0C\x01\x05\0";
pub const MBEDTLS_OID_PKCS12_PBE_SHA1_RC2_40_CBC: &[u8; 11] = b"*\x86H\x86\xF7\r\x01\x0C\x01\x06\0";
pub const MBEDTLS_OID_EC_ALG_UNRESTRICTED: &[u8; 8] = b"*\x86H\xCE=\x02\x01\0";
pub const MBEDTLS_OID_EC_ALG_ECDH: &[u8; 6] = b"+\x81\x04\x01\x0C\0";
pub const MBEDTLS_OID_EC_GRP_SECP192R1: &[u8; 9] = b"*\x86H\xCE=\x03\x01\x01\0";
pub const MBEDTLS_OID_EC_GRP_SECP224R1: &[u8; 6] = b"+\x81\x04\0!\0";
pub const MBEDTLS_OID_EC_GRP_SECP256R1: &[u8; 9] = b"*\x86H\xCE=\x03\x01\x07\0";
pub const MBEDTLS_OID_EC_GRP_SECP384R1: &[u8; 6] = b"+\x81\x04\0\"\0";
pub const MBEDTLS_OID_EC_GRP_SECP521R1: &[u8; 6] = b"+\x81\x04\0#\0";
pub const MBEDTLS_OID_EC_GRP_SECP192K1: &[u8; 6] = b"+\x81\x04\0\x1F\0";
pub const MBEDTLS_OID_EC_GRP_SECP224K1: &[u8; 6] = b"+\x81\x04\0 \0";
pub const MBEDTLS_OID_EC_GRP_SECP256K1: &[u8; 6] = b"+\x81\x04\0\n\0";
pub const MBEDTLS_OID_EC_BRAINPOOL_V1: &[u8; 9] = b"+$\x03\x03\x02\x08\x01\x01\0";
pub const MBEDTLS_OID_EC_GRP_BP256R1: &[u8; 10] = b"+$\x03\x03\x02\x08\x01\x01\x07\0";
pub const MBEDTLS_OID_EC_GRP_BP384R1: &[u8; 10] = b"+$\x03\x03\x02\x08\x01\x01\x0B\0";
pub const MBEDTLS_OID_EC_GRP_BP512R1: &[u8; 10] = b"+$\x03\x03\x02\x08\x01\x01\r\0";
pub const MBEDTLS_OID_ANSI_X9_62_FIELD_TYPE: &[u8; 7] = b"*\x86H\xCE=\x01\0";
pub const MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD: &[u8; 8] = b"*\x86H\xCE=\x01\x01\0";
pub const MBEDTLS_OID_ANSI_X9_62_SIG: &[u8; 7] = b"*\x86H\xCE=\x04\0";
pub const MBEDTLS_OID_ANSI_X9_62_SIG_SHA2: &[u8; 8] = b"*\x86H\xCE=\x04\x03\0";
pub const MBEDTLS_OID_ECDSA_SHA1: &[u8; 8] = b"*\x86H\xCE=\x04\x01\0";
pub const MBEDTLS_OID_ECDSA_SHA224: &[u8; 9] = b"*\x86H\xCE=\x04\x03\x01\0";
pub const MBEDTLS_OID_ECDSA_SHA256: &[u8; 9] = b"*\x86H\xCE=\x04\x03\x02\0";
pub const MBEDTLS_OID_ECDSA_SHA384: &[u8; 9] = b"*\x86H\xCE=\x04\x03\x03\0";
pub const MBEDTLS_OID_ECDSA_SHA512: &[u8; 9] = b"*\x86H\xCE=\x04\x03\x04\0";
pub const MBEDTLS_OID_X25519: &[u8; 4] = b"+en\0";
pub const MBEDTLS_OID_X448: &[u8; 4] = b"+eo\0";
pub const MBEDTLS_OID_ED25519: &[u8; 4] = b"+ep\0";
pub const MBEDTLS_OID_ED448: &[u8; 4] = b"+eq\0";
pub const MAX_SIGNER_NAME_LEN: u32 = 512;
pub const PARAM_CONST_VALUE_LEN_MAX: u32 = 4096;
pub const PARAM_VALUE_LEN_MAX: u32 = 96;
pub const PARAM_NAME_LEN_MAX: u32 = 96;
pub const OS_FULL_NAME_LEN: u32 = 128;
pub const VERSION_ID_MAX_LEN: u32 = 256;
pub const PARAM_BUFFER_MAX: u32 = 65536;
pub const CJSON_VERSION_MAJOR: u32 = 1;
pub const CJSON_VERSION_MINOR: u32 = 7;
pub const CJSON_VERSION_PATCH: u32 = 17;
pub const cJSON_Invalid: u32 = 0;
pub const cJSON_False: u32 = 1;
pub const cJSON_True: u32 = 2;
pub const cJSON_NULL: u32 = 4;
pub const cJSON_Number: u32 = 8;
pub const cJSON_String: u32 = 16;
pub const cJSON_Array: u32 = 32;
pub const cJSON_Object: u32 = 64;
pub const cJSON_Raw: u32 = 128;
pub const cJSON_IsReference: u32 = 256;
pub const cJSON_StringIsConst: u32 = 512;
pub const CJSON_NESTING_LIMIT: u32 = 1000;
pub const MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL: i32 = -42;
pub const MBEDTLS_ERR_BASE64_INVALID_CHARACTER: i32 = -44;
pub const SECUREC_USING_STD_SECURE_LIB: u32 = 0;
pub const SECUREC_DISABLE_CRT_FUNC: u32 = 0;
pub const SECUREC_DISABLE_CRT_IMP: u32 = 0;
pub const SECUREC_IN_KERNEL: u32 = 0;
pub const SECUREC_EXPORT_KERNEL_SYMBOL: u32 = 0;
pub const SECUREC_ENABLE_SCANF_FILE: u32 = 1;
pub const SECUREC_ENABLE_WCHAR_FUNC: u32 = 1;
pub const SECUREC_SNPRINTF_TRUNCATED: u32 = 1;
pub const SECUREC_ENABLE_MEMSET: u32 = 1;
pub const SECUREC_ENABLE_MEMMOVE: u32 = 1;
pub const SECUREC_ENABLE_MEMCPY: u32 = 1;
pub const SECUREC_ENABLE_STRCPY: u32 = 1;
pub const SECUREC_ENABLE_STRNCPY: u32 = 1;
pub const SECUREC_ENABLE_STRCAT: u32 = 1;
pub const SECUREC_ENABLE_STRNCAT: u32 = 1;
pub const SECUREC_ENABLE_SPRINTF: u32 = 1;
pub const SECUREC_ENABLE_VSPRINTF: u32 = 1;
pub const SECUREC_ENABLE_SNPRINTF: u32 = 1;
pub const SECUREC_ENABLE_VSNPRINTF: u32 = 1;
pub const SECUREC_ENABLE_SSCANF: u32 = 1;
pub const SECUREC_ENABLE_VSSCANF: u32 = 1;
pub const SECUREC_ENABLE_SCANF: u32 = 1;
pub const SECUREC_ENABLE_VSCANF: u32 = 1;
pub const SECUREC_ENABLE_FSCANF: u32 = 1;
pub const SECUREC_ENABLE_VFSCANF: u32 = 1;
pub const SECUREC_ENABLE_STRTOK: u32 = 1;
pub const SECUREC_ENABLE_GETS: u32 = 1;
pub const SECUREC_HAVE_STDIO_H: u32 = 1;
pub const SECUREC_HAVE_STRING_H: u32 = 1;
pub const SECUREC_HAVE_STDLIB_H: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const SECUREC_WITH_PERFORMANCE_ADDONS: u32 = 1;
pub const SECUREC_HAVE_STDDEF_H: u32 = 1;
pub const SECUREC_SUPPORT_FORMAT_WARNING: u32 = 0;
pub const SECUREC_SUPPORT_BUILTIN_EXPECT: u32 = 1;
pub const SECUREC_STRING_MAX_LEN: u32 = 2147483647;
pub const SECUREC_MEM_MAX_LEN: u32 = 2147483647;
pub const SECUREC_SUPPORT_STRTOLD: u32 = 0;
pub const SECUREC_HAVE_STDARG_H: u32 = 1;
pub const SECUREC_HAVE_ERRNO_H: u32 = 1;
pub const ENOERR: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const ENOTSUP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const EOK: u32 = 0;
pub const EINVAL_AND_RESET: u32 = 150;
pub const ERANGE_AND_RESET: u32 = 162;
pub const EOVERLAP_AND_RESET: u32 = 182;
pub const SECUREC_ONLY_DECLARE_MEMSET: u32 = 0;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const NUM_SIGNAL_ACTIONS: u32 = 16;
pub const SI_ASYNCNL: i32 = -60;
pub const SI_TKILL: i32 = -6;
pub const SI_SIGIO: i32 = -5;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SI_TIMER: i32 = -2;
pub const SI_QUEUE: u32 = 2;
pub const SI_USER: u32 = 1;
pub const SI_KERNEL: u32 = 128;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_SIGINFO: u32 = 2;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_RESTORER: u32 = 67108864;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const _NSIG: u32 = 65;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_MTEAERR: u32 = 8;
pub const SEGV_MTESERR: u32 = 9;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const SA_UNSUPPORTED: u32 = 1024;
pub const SA_EXPOSE_TAGBITS: u32 = 2048;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const SIGRTMIN: u32 = 35;
pub const SIGRTMAX: u32 = 64;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const NSIG: u32 = 65;
pub const SYS_SECCOMP: u32 = 1;
pub const SYS_USER_DISPATCH: u32 = 2;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const FD_SETSIZE: u32 = 1024;
pub const FD_SET_TOTAL_SIZE: u32 = 1024;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const TIME_UTC: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const TIMER_ABSTIME: u32 = 1;
pub const __PRI64: &[u8; 3] = b"ll\0";
pub const __PRIPTR: &[u8; 1] = b"\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 2] = b"d\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 2] = b"i\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 2] = b"o\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 2] = b"u\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 2] = b"x\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 2] = b"X\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdMAX: &[u8; 4] = b"lld\0";
pub const PRIiMAX: &[u8; 4] = b"lli\0";
pub const PRIoMAX: &[u8; 4] = b"llo\0";
pub const PRIuMAX: &[u8; 4] = b"llu\0";
pub const PRIxMAX: &[u8; 4] = b"llx\0";
pub const PRIXMAX: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 2] = b"d\0";
pub const PRIiPTR: &[u8; 2] = b"i\0";
pub const PRIoPTR: &[u8; 2] = b"o\0";
pub const PRIuPTR: &[u8; 2] = b"u\0";
pub const PRIxPTR: &[u8; 2] = b"x\0";
pub const PRIXPTR: &[u8; 2] = b"X\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 2] = b"d\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 2] = b"i\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 2] = b"u\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 2] = b"o\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 2] = b"x\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdMAX: &[u8; 4] = b"lld\0";
pub const SCNiMAX: &[u8; 4] = b"lli\0";
pub const SCNoMAX: &[u8; 4] = b"llo\0";
pub const SCNuMAX: &[u8; 4] = b"llu\0";
pub const SCNxMAX: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 2] = b"d\0";
pub const SCNiPTR: &[u8; 2] = b"i\0";
pub const SCNoPTR: &[u8; 2] = b"o\0";
pub const SCNuPTR: &[u8; 2] = b"u\0";
pub const SCNxPTR: &[u8; 2] = b"x\0";
pub const MBEDTLS_EXIT_SUCCESS: u32 = 0;
pub const MBEDTLS_EXIT_FAILURE: u32 = 1;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __ll: ::core::ffi::c_longlong,
    pub __ld: f64,
}
pub type size_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [::core::ffi::c_ulong; 1usize],
}
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i32;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u32;
pub type uint_fast32_t = u32;
pub type UINT8 = ::core::ffi::c_uchar;
pub type UINT16 = ::core::ffi::c_ushort;
pub type UINT32 = ::core::ffi::c_uint;
pub type INT8 = ::core::ffi::c_schar;
pub type INT16 = ::core::ffi::c_short;
pub type INT32 = ::core::ffi::c_int;
pub type FLOAT = f32;
pub type DOUBLE = f64;
pub type CHAR = ::core::ffi::c_char;
pub type UINT64 = ::core::ffi::c_ulonglong;
pub type INT64 = ::core::ffi::c_longlong;
pub type UINTPTR = ::core::ffi::c_uint;
pub type INTPTR = ::core::ffi::c_int;
pub type ssize_t = INT32;
pub type AARCHPTR = UINTPTR;
pub type BOOL = size_t;
pub type status_t = ::core::ffi::c_int;
pub type vaddr_t = ::core::ffi::c_ulong;
pub type PADDR_T = ::core::ffi::c_ulong;
pub type VADDR_T = ::core::ffi::c_ulong;
pub type paddr_t = ::core::ffi::c_ulong;
pub type DMA_ADDR_T = ::core::ffi::c_ulong;
pub type ADDR_T = ::core::ffi::c_ulong;
pub type VM_OFFSET_T = ::core::ffi::c_ulong;
pub type PTE_T = ::core::ffi::c_ulong;
pub type ULONG_T = ::core::ffi::c_uint;
pub type STATUS_T = ::core::ffi::c_int;
pub type LOS_ERRORHANDLE_FUNC = ::core::option::Option<
    unsafe extern "C" fn(
        fileName: *mut CHAR,
        lineNo: UINT32,
        errorNo: UINT32,
        paraLen: UINT32,
        para: *mut ::core::ffi::c_void,
    ),
>;
pub const LOS_MOD_SYS: LOS_MOUDLE_ID = 0;
pub const LOS_MOD_MEM: LOS_MOUDLE_ID = 1;
pub const LOS_MOD_TSK: LOS_MOUDLE_ID = 2;
pub const LOS_MOD_SWTMR: LOS_MOUDLE_ID = 3;
pub const LOS_MOD_TICK: LOS_MOUDLE_ID = 4;
pub const LOS_MOD_MSG: LOS_MOUDLE_ID = 5;
pub const LOS_MOD_QUE: LOS_MOUDLE_ID = 6;
pub const LOS_MOD_SEM: LOS_MOUDLE_ID = 7;
pub const LOS_MOD_MBOX: LOS_MOUDLE_ID = 8;
pub const LOS_MOD_HWI: LOS_MOUDLE_ID = 9;
pub const LOS_MOD_HWWDG: LOS_MOUDLE_ID = 10;
pub const LOS_MOD_CACHE: LOS_MOUDLE_ID = 11;
pub const LOS_MOD_HWTMR: LOS_MOUDLE_ID = 12;
pub const LOS_MOD_MMU: LOS_MOUDLE_ID = 13;
pub const LOS_MOD_LOG: LOS_MOUDLE_ID = 14;
pub const LOS_MOD_ERR: LOS_MOUDLE_ID = 15;
pub const LOS_MOD_EXC: LOS_MOUDLE_ID = 16;
pub const LOS_MOD_CSTK: LOS_MOUDLE_ID = 17;
pub const LOS_MOD_MPU: LOS_MOUDLE_ID = 18;
pub const LOS_MOD_NMHWI: LOS_MOUDLE_ID = 19;
pub const LOS_MOD_TRACE: LOS_MOUDLE_ID = 20;
pub const LOS_MOD_KNLSTAT: LOS_MOUDLE_ID = 21;
pub const LOS_MOD_EVTTIME: LOS_MOUDLE_ID = 22;
pub const LOS_MOD_THRDCPUP: LOS_MOUDLE_ID = 23;
pub const LOS_MOD_IPC: LOS_MOUDLE_ID = 24;
pub const LOS_MOD_STKMON: LOS_MOUDLE_ID = 25;
pub const LOS_MOD_TIMER: LOS_MOUDLE_ID = 26;
pub const LOS_MOD_RESLEAKMON: LOS_MOUDLE_ID = 27;
pub const LOS_MOD_EVENT: LOS_MOUDLE_ID = 28;
pub const LOS_MOD_MUX: LOS_MOUDLE_ID = 29;
pub const LOS_MOD_CPUP: LOS_MOUDLE_ID = 30;
pub const LOS_MOD_HOOK: LOS_MOUDLE_ID = 31;
pub const LOS_MOD_PERF: LOS_MOUDLE_ID = 32;
pub const LOS_MOD_PM: LOS_MOUDLE_ID = 33;
pub const LOS_MOD_SHELL: LOS_MOUDLE_ID = 49;
pub const LOS_MOD_DRIVER: LOS_MOUDLE_ID = 65;
pub const LOS_MOD_BUTT: LOS_MOUDLE_ID = 66;
pub type LOS_MOUDLE_ID = ::core::ffi::c_uint;
unsafe extern "C" {
    pub static mut g_sysClock: UINT32;
}
unsafe extern "C" {
    pub static mut g_tickPerSecond: UINT32;
}
unsafe extern "C" {
    pub static mut __int_stack_start: CHAR;
}
unsafe extern "C" {
    pub static mut __rodata_start: CHAR;
}
unsafe extern "C" {
    pub static mut __rodata_end: CHAR;
}
unsafe extern "C" {
    pub static mut __bss_start: CHAR;
}
unsafe extern "C" {
    pub static mut __bss_end: CHAR;
}
unsafe extern "C" {
    pub static mut __text_start: CHAR;
}
unsafe extern "C" {
    pub static mut __text_end: CHAR;
}
unsafe extern "C" {
    pub static mut __ram_data_start: CHAR;
}
unsafe extern "C" {
    pub static mut __ram_data_end: CHAR;
}
unsafe extern "C" {
    pub static mut __heap_start: UINT32;
}
unsafe extern "C" {
    pub static mut __heap_end: UINT32;
}
pub type SystemRebootFunc = ::core::option::Option<unsafe extern "C" fn()>;
pub type mbedtls_iso_c_forbids_empty_translation_units = ::core::ffi::c_int;
pub const MBEDTLS_MD_NONE: mbedtls_md_type_t = 0;
pub const MBEDTLS_MD_MD5: mbedtls_md_type_t = 1;
pub const MBEDTLS_MD_RIPEMD160: mbedtls_md_type_t = 4;
pub const MBEDTLS_MD_SHA1: mbedtls_md_type_t = 5;
pub const MBEDTLS_MD_SHA224: mbedtls_md_type_t = 8;
pub const MBEDTLS_MD_SHA256: mbedtls_md_type_t = 9;
pub const MBEDTLS_MD_SHA384: mbedtls_md_type_t = 10;
pub const MBEDTLS_MD_SHA512: mbedtls_md_type_t = 11;
pub const MBEDTLS_MD_SHA3_224: mbedtls_md_type_t = 16;
pub const MBEDTLS_MD_SHA3_256: mbedtls_md_type_t = 17;
pub const MBEDTLS_MD_SHA3_384: mbedtls_md_type_t = 18;
pub const MBEDTLS_MD_SHA3_512: mbedtls_md_type_t = 19;
pub type mbedtls_md_type_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_info_t {
    _unused: [u8; 0],
}
pub const MBEDTLS_MD_ENGINE_LEGACY: mbedtls_md_engine_t = 0;
pub const MBEDTLS_MD_ENGINE_PSA: mbedtls_md_engine_t = 1;
pub type mbedtls_md_engine_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_context_t {
    pub private_md_info: *const mbedtls_md_info_t,
    pub private_md_ctx: *mut ::core::ffi::c_void,
    pub private_hmac_ctx: *mut ::core::ffi::c_void,
}
pub type va_list = u32;
pub type __isoc_va_list = u32;
pub type off_t = ::core::ffi::c_longlong;
pub type loff_t = ::core::ffi::c_longlong;
pub type off64_t = off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _G_fpos64_t {
    pub __opaque: [::core::ffi::c_char; 16usize],
    pub __lldata: ::core::ffi::c_longlong,
    pub __align: f64,
}
pub type fpos_t = _G_fpos64_t;
unsafe extern "C" {
    pub static stdin: *mut FILE;
}
unsafe extern "C" {
    pub static stdout: *mut FILE;
}
unsafe extern "C" {
    pub static stderr: *mut FILE;
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_char,
        arg3: size_t,
    ) -> ssize_t,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_char,
        arg3: size_t,
    ) -> ssize_t,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut off_t,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type cookie_close_function_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type mbedtls_mpi_sint = i32;
pub type mbedtls_mpi_uint = u32;
pub type mbedtls_t_udbl = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_mpi {
    pub private_p: *mut mbedtls_mpi_uint,
    pub private_s: ::core::ffi::c_short,
    pub private_n: ::core::ffi::c_ushort,
}
pub const MBEDTLS_MPI_GEN_PRIME_FLAG_DH: mbedtls_mpi_gen_prime_flag_t = 1;
pub const MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR: mbedtls_mpi_gen_prime_flag_t = 2;
pub type mbedtls_mpi_gen_prime_flag_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_rsa_context {
    pub private_ver: ::core::ffi::c_int,
    pub private_len: size_t,
    pub private_N: mbedtls_mpi,
    pub private_E: mbedtls_mpi,
    pub private_D: mbedtls_mpi,
    pub private_P: mbedtls_mpi,
    pub private_Q: mbedtls_mpi,
    pub private_DP: mbedtls_mpi,
    pub private_DQ: mbedtls_mpi,
    pub private_QP: mbedtls_mpi,
    pub private_RN: mbedtls_mpi,
    pub private_RP: mbedtls_mpi,
    pub private_RQ: mbedtls_mpi,
    pub private_Vi: mbedtls_mpi,
    pub private_Vf: mbedtls_mpi,
    pub private_padding: ::core::ffi::c_int,
    pub private_hash_id: ::core::ffi::c_int,
}
pub const MBEDTLS_ECP_DP_NONE: mbedtls_ecp_group_id = 0;
pub const MBEDTLS_ECP_DP_SECP192R1: mbedtls_ecp_group_id = 1;
pub const MBEDTLS_ECP_DP_SECP224R1: mbedtls_ecp_group_id = 2;
pub const MBEDTLS_ECP_DP_SECP256R1: mbedtls_ecp_group_id = 3;
pub const MBEDTLS_ECP_DP_SECP384R1: mbedtls_ecp_group_id = 4;
pub const MBEDTLS_ECP_DP_SECP521R1: mbedtls_ecp_group_id = 5;
pub const MBEDTLS_ECP_DP_BP256R1: mbedtls_ecp_group_id = 6;
pub const MBEDTLS_ECP_DP_BP384R1: mbedtls_ecp_group_id = 7;
pub const MBEDTLS_ECP_DP_BP512R1: mbedtls_ecp_group_id = 8;
pub const MBEDTLS_ECP_DP_CURVE25519: mbedtls_ecp_group_id = 9;
pub const MBEDTLS_ECP_DP_SECP192K1: mbedtls_ecp_group_id = 10;
pub const MBEDTLS_ECP_DP_SECP224K1: mbedtls_ecp_group_id = 11;
pub const MBEDTLS_ECP_DP_SECP256K1: mbedtls_ecp_group_id = 12;
pub const MBEDTLS_ECP_DP_CURVE448: mbedtls_ecp_group_id = 13;
pub type mbedtls_ecp_group_id = ::core::ffi::c_uint;
pub const MBEDTLS_ECP_TYPE_NONE: mbedtls_ecp_curve_type = 0;
pub const MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS: mbedtls_ecp_curve_type = 1;
pub const MBEDTLS_ECP_TYPE_MONTGOMERY: mbedtls_ecp_curve_type = 2;
pub type mbedtls_ecp_curve_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_curve_info {
    pub grp_id: mbedtls_ecp_group_id,
    pub tls_id: u16,
    pub bit_size: u16,
    pub name: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_point {
    pub private_X: mbedtls_mpi,
    pub private_Y: mbedtls_mpi,
    pub private_Z: mbedtls_mpi,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_group {
    pub id: mbedtls_ecp_group_id,
    pub P: mbedtls_mpi,
    pub A: mbedtls_mpi,
    pub B: mbedtls_mpi,
    pub G: mbedtls_ecp_point,
    pub N: mbedtls_mpi,
    pub pbits: size_t,
    pub nbits: size_t,
    pub private_h: ::core::ffi::c_uint,
    pub private_modp:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbedtls_mpi) -> ::core::ffi::c_int>,
    pub private_t_pre: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub private_t_post: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub private_t_data: *mut ::core::ffi::c_void,
    pub private_T: *mut mbedtls_ecp_point,
    pub private_T_size: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_restart_mul {
    _unused: [u8; 0],
}
pub type mbedtls_ecp_restart_mul_ctx = mbedtls_ecp_restart_mul;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_restart_muladd {
    _unused: [u8; 0],
}
pub type mbedtls_ecp_restart_muladd_ctx = mbedtls_ecp_restart_muladd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_restart_ctx {
    pub private_ops_done: ::core::ffi::c_uint,
    pub private_depth: ::core::ffi::c_uint,
    pub private_rsm: *mut mbedtls_ecp_restart_mul_ctx,
    pub private_ma: *mut mbedtls_ecp_restart_muladd_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_keypair {
    pub private_grp: mbedtls_ecp_group,
    pub private_d: mbedtls_mpi,
    pub private_Q: mbedtls_ecp_point,
}
pub type mbedtls_ecdsa_context = mbedtls_ecp_keypair;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecdsa_restart_ver {
    _unused: [u8; 0],
}
pub type mbedtls_ecdsa_restart_ver_ctx = mbedtls_ecdsa_restart_ver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecdsa_restart_sig {
    _unused: [u8; 0],
}
pub type mbedtls_ecdsa_restart_sig_ctx = mbedtls_ecdsa_restart_sig;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecdsa_restart_ctx {
    pub private_ecp: mbedtls_ecp_restart_ctx,
    pub private_ver: *mut mbedtls_ecdsa_restart_ver_ctx,
    pub private_sig: *mut mbedtls_ecdsa_restart_sig_ctx,
}
pub type psa_status_t = i32;
pub type psa_key_type_t = u16;
pub type psa_ecc_family_t = u8;
pub type psa_dh_family_t = u8;
pub type psa_algorithm_t = u32;
pub type psa_key_lifetime_t = u32;
pub type psa_key_persistence_t = u8;
pub type psa_key_location_t = u32;
pub type psa_key_id_t = u32;
pub type mbedtls_svc_key_id_t = psa_key_id_t;
pub type psa_key_usage_t = u32;
pub type psa_key_attributes_t = psa_key_attributes_s;
pub type psa_key_derivation_step_t = u16;
pub type psa_key_production_parameters_t = psa_key_production_parameters_s;
pub type psa_hash_operation_t = psa_hash_operation_s;
pub type psa_mac_operation_t = psa_mac_operation_s;
pub type psa_cipher_operation_t = psa_cipher_operation_s;
pub type psa_aead_operation_t = psa_aead_operation_s;
pub type psa_key_derivation_operation_t = psa_key_derivation_s;
pub type psa_sign_hash_interruptible_operation_t = psa_sign_hash_interruptible_operation_s;
pub type psa_verify_hash_interruptible_operation_t = psa_verify_hash_interruptible_operation_s;
pub const PSA_CRYPTO_DRIVER_DECRYPT: psa_encrypt_or_decrypt_t = 0;
pub const PSA_CRYPTO_DRIVER_ENCRYPT: psa_encrypt_or_decrypt_t = 1;
pub type psa_encrypt_or_decrypt_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md5_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 4usize],
    pub private_buffer: [::core::ffi::c_uchar; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ripemd160_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 5usize],
    pub private_buffer: [::core::ffi::c_uchar; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha1_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 5usize],
    pub private_buffer: [::core::ffi::c_uchar; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha256_context {
    pub private_buffer: [::core::ffi::c_uchar; 64usize],
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 8usize],
    pub private_is224: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha512_context {
    pub private_total: [u64; 2usize],
    pub private_state: [u64; 8usize],
    pub private_buffer: [::core::ffi::c_uchar; 128usize],
    pub private_is384: ::core::ffi::c_int,
}
pub const MBEDTLS_SHA3_NONE: mbedtls_sha3_id = 0;
pub const MBEDTLS_SHA3_224: mbedtls_sha3_id = 1;
pub const MBEDTLS_SHA3_256: mbedtls_sha3_id = 2;
pub const MBEDTLS_SHA3_384: mbedtls_sha3_id = 3;
pub const MBEDTLS_SHA3_512: mbedtls_sha3_id = 4;
pub type mbedtls_sha3_id = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha3_context {
    pub private_state: [u64; 25usize],
    pub private_index: u32,
    pub private_olen: u16,
    pub private_max_block_size: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hash_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_hash_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_hash_operation_t__bindgen_ty_1 {
    pub dummy: ::core::ffi::c_uint,
    pub md5: mbedtls_md5_context,
    pub sha1: mbedtls_sha1_context,
    pub sha256: mbedtls_sha256_context,
    pub sha512: mbedtls_sha512_context,
    pub sha3: mbedtls_sha3_context,
}
pub const MBEDTLS_CIPHER_ID_NONE: mbedtls_cipher_id_t = 0;
pub const MBEDTLS_CIPHER_ID_NULL: mbedtls_cipher_id_t = 1;
pub const MBEDTLS_CIPHER_ID_AES: mbedtls_cipher_id_t = 2;
pub const MBEDTLS_CIPHER_ID_DES: mbedtls_cipher_id_t = 3;
pub const MBEDTLS_CIPHER_ID_3DES: mbedtls_cipher_id_t = 4;
pub const MBEDTLS_CIPHER_ID_CAMELLIA: mbedtls_cipher_id_t = 5;
pub const MBEDTLS_CIPHER_ID_ARIA: mbedtls_cipher_id_t = 6;
pub const MBEDTLS_CIPHER_ID_CHACHA20: mbedtls_cipher_id_t = 7;
pub type mbedtls_cipher_id_t = ::core::ffi::c_uint;
pub const MBEDTLS_CIPHER_NONE: mbedtls_cipher_type_t = 0;
pub const MBEDTLS_CIPHER_NULL: mbedtls_cipher_type_t = 1;
pub const MBEDTLS_CIPHER_AES_128_ECB: mbedtls_cipher_type_t = 2;
pub const MBEDTLS_CIPHER_AES_192_ECB: mbedtls_cipher_type_t = 3;
pub const MBEDTLS_CIPHER_AES_256_ECB: mbedtls_cipher_type_t = 4;
pub const MBEDTLS_CIPHER_AES_128_CBC: mbedtls_cipher_type_t = 5;
pub const MBEDTLS_CIPHER_AES_192_CBC: mbedtls_cipher_type_t = 6;
pub const MBEDTLS_CIPHER_AES_256_CBC: mbedtls_cipher_type_t = 7;
pub const MBEDTLS_CIPHER_AES_128_CFB128: mbedtls_cipher_type_t = 8;
pub const MBEDTLS_CIPHER_AES_192_CFB128: mbedtls_cipher_type_t = 9;
pub const MBEDTLS_CIPHER_AES_256_CFB128: mbedtls_cipher_type_t = 10;
pub const MBEDTLS_CIPHER_AES_128_CTR: mbedtls_cipher_type_t = 11;
pub const MBEDTLS_CIPHER_AES_192_CTR: mbedtls_cipher_type_t = 12;
pub const MBEDTLS_CIPHER_AES_256_CTR: mbedtls_cipher_type_t = 13;
pub const MBEDTLS_CIPHER_AES_128_GCM: mbedtls_cipher_type_t = 14;
pub const MBEDTLS_CIPHER_AES_192_GCM: mbedtls_cipher_type_t = 15;
pub const MBEDTLS_CIPHER_AES_256_GCM: mbedtls_cipher_type_t = 16;
pub const MBEDTLS_CIPHER_CAMELLIA_128_ECB: mbedtls_cipher_type_t = 17;
pub const MBEDTLS_CIPHER_CAMELLIA_192_ECB: mbedtls_cipher_type_t = 18;
pub const MBEDTLS_CIPHER_CAMELLIA_256_ECB: mbedtls_cipher_type_t = 19;
pub const MBEDTLS_CIPHER_CAMELLIA_128_CBC: mbedtls_cipher_type_t = 20;
pub const MBEDTLS_CIPHER_CAMELLIA_192_CBC: mbedtls_cipher_type_t = 21;
pub const MBEDTLS_CIPHER_CAMELLIA_256_CBC: mbedtls_cipher_type_t = 22;
pub const MBEDTLS_CIPHER_CAMELLIA_128_CFB128: mbedtls_cipher_type_t = 23;
pub const MBEDTLS_CIPHER_CAMELLIA_192_CFB128: mbedtls_cipher_type_t = 24;
pub const MBEDTLS_CIPHER_CAMELLIA_256_CFB128: mbedtls_cipher_type_t = 25;
pub const MBEDTLS_CIPHER_CAMELLIA_128_CTR: mbedtls_cipher_type_t = 26;
pub const MBEDTLS_CIPHER_CAMELLIA_192_CTR: mbedtls_cipher_type_t = 27;
pub const MBEDTLS_CIPHER_CAMELLIA_256_CTR: mbedtls_cipher_type_t = 28;
pub const MBEDTLS_CIPHER_CAMELLIA_128_GCM: mbedtls_cipher_type_t = 29;
pub const MBEDTLS_CIPHER_CAMELLIA_192_GCM: mbedtls_cipher_type_t = 30;
pub const MBEDTLS_CIPHER_CAMELLIA_256_GCM: mbedtls_cipher_type_t = 31;
pub const MBEDTLS_CIPHER_DES_ECB: mbedtls_cipher_type_t = 32;
pub const MBEDTLS_CIPHER_DES_CBC: mbedtls_cipher_type_t = 33;
pub const MBEDTLS_CIPHER_DES_EDE_ECB: mbedtls_cipher_type_t = 34;
pub const MBEDTLS_CIPHER_DES_EDE_CBC: mbedtls_cipher_type_t = 35;
pub const MBEDTLS_CIPHER_DES_EDE3_ECB: mbedtls_cipher_type_t = 36;
pub const MBEDTLS_CIPHER_DES_EDE3_CBC: mbedtls_cipher_type_t = 37;
pub const MBEDTLS_CIPHER_AES_128_CCM: mbedtls_cipher_type_t = 38;
pub const MBEDTLS_CIPHER_AES_192_CCM: mbedtls_cipher_type_t = 39;
pub const MBEDTLS_CIPHER_AES_256_CCM: mbedtls_cipher_type_t = 40;
pub const MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 41;
pub const MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 42;
pub const MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 43;
pub const MBEDTLS_CIPHER_CAMELLIA_128_CCM: mbedtls_cipher_type_t = 44;
pub const MBEDTLS_CIPHER_CAMELLIA_192_CCM: mbedtls_cipher_type_t = 45;
pub const MBEDTLS_CIPHER_CAMELLIA_256_CCM: mbedtls_cipher_type_t = 46;
pub const MBEDTLS_CIPHER_CAMELLIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 47;
pub const MBEDTLS_CIPHER_CAMELLIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 48;
pub const MBEDTLS_CIPHER_CAMELLIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 49;
pub const MBEDTLS_CIPHER_ARIA_128_ECB: mbedtls_cipher_type_t = 50;
pub const MBEDTLS_CIPHER_ARIA_192_ECB: mbedtls_cipher_type_t = 51;
pub const MBEDTLS_CIPHER_ARIA_256_ECB: mbedtls_cipher_type_t = 52;
pub const MBEDTLS_CIPHER_ARIA_128_CBC: mbedtls_cipher_type_t = 53;
pub const MBEDTLS_CIPHER_ARIA_192_CBC: mbedtls_cipher_type_t = 54;
pub const MBEDTLS_CIPHER_ARIA_256_CBC: mbedtls_cipher_type_t = 55;
pub const MBEDTLS_CIPHER_ARIA_128_CFB128: mbedtls_cipher_type_t = 56;
pub const MBEDTLS_CIPHER_ARIA_192_CFB128: mbedtls_cipher_type_t = 57;
pub const MBEDTLS_CIPHER_ARIA_256_CFB128: mbedtls_cipher_type_t = 58;
pub const MBEDTLS_CIPHER_ARIA_128_CTR: mbedtls_cipher_type_t = 59;
pub const MBEDTLS_CIPHER_ARIA_192_CTR: mbedtls_cipher_type_t = 60;
pub const MBEDTLS_CIPHER_ARIA_256_CTR: mbedtls_cipher_type_t = 61;
pub const MBEDTLS_CIPHER_ARIA_128_GCM: mbedtls_cipher_type_t = 62;
pub const MBEDTLS_CIPHER_ARIA_192_GCM: mbedtls_cipher_type_t = 63;
pub const MBEDTLS_CIPHER_ARIA_256_GCM: mbedtls_cipher_type_t = 64;
pub const MBEDTLS_CIPHER_ARIA_128_CCM: mbedtls_cipher_type_t = 65;
pub const MBEDTLS_CIPHER_ARIA_192_CCM: mbedtls_cipher_type_t = 66;
pub const MBEDTLS_CIPHER_ARIA_256_CCM: mbedtls_cipher_type_t = 67;
pub const MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 68;
pub const MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 69;
pub const MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 70;
pub const MBEDTLS_CIPHER_AES_128_OFB: mbedtls_cipher_type_t = 71;
pub const MBEDTLS_CIPHER_AES_192_OFB: mbedtls_cipher_type_t = 72;
pub const MBEDTLS_CIPHER_AES_256_OFB: mbedtls_cipher_type_t = 73;
pub const MBEDTLS_CIPHER_AES_128_XTS: mbedtls_cipher_type_t = 74;
pub const MBEDTLS_CIPHER_AES_256_XTS: mbedtls_cipher_type_t = 75;
pub const MBEDTLS_CIPHER_CHACHA20: mbedtls_cipher_type_t = 76;
pub const MBEDTLS_CIPHER_CHACHA20_POLY1305: mbedtls_cipher_type_t = 77;
pub const MBEDTLS_CIPHER_AES_128_KW: mbedtls_cipher_type_t = 78;
pub const MBEDTLS_CIPHER_AES_192_KW: mbedtls_cipher_type_t = 79;
pub const MBEDTLS_CIPHER_AES_256_KW: mbedtls_cipher_type_t = 80;
pub const MBEDTLS_CIPHER_AES_128_KWP: mbedtls_cipher_type_t = 81;
pub const MBEDTLS_CIPHER_AES_192_KWP: mbedtls_cipher_type_t = 82;
pub const MBEDTLS_CIPHER_AES_256_KWP: mbedtls_cipher_type_t = 83;
pub type mbedtls_cipher_type_t = ::core::ffi::c_uint;
pub const MBEDTLS_MODE_NONE: mbedtls_cipher_mode_t = 0;
pub const MBEDTLS_MODE_ECB: mbedtls_cipher_mode_t = 1;
pub const MBEDTLS_MODE_CBC: mbedtls_cipher_mode_t = 2;
pub const MBEDTLS_MODE_CFB: mbedtls_cipher_mode_t = 3;
pub const MBEDTLS_MODE_OFB: mbedtls_cipher_mode_t = 4;
pub const MBEDTLS_MODE_CTR: mbedtls_cipher_mode_t = 5;
pub const MBEDTLS_MODE_GCM: mbedtls_cipher_mode_t = 6;
pub const MBEDTLS_MODE_STREAM: mbedtls_cipher_mode_t = 7;
pub const MBEDTLS_MODE_CCM: mbedtls_cipher_mode_t = 8;
pub const MBEDTLS_MODE_CCM_STAR_NO_TAG: mbedtls_cipher_mode_t = 9;
pub const MBEDTLS_MODE_XTS: mbedtls_cipher_mode_t = 10;
pub const MBEDTLS_MODE_CHACHAPOLY: mbedtls_cipher_mode_t = 11;
pub const MBEDTLS_MODE_KW: mbedtls_cipher_mode_t = 12;
pub const MBEDTLS_MODE_KWP: mbedtls_cipher_mode_t = 13;
pub type mbedtls_cipher_mode_t = ::core::ffi::c_uint;
pub const MBEDTLS_PADDING_PKCS7: mbedtls_cipher_padding_t = 0;
pub const MBEDTLS_PADDING_ONE_AND_ZEROS: mbedtls_cipher_padding_t = 1;
pub const MBEDTLS_PADDING_ZEROS_AND_LEN: mbedtls_cipher_padding_t = 2;
pub const MBEDTLS_PADDING_ZEROS: mbedtls_cipher_padding_t = 3;
pub const MBEDTLS_PADDING_NONE: mbedtls_cipher_padding_t = 4;
pub type mbedtls_cipher_padding_t = ::core::ffi::c_uint;
pub const MBEDTLS_OPERATION_NONE: mbedtls_operation_t = -1;
pub const MBEDTLS_DECRYPT: mbedtls_operation_t = 0;
pub const MBEDTLS_ENCRYPT: mbedtls_operation_t = 1;
pub type mbedtls_operation_t = ::core::ffi::c_int;
pub const MBEDTLS_KEY_LENGTH_NONE: _bindgen_ty_1 = 0;
pub const MBEDTLS_KEY_LENGTH_DES: _bindgen_ty_1 = 64;
pub const MBEDTLS_KEY_LENGTH_DES_EDE: _bindgen_ty_1 = 128;
pub const MBEDTLS_KEY_LENGTH_DES_EDE3: _bindgen_ty_1 = 192;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_base_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_info_t {
    pub private_name: *const ::core::ffi::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl mbedtls_cipher_info_t {
    #[inline]
    pub fn private_block_size(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_private_block_size(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    pub unsafe fn private_block_size_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                5u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_block_size_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_iv_size(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_size(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    pub unsafe fn private_iv_size_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                3u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_iv_size_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_key_bitlen(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_private_key_bitlen(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    pub unsafe fn private_key_bitlen_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_key_bitlen_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_mode(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_private_mode(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    pub unsafe fn private_mode_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_mode_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_type(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_private_type(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    pub unsafe fn private_type_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_type_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_flags(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_private_flags(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    pub unsafe fn private_flags_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                2u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_flags_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_base_idx(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_private_base_idx(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 5u8, val as u64)
        }
    }
    pub unsafe fn private_base_idx_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                5u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_base_idx_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_block_size: ::core::ffi::c_uint,
        private_iv_size: ::core::ffi::c_uint,
        private_key_bitlen: ::core::ffi::c_uint,
        private_mode: ::core::ffi::c_uint,
        private_type: ::core::ffi::c_uint,
        private_flags: ::core::ffi::c_uint,
        private_base_idx: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let private_block_size: u32 = unsafe { ::core::mem::transmute(private_block_size) };
            private_block_size as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let private_iv_size: u32 = unsafe { ::core::mem::transmute(private_iv_size) };
            private_iv_size as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let private_key_bitlen: u32 = unsafe { ::core::mem::transmute(private_key_bitlen) };
            private_key_bitlen as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let private_mode: u32 = unsafe { ::core::mem::transmute(private_mode) };
            private_mode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let private_type: u32 = unsafe { ::core::mem::transmute(private_type) };
            private_type as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let private_flags: u32 = unsafe { ::core::mem::transmute(private_flags) };
            private_flags as u64
        });
        __bindgen_bitfield_unit.set(26usize, 5u8, {
            let private_base_idx: u32 = unsafe { ::core::mem::transmute(private_base_idx) };
            private_base_idx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_context_t {
    pub private_cipher_info: *const mbedtls_cipher_info_t,
    pub private_key_bitlen: ::core::ffi::c_int,
    pub private_operation: mbedtls_operation_t,
    pub private_add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut ::core::ffi::c_uchar, olen: size_t, data_len: size_t),
    >,
    pub private_get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut ::core::ffi::c_uchar,
            ilen: size_t,
            data_len: *mut size_t,
        ) -> ::core::ffi::c_int,
    >,
    pub private_unprocessed_data: [::core::ffi::c_uchar; 16usize],
    pub private_unprocessed_len: size_t,
    pub private_iv: [::core::ffi::c_uchar; 16usize],
    pub private_iv_size: size_t,
    pub private_cipher_ctx: *mut ::core::ffi::c_void,
    pub private_cmac_ctx: *mut mbedtls_cmac_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_cipher_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_iv_length: u8,
    pub private_block_length: u8,
    pub private_ctx: mbedtls_psa_cipher_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_cipher_operation_t__bindgen_ty_1 {
    pub private_dummy: ::core::ffi::c_uint,
    pub private_cipher: mbedtls_cipher_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_hash_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_hash_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_cipher_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_cipher_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hash_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub private_ctx: psa_driver_hash_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_cipher_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_default_iv_length: u8,
    pub private_ctx: psa_driver_cipher_context_t,
}
impl psa_cipher_operation_s {
    #[inline]
    pub fn private_iv_required(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_required(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_iv_required_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_iv_required_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_iv_set(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_set(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_iv_set_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_iv_set_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_iv_required: ::core::ffi::c_uint,
        private_iv_set: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_iv_required: u32 = unsafe { ::core::mem::transmute(private_iv_required) };
            private_iv_required as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_iv_set: u32 = unsafe { ::core::mem::transmute(private_iv_set) };
            private_iv_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cmac_context_t {
    pub private_state: [::core::ffi::c_uchar; 16usize],
    pub private_unprocessed_block: [::core::ffi::c_uchar; 16usize],
    pub private_unprocessed_len: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_gcm_context {
    pub private_cipher_ctx: mbedtls_cipher_context_t,
    pub private_H: [[u64; 2usize]; 16usize],
    pub private_len: u64,
    pub private_add_len: u64,
    pub private_base_ectr: [::core::ffi::c_uchar; 16usize],
    pub private_y: [::core::ffi::c_uchar; 16usize],
    pub private_buf: [::core::ffi::c_uchar; 16usize],
    pub private_mode: ::core::ffi::c_uchar,
    pub private_acceleration: ::core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_poly1305_context {
    pub private_r: [u32; 4usize],
    pub private_s: [u32; 4usize],
    pub private_acc: [u32; 5usize],
    pub private_queue: [u8; 16usize],
    pub private_queue_len: size_t,
}
pub const MBEDTLS_CHACHAPOLY_ENCRYPT: mbedtls_chachapoly_mode_t = 0;
pub const MBEDTLS_CHACHAPOLY_DECRYPT: mbedtls_chachapoly_mode_t = 1;
pub type mbedtls_chachapoly_mode_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_chacha20_context {
    pub private_state: [u32; 16usize],
    pub private_keystream8: [u8; 64usize],
    pub private_keystream_bytes_used: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_chachapoly_context {
    pub private_chacha20_ctx: mbedtls_chacha20_context,
    pub private_poly1305_ctx: mbedtls_poly1305_context,
    pub private_aad_len: u64,
    pub private_ciphertext_len: u64,
    pub private_state: ::core::ffi::c_int,
    pub private_mode: mbedtls_chachapoly_mode_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hmac_operation_t {
    pub private_alg: psa_algorithm_t,
    pub hash_ctx: psa_hash_operation_s,
    pub private_opad: [u8; 144usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_mac_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_mac_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_mac_operation_t__bindgen_ty_1 {
    pub private_dummy: ::core::ffi::c_uint,
    pub private_hmac: mbedtls_psa_hmac_operation_t,
    pub private_cmac: mbedtls_cipher_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_aead_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_tag_length: u8,
    pub ctx: mbedtls_psa_aead_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_aead_operation_t__bindgen_ty_1 {
    pub dummy: ::core::ffi::c_uint,
    pub private_gcm: mbedtls_gcm_context,
    pub private_chachapoly: mbedtls_chachapoly_context,
}
impl mbedtls_psa_aead_operation_t {
    #[inline]
    pub fn private_is_encrypt(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_is_encrypt_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_is_encrypt_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_encrypt: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_psa_sign_hash_interruptible_operation_t {
    pub private_ctx: *mut mbedtls_ecdsa_context,
    pub private_restart_ctx: mbedtls_ecdsa_restart_ctx,
    pub private_num_ops: u32,
    pub private_coordinate_bytes: size_t,
    pub private_alg: psa_algorithm_t,
    pub private_md_alg: mbedtls_md_type_t,
    pub private_hash: [u8; 66usize],
    pub private_hash_length: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_psa_verify_hash_interruptible_operation_t {
    pub private_ctx: *mut mbedtls_ecdsa_context,
    pub private_restart_ctx: mbedtls_ecdsa_restart_ctx,
    pub private_num_ops: u32,
    pub private_hash: [u8; 66usize],
    pub private_hash_length: size_t,
    pub private_r: mbedtls_mpi,
    pub private_s: mbedtls_mpi,
}
pub const MBEDTLS_ECJPAKE_CLIENT: mbedtls_ecjpake_role = 0;
pub const MBEDTLS_ECJPAKE_SERVER: mbedtls_ecjpake_role = 1;
pub const MBEDTLS_ECJPAKE_NONE: mbedtls_ecjpake_role = 2;
pub type mbedtls_ecjpake_role = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecjpake_context {
    pub private_md_type: mbedtls_md_type_t,
    pub private_grp: mbedtls_ecp_group,
    pub private_role: mbedtls_ecjpake_role,
    pub private_point_format: ::core::ffi::c_int,
    pub private_Xm1: mbedtls_ecp_point,
    pub private_Xm2: mbedtls_ecp_point,
    pub private_Xp1: mbedtls_ecp_point,
    pub private_Xp2: mbedtls_ecp_point,
    pub private_Xp: mbedtls_ecp_point,
    pub private_xm1: mbedtls_mpi,
    pub private_xm2: mbedtls_mpi,
    pub private_s: mbedtls_mpi,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_pake_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_password: *mut u8,
    pub private_password_len: size_t,
    pub private_role: mbedtls_ecjpake_role,
    pub private_buffer: [u8; 336usize],
    pub private_buffer_length: size_t,
    pub private_buffer_offset: size_t,
    pub private_ctx: mbedtls_psa_pake_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_pake_operation_t__bindgen_ty_1 {
    pub private_dummy: ::core::ffi::c_uint,
    pub private_jpake: mbedtls_ecjpake_context,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_mac_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_mac_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_aead_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_aead_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_sign_hash_interruptible_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_sign_hash_interruptible_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_verify_hash_interruptible_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_verify_hash_interruptible_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_pake_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub mbedtls_ctx: mbedtls_psa_pake_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_mac_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub private_mac_size: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_mac_context_t,
}
impl psa_mac_operation_s {
    #[inline]
    pub fn private_is_sign(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_sign(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_is_sign_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_is_sign_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_sign: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_sign: u32 = unsafe { ::core::mem::transmute(private_is_sign) };
            private_is_sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_aead_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub private_ad_remaining: size_t,
    pub private_body_remaining: size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_aead_context_t,
}
impl psa_aead_operation_s {
    #[inline]
    pub fn private_nonce_set(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_nonce_set(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_nonce_set_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_nonce_set_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_lengths_set(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_lengths_set(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_lengths_set_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_lengths_set_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_ad_started(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_ad_started(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_ad_started_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_ad_started_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_body_started(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_body_started(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_body_started_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_body_started_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_is_encrypt(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_is_encrypt_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_is_encrypt_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_nonce_set: ::core::ffi::c_uint,
        private_lengths_set: ::core::ffi::c_uint,
        private_ad_started: ::core::ffi::c_uint,
        private_body_started: ::core::ffi::c_uint,
        private_is_encrypt: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_nonce_set: u32 = unsafe { ::core::mem::transmute(private_nonce_set) };
            private_nonce_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_lengths_set: u32 = unsafe { ::core::mem::transmute(private_lengths_set) };
            private_lengths_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let private_ad_started: u32 = unsafe { ::core::mem::transmute(private_ad_started) };
            private_ad_started as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let private_body_started: u32 = unsafe { ::core::mem::transmute(private_body_started) };
            private_body_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hkdf_key_derivation_t {
    pub private_info: *mut u8,
    pub private_info_length: size_t,
    pub private_offset_in_block: u8,
    pub private_block_number: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_output_block: [u8; 64usize],
    pub private_prk: [u8; 64usize],
    pub private_hmac: psa_mac_operation_s,
}
impl psa_hkdf_key_derivation_t {
    #[inline]
    pub fn private_state(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_private_state(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    pub unsafe fn private_state_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_state_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn private_info_set(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_info_set(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_info_set_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_info_set_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_state: ::core::ffi::c_uint,
        private_info_set: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let private_state: u32 = unsafe { ::core::mem::transmute(private_state) };
            private_state as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let private_info_set: u32 = unsafe { ::core::mem::transmute(private_info_set) };
            private_info_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_tls12_ecjpake_to_pms_t {
    pub private_data: [u8; 32usize],
}
pub const PSA_TLS12_PRF_STATE_INIT: psa_tls12_prf_key_derivation_state_t = 0;
pub const PSA_TLS12_PRF_STATE_SEED_SET: psa_tls12_prf_key_derivation_state_t = 1;
pub const PSA_TLS12_PRF_STATE_OTHER_KEY_SET: psa_tls12_prf_key_derivation_state_t = 2;
pub const PSA_TLS12_PRF_STATE_KEY_SET: psa_tls12_prf_key_derivation_state_t = 3;
pub const PSA_TLS12_PRF_STATE_LABEL_SET: psa_tls12_prf_key_derivation_state_t = 4;
pub const PSA_TLS12_PRF_STATE_OUTPUT: psa_tls12_prf_key_derivation_state_t = 5;
pub type psa_tls12_prf_key_derivation_state_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_tls12_prf_key_derivation_s {
    pub private_left_in_block: u8,
    pub private_block_number: u8,
    pub private_state: psa_tls12_prf_key_derivation_state_t,
    pub private_secret: *mut u8,
    pub private_secret_length: size_t,
    pub private_seed: *mut u8,
    pub private_seed_length: size_t,
    pub private_label: *mut u8,
    pub private_label_length: size_t,
    pub private_other_secret: *mut u8,
    pub private_other_secret_length: size_t,
    pub private_Ai: [u8; 64usize],
    pub private_output_block: [u8; 64usize],
}
pub type psa_tls12_prf_key_derivation_t = psa_tls12_prf_key_derivation_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_key_derivation_context_t {
    pub dummy: ::core::ffi::c_uint,
    pub private_hkdf: psa_hkdf_key_derivation_t,
    pub private_tls12_prf: psa_tls12_prf_key_derivation_t,
    pub private_tls12_ecjpake_to_pms: psa_tls12_ecjpake_to_pms_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_derivation_s {
    pub private_alg: psa_algorithm_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_capacity: size_t,
    pub private_ctx: psa_driver_key_derivation_context_t,
}
impl psa_key_derivation_s {
    #[inline]
    pub fn private_can_output_key(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_can_output_key(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_can_output_key_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_can_output_key_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_can_output_key: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_can_output_key: u32 =
                unsafe { ::core::mem::transmute(private_can_output_key) };
            private_can_output_key as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct psa_key_production_parameters_s {
    pub flags: u32,
    pub data: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_key_policy_s {
    pub private_usage: psa_key_usage_t,
    pub private_alg: psa_algorithm_t,
    pub private_alg2: psa_algorithm_t,
}
pub type psa_key_policy_t = psa_key_policy_s;
pub type psa_key_bits_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_key_attributes_s {
    pub private_type: psa_key_type_t,
    pub private_bits: psa_key_bits_t,
    pub private_lifetime: psa_key_lifetime_t,
    pub private_policy: psa_key_policy_t,
    pub private_id: mbedtls_svc_key_id_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_sign_hash_interruptible_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub private_ctx: psa_driver_sign_hash_interruptible_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_num_ops: u32,
}
impl psa_sign_hash_interruptible_operation_s {
    #[inline]
    pub fn private_error_occurred(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_error_occurred(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_error_occurred_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_error_occurred_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_error_occurred: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_error_occurred: u32 =
                unsafe { ::core::mem::transmute(private_error_occurred) };
            private_error_occurred as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_verify_hash_interruptible_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub private_ctx: psa_driver_verify_hash_interruptible_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_num_ops: u32,
}
impl psa_verify_hash_interruptible_operation_s {
    #[inline]
    pub fn private_error_occurred(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_error_occurred(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    pub unsafe fn private_error_occurred_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    pub unsafe fn set_private_error_occurred_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_error_occurred: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_error_occurred: u32 =
                unsafe { ::core::mem::transmute(private_error_occurred) };
            private_error_occurred as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type psa_key_handle_t = mbedtls_svc_key_id_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_psa_stats_s {
    pub private_volatile_slots: size_t,
    pub private_persistent_slots: size_t,
    pub private_external_slots: size_t,
    pub private_half_filled_slots: size_t,
    pub private_cache_slots: size_t,
    pub private_empty_slots: size_t,
    pub private_locked_slots: size_t,
    pub private_max_open_internal_key_id: psa_key_id_t,
    pub private_max_open_external_key_id: psa_key_id_t,
}
pub type mbedtls_psa_stats_t = mbedtls_psa_stats_s;
pub type psa_drv_slot_number_t = u64;
pub type psa_pake_role_t = u8;
pub type psa_pake_step_t = u8;
pub type psa_pake_primitive_type_t = u8;
pub type psa_pake_family_t = u8;
pub type psa_pake_primitive_t = u32;
pub type psa_pake_cipher_suite_t = psa_pake_cipher_suite_s;
pub type psa_pake_operation_t = psa_pake_operation_s;
pub type psa_crypto_driver_pake_inputs_t = psa_crypto_driver_pake_inputs_s;
pub type psa_jpake_computation_stage_t = psa_jpake_computation_stage_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_pake_cipher_suite_s {
    pub algorithm: psa_algorithm_t,
    pub type_: psa_pake_primitive_type_t,
    pub family: psa_pake_family_t,
    pub bits: u16,
    pub hash: psa_algorithm_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_crypto_driver_pake_inputs_s {
    pub private_password: *mut u8,
    pub private_password_len: size_t,
    pub private_user: *mut u8,
    pub private_user_len: size_t,
    pub private_peer: *mut u8,
    pub private_peer_len: size_t,
    pub private_attributes: psa_key_attributes_t,
    pub private_cipher_suite: psa_pake_cipher_suite_t,
}
pub const PSA_JPAKE_STEP_INVALID: psa_crypto_driver_pake_step = 0;
pub const PSA_JPAKE_X1_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 1;
pub const PSA_JPAKE_X1_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 2;
pub const PSA_JPAKE_X1_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 3;
pub const PSA_JPAKE_X2_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 4;
pub const PSA_JPAKE_X2_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 5;
pub const PSA_JPAKE_X2_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 6;
pub const PSA_JPAKE_X2S_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 7;
pub const PSA_JPAKE_X2S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 8;
pub const PSA_JPAKE_X2S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 9;
pub const PSA_JPAKE_X4S_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 10;
pub const PSA_JPAKE_X4S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 11;
pub const PSA_JPAKE_X4S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 12;
pub type psa_crypto_driver_pake_step = ::core::ffi::c_uint;
pub use self::psa_crypto_driver_pake_step as psa_crypto_driver_pake_step_t;
pub const PSA_JPAKE_FIRST: psa_jpake_round = 0;
pub const PSA_JPAKE_SECOND: psa_jpake_round = 1;
pub const PSA_JPAKE_FINISHED: psa_jpake_round = 2;
pub type psa_jpake_round = ::core::ffi::c_uint;
pub use self::psa_jpake_round as psa_jpake_round_t;
pub const PSA_JPAKE_INPUT: psa_jpake_io_mode = 0;
pub const PSA_JPAKE_OUTPUT: psa_jpake_io_mode = 1;
pub type psa_jpake_io_mode = ::core::ffi::c_uint;
pub use self::psa_jpake_io_mode as psa_jpake_io_mode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_jpake_computation_stage_s {
    pub private_round: psa_jpake_round_t,
    pub private_io_mode: psa_jpake_io_mode_t,
    pub private_inputs: u8,
    pub private_outputs: u8,
    pub private_step: psa_pake_step_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_pake_operation_s {
    pub private_id: ::core::ffi::c_uint,
    pub private_alg: psa_algorithm_t,
    pub private_primitive: psa_pake_primitive_t,
    pub private_stage: u8,
    pub private_computation_stage: psa_pake_operation_s__bindgen_ty_1,
    pub private_data: psa_pake_operation_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_1 {
    pub private_dummy: u8,
    pub private_jpake: psa_jpake_computation_stage_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_2 {
    pub private_ctx: psa_driver_pake_context_t,
    pub private_inputs: psa_crypto_driver_pake_inputs_t,
}
pub const MBEDTLS_PK_NONE: mbedtls_pk_type_t = 0;
pub const MBEDTLS_PK_RSA: mbedtls_pk_type_t = 1;
pub const MBEDTLS_PK_ECKEY: mbedtls_pk_type_t = 2;
pub const MBEDTLS_PK_ECKEY_DH: mbedtls_pk_type_t = 3;
pub const MBEDTLS_PK_ECDSA: mbedtls_pk_type_t = 4;
pub const MBEDTLS_PK_RSA_ALT: mbedtls_pk_type_t = 5;
pub const MBEDTLS_PK_RSASSA_PSS: mbedtls_pk_type_t = 6;
pub const MBEDTLS_PK_OPAQUE: mbedtls_pk_type_t = 7;
pub type mbedtls_pk_type_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_rsassa_pss_options {
    pub mgf1_hash_id: mbedtls_md_type_t,
    pub expected_salt_len: ::core::ffi::c_int,
}
pub const MBEDTLS_PK_DEBUG_NONE: mbedtls_pk_debug_type = 0;
pub const MBEDTLS_PK_DEBUG_MPI: mbedtls_pk_debug_type = 1;
pub const MBEDTLS_PK_DEBUG_ECP: mbedtls_pk_debug_type = 2;
pub const MBEDTLS_PK_DEBUG_PSA_EC: mbedtls_pk_debug_type = 3;
pub type mbedtls_pk_debug_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_debug_item {
    pub private_type: mbedtls_pk_debug_type,
    pub private_name: *const ::core::ffi::c_char,
    pub private_value: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_info_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_context {
    pub private_pk_info: *const mbedtls_pk_info_t,
    pub private_pk_ctx: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_restart_ctx {
    pub private_pk_info: *const mbedtls_pk_info_t,
    pub private_rs_ctx: *mut ::core::ffi::c_void,
}
pub type mbedtls_pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        olen: *mut size_t,
        input: *const ::core::ffi::c_uchar,
        output: *mut ::core::ffi::c_uchar,
        output_max_len: size_t,
    ) -> ::core::ffi::c_int,
>;
pub type mbedtls_pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_uchar,
                arg3: size_t,
            ) -> ::core::ffi::c_int,
        >,
        p_rng: *mut ::core::ffi::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: ::core::ffi::c_uint,
        hash: *const ::core::ffi::c_uchar,
        sig: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
pub type mbedtls_pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void) -> size_t>;
pub const V_OK: AppVErrCode = 0;
pub const V_ERR_GET_CERT_INFO: AppVErrCode = 4009754626;
pub const V_ERR_UNTRUSTED_CERT: AppVErrCode = 4009754627;
pub const V_ERR_INTEGRITY: AppVErrCode = 4009754628;
pub const V_ERR_GET_SIGNHEAD: AppVErrCode = 4009754629;
pub const V_ERR_GET_SIGN_BLOCK: AppVErrCode = 4009754630;
pub const V_ERR_GET_HASH_DIFF: AppVErrCode = 4009754631;
pub const V_ERR_INVALID_CONTENT_TAG: AppVErrCode = 4009754632;
pub const V_ERR_INVALID_HASH_ALG: AppVErrCode = 4009754633;
pub const V_ERR_GET_ROOT_HASH: AppVErrCode = 4009754634;
pub const V_ERR_CALC_BLOCK_HASH: AppVErrCode = 4009754636;
pub const V_ERR_PARSE_PKC7_DATA: AppVErrCode = 4009754637;
pub const V_ERR_VERIFY_CERT_CHAIN: AppVErrCode = 4009754638;
pub const V_ERR_VERIFY_SIGNATURE: AppVErrCode = 4009754639;
pub const V_ERR_GET_CERT_TYPE: AppVErrCode = 4009754640;
pub const V_ERR_GET_PROFILE_DATA: AppVErrCode = 4009754641;
pub const V_ERR_GET_PARSE_PROFILE: AppVErrCode = 4009754642;
pub const V_ERR_PROF_CONTENT_INVALID: AppVErrCode = 4009754643;
pub const V_ERR_VERFIY_PROF_CERT: AppVErrCode = 4009754644;
pub const V_ERR_GET_CERT_PK: AppVErrCode = 4009754645;
pub const V_ERR_GET_APPID: AppVErrCode = 4009754646;
pub const V_ERR_INVALID_DISP_TYPE: AppVErrCode = 4009754647;
pub const V_ERR_INVALID_APP_BUNDLE: AppVErrCode = 4009754648;
pub const V_ERR_INVALID_DATE: AppVErrCode = 4009754649;
pub const V_ERR_INVALID_DEVID: AppVErrCode = 4009754650;
pub const V_ERR_FILE_OPEN: AppVErrCode = 4009754651;
pub const V_ERR_FILE_STAT: AppVErrCode = 4009754652;
pub const V_ERR_FILE_LENGTH: AppVErrCode = 4009754653;
pub const V_ERR_MEMSET: AppVErrCode = 4009754654;
pub const V_ERR_MEMCPY: AppVErrCode = 4009754655;
pub const V_ERR_MALLOC: AppVErrCode = 4009754656;
pub const V_ERR: AppVErrCode = 4294967295;
pub type AppVErrCode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProfValidity {
    pub notBefore: i32,
    pub notAfter: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProfBundleInfo {
    pub developerId: *mut ::core::ffi::c_char,
    pub devCert: *mut ::core::ffi::c_uchar,
    pub releaseCert: *mut ::core::ffi::c_uchar,
    pub bundleName: *mut ::core::ffi::c_char,
    pub appFeature: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProfPermission {
    pub restricNum: i32,
    pub restricPermission: *mut *mut ::core::ffi::c_char,
    pub permissionNum: i32,
    pub permission: *mut *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProfDebugInfo {
    pub devIdType: *mut ::core::ffi::c_char,
    pub devidNum: i32,
    pub deviceId: *mut *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProfileProf {
    pub versionCode: i32,
    pub versionName: *mut ::core::ffi::c_char,
    pub uuid: *mut ::core::ffi::c_char,
    pub type_: *mut ::core::ffi::c_char,
    pub appDistType: *mut ::core::ffi::c_char,
    pub validity: ProfValidity,
    pub bundleInfo: ProfBundleInfo,
    pub permission: ProfPermission,
    pub debugInfo: ProfDebugInfo,
    pub issuer: *mut ::core::ffi::c_char,
    pub appid: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppSignPk {
    pub pk: *mut ::core::ffi::c_char,
    pub len: i32,
}
pub type GetSignPk =
    ::core::option::Option<unsafe extern "C" fn(verifyRst: *mut VfyRst, pk: *mut AppSignPk) -> i32>;
pub type FreeSignPK = ::core::option::Option<unsafe extern "C" fn(pk: *mut AppSignPk)>;
pub type MessageFunc = ::core::option::Option<
    unsafe extern "C" fn(
        operationResult: ::core::ffi::c_uchar,
        bundleName: *const ::core::ffi::c_char,
        errCode: ::core::ffi::c_uchar,
    ) -> i32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VfyRst {
    pub profile: ProfileProf,
}
pub type VerifyResult = VfyRst;
pub const DEST_BUFFER_IS_NULL: ReadFileErrorCode = -1;
pub const FILE_IS_CLOSE: ReadFileErrorCode = -2;
pub const MMAP_COPY_FAILED: ReadFileErrorCode = -3;
pub const READ_OFFSET_OUT_OF_RANGE: ReadFileErrorCode = -4;
pub const MMAP_FAILED: ReadFileErrorCode = -5;
pub const MMAP_PARAM_INVALID: ReadFileErrorCode = -6;
pub type ReadFileErrorCode = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MmapInfo {
    pub mmapPosition: i32,
    pub readMoreLen: i32,
    pub mmapSize: i32,
    pub mapAddr: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileRead {
    pub fp: i32,
    pub offset: i32,
    pub len: i32,
}
pub type GetDeviceUdid =
    ::core::option::Option<unsafe extern "C" fn(udid: *mut ::core::ffi::c_uchar, size: i32) -> i32>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProductDiff {
    pub devUdidFunc: GetDeviceUdid,
}
pub const HILOG_MODULE_HIVIEW: HiLogModuleType = 0;
pub const HILOG_MODULE_SAMGR: HiLogModuleType = 1;
pub const HILOG_MODULE_UPDATE: HiLogModuleType = 2;
pub const HILOG_MODULE_ACE: HiLogModuleType = 3;
pub const HILOG_MODULE_APP: HiLogModuleType = 4;
pub const HILOG_MODULE_MAX: HiLogModuleType = 5;
pub type HiLogModuleType = ::core::ffi::c_uint;
pub const LOG_TYPE_MIN: LogType = 0;
pub const LOG_INIT: LogType = 1;
pub const LOG_CORE: LogType = 3;
pub const LOG_TYPE_MAX: LogType = 4;
pub type LogType = ::core::ffi::c_uint;
pub const LOG_DEBUG: LogLevel = 3;
pub const LOG_INFO: LogLevel = 4;
pub const LOG_WARN: LogLevel = 5;
pub const LOG_ERROR: LogLevel = 6;
pub const LOG_FATAL: LogLevel = 7;
pub type LogLevel = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct HiLogEntry {
    pub len: ::core::ffi::c_uint,
    pub hdrSize: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sec: ::core::ffi::c_uint,
    pub nsec: ::core::ffi::c_uint,
    pub reserved: ::core::ffi::c_uint,
    pub msg: __IncompleteArrayField<::core::ffi::c_char>,
}
impl HiLogEntry {
    #[inline]
    pub fn pid(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_pid(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    pub unsafe fn pid_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    pub unsafe fn set_pid_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn taskId(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_taskId(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    pub unsafe fn taskId_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    pub unsafe fn set_taskId_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pid: ::core::ffi::c_uint,
        taskId: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let pid: u32 = unsafe { ::core::mem::transmute(pid) };
            pid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let taskId: u32 = unsafe { ::core::mem::transmute(taskId) };
            taskId as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HapBuf {
    pub buffer: *mut ::core::ffi::c_void,
    pub len: i32,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HwSignHead {
    pub blockNum: u32,
    pub size: ::core::ffi::c_ulonglong,
    pub magicLow: ::core::ffi::c_ulonglong,
    pub magicHigh: ::core::ffi::c_ulonglong,
    pub version: u32,
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct MinEocd {
    pub magic: i32,
    pub diskNum: ::core::ffi::c_short,
    pub startNum: ::core::ffi::c_short,
    pub coreDirNumOnDisk: ::core::ffi::c_short,
    pub coreDirNum: ::core::ffi::c_short,
    pub coreDirSize: i32,
    pub coreDirOffset: i32,
    pub commentLen: ::core::ffi::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HapEocd {
    pub eocdHead: MinEocd,
    pub comment: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignatureInfo {
    pub signHead: *mut HwSignHead,
    pub fullSignBlockOffset: i32,
    pub hapCoreDirOffset: i32,
    pub hapEocdOffset: i32,
    pub hapEocdSize: i32,
    pub fileSize: i32,
    pub version: i32,
    pub certType: i32,
}
pub const SIGNATURE_BLOCK_TYPE: BockType = 536870912;
pub const KEY_ROTATION_BLOCK_TYPE: BockType = 536870913;
pub const PROFILE_BLOCK_WITHSIGN_TYPE: BockType = 536870914;
pub const PROPERTY_BLOCK_TYPE: BockType = 536870915;
pub type BockType = ::core::ffi::c_uint;
pub const DEFAULT_TAG: SignBlockTag = 0;
pub const HASH_TAG: SignBlockTag = 1;
pub const HASH_ROOT_1M_TAG: SignBlockTag = 128;
pub const HASH_ROOT_512K_TAG: SignBlockTag = 129;
pub const HASH_ROOT_256K_TAG: SignBlockTag = 130;
pub const HASH_ROOT_128K_TAG: SignBlockTag = 131;
pub const HASH_ROOT_64K_TAG: SignBlockTag = 132;
pub const HASH_ROOT_32K_TAG: SignBlockTag = 133;
pub const HASH_ROOT_16K_TAG: SignBlockTag = 134;
pub const HASH_ROOT_8K_TAG: SignBlockTag = 135;
pub const HASH_ROOT_4K_TAG: SignBlockTag = 136;
pub type SignBlockTag = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockHead {
    pub type_: u32,
    pub length: u32,
    pub offset: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ContentInfo {
    pub version: i32,
    pub blockNum: i32,
    pub size: i32,
    pub algId: i32,
    pub length: i32,
    pub hash: [::core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TrustAppCert {
    pub maxCertPath: i32,
    pub name: *mut ::core::ffi::c_char,
    pub appSignCert: *mut ::core::ffi::c_char,
    pub profileSignCert: *mut ::core::ffi::c_char,
    pub profileDebugSignCert: *mut ::core::ffi::c_char,
    pub issueCA: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CertInfo {
    pub issuerLen: i32,
    pub issuer: *mut ::core::ffi::c_char,
    pub subjectLen: i32,
    pub subject: *mut ::core::ffi::c_char,
    pub pkType: mbedtls_pk_type_t,
    pub pkLen: i32,
    pub pkBuf: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_buf {
    pub tag: ::core::ffi::c_int,
    pub len: size_t,
    pub p: *mut ::core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_bitstring {
    pub len: size_t,
    pub unused_bits: ::core::ffi::c_uchar,
    pub p: *mut ::core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_sequence {
    pub buf: mbedtls_asn1_buf,
    pub next: *mut mbedtls_asn1_sequence,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_named_data {
    pub oid: mbedtls_asn1_buf,
    pub val: mbedtls_asn1_buf,
    pub next: *mut mbedtls_asn1_named_data,
    pub private_next_merged: ::core::ffi::c_uchar,
}
pub type mbedtls_x509_buf = mbedtls_asn1_buf;
pub type mbedtls_x509_bitstring = mbedtls_asn1_bitstring;
pub type mbedtls_x509_name = mbedtls_asn1_named_data;
pub type mbedtls_x509_sequence = mbedtls_asn1_sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_authority {
    pub keyIdentifier: mbedtls_x509_buf,
    pub authorityCertIssuer: mbedtls_x509_sequence,
    pub authorityCertSerialNumber: mbedtls_x509_buf,
    pub raw: mbedtls_x509_buf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_time {
    pub year: ::core::ffi::c_int,
    pub mon: ::core::ffi::c_int,
    pub day: ::core::ffi::c_int,
    pub hour: ::core::ffi::c_int,
    pub min: ::core::ffi::c_int,
    pub sec: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_san_other_name {
    pub type_id: mbedtls_x509_buf,
    pub value: mbedtls_x509_san_other_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_san_other_name__bindgen_ty_1 {
    pub hardware_module_name: mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    pub oid: mbedtls_x509_buf,
    pub val: mbedtls_x509_buf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_subject_alternative_name {
    pub type_: ::core::ffi::c_int,
    pub san: mbedtls_x509_subject_alternative_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_subject_alternative_name__bindgen_ty_1 {
    pub other_name: mbedtls_x509_san_other_name,
    pub directory_name: mbedtls_x509_name,
    pub unstructured_name: mbedtls_x509_buf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_san_list {
    pub node: mbedtls_x509_subject_alternative_name,
    pub next: *mut mbedtls_x509_san_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crl_entry {
    pub raw: mbedtls_x509_buf,
    pub serial: mbedtls_x509_buf,
    pub revocation_date: mbedtls_x509_time,
    pub entry_ext: mbedtls_x509_buf,
    pub next: *mut mbedtls_x509_crl_entry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crl {
    pub raw: mbedtls_x509_buf,
    pub tbs: mbedtls_x509_buf,
    pub version: ::core::ffi::c_int,
    pub sig_oid: mbedtls_x509_buf,
    pub issuer_raw: mbedtls_x509_buf,
    pub issuer: mbedtls_x509_name,
    pub this_update: mbedtls_x509_time,
    pub next_update: mbedtls_x509_time,
    pub entry: mbedtls_x509_crl_entry,
    pub crl_ext: mbedtls_x509_buf,
    pub private_sig_oid2: mbedtls_x509_buf,
    pub private_sig: mbedtls_x509_buf,
    pub private_sig_md: mbedtls_md_type_t,
    pub private_sig_pk: mbedtls_pk_type_t,
    pub private_sig_opts: *mut ::core::ffi::c_void,
    pub next: *mut mbedtls_x509_crl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt {
    pub private_own_buffer: ::core::ffi::c_int,
    pub raw: mbedtls_x509_buf,
    pub tbs: mbedtls_x509_buf,
    pub version: ::core::ffi::c_int,
    pub serial: mbedtls_x509_buf,
    pub sig_oid: mbedtls_x509_buf,
    pub issuer_raw: mbedtls_x509_buf,
    pub subject_raw: mbedtls_x509_buf,
    pub issuer: mbedtls_x509_name,
    pub subject: mbedtls_x509_name,
    pub valid_from: mbedtls_x509_time,
    pub valid_to: mbedtls_x509_time,
    pub pk_raw: mbedtls_x509_buf,
    pub pk: mbedtls_pk_context,
    pub issuer_id: mbedtls_x509_buf,
    pub subject_id: mbedtls_x509_buf,
    pub v3_ext: mbedtls_x509_buf,
    pub subject_alt_names: mbedtls_x509_sequence,
    pub subject_key_id: mbedtls_x509_buf,
    pub authority_key_id: mbedtls_x509_authority,
    pub certificate_policies: mbedtls_x509_sequence,
    pub private_ext_types: ::core::ffi::c_int,
    pub private_ca_istrue: ::core::ffi::c_int,
    pub private_max_pathlen: ::core::ffi::c_int,
    pub private_key_usage: ::core::ffi::c_uint,
    pub ext_key_usage: mbedtls_x509_sequence,
    pub private_ns_cert_type: ::core::ffi::c_uchar,
    pub private_sig: mbedtls_x509_buf,
    pub private_sig_md: mbedtls_md_type_t,
    pub private_sig_pk: mbedtls_pk_type_t,
    pub private_sig_opts: *mut ::core::ffi::c_void,
    pub next: *mut mbedtls_x509_crt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt_profile {
    pub allowed_mds: u32,
    pub allowed_pks: u32,
    pub allowed_curves: u32,
    pub rsa_min_bitlen: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509write_cert {
    pub private_version: ::core::ffi::c_int,
    pub private_serial: [::core::ffi::c_uchar; 20usize],
    pub private_serial_len: size_t,
    pub private_subject_key: *mut mbedtls_pk_context,
    pub private_issuer_key: *mut mbedtls_pk_context,
    pub private_subject: *mut mbedtls_asn1_named_data,
    pub private_issuer: *mut mbedtls_asn1_named_data,
    pub private_md_alg: mbedtls_md_type_t,
    pub private_not_before: [::core::ffi::c_char; 16usize],
    pub private_not_after: [::core::ffi::c_char; 16usize],
    pub private_extensions: *mut mbedtls_asn1_named_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain_item {
    pub private_crt: *mut mbedtls_x509_crt,
    pub private_flags: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain {
    pub private_items: [mbedtls_x509_crt_verify_chain_item; 10usize],
    pub private_len: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt_restart_ctx {
    pub private_pk: mbedtls_pk_restart_ctx,
    pub private_parent: *mut mbedtls_x509_crt,
    pub private_fallback_parent: *mut mbedtls_x509_crt,
    pub private_fallback_signature_is_good: ::core::ffi::c_int,
    pub private_parent_is_trusted: ::core::ffi::c_int,
    pub private_in_progress: mbedtls_x509_crt_restart_ctx__bindgen_ty_1,
    pub private_self_cnt: ::core::ffi::c_int,
    pub private_ver_chain: mbedtls_x509_crt_verify_chain,
}
pub const x509_crt_rs_none: mbedtls_x509_crt_restart_ctx__bindgen_ty_1 = 0;
pub const x509_crt_rs_find_parent: mbedtls_x509_crt_restart_ctx__bindgen_ty_1 = 1;
pub type mbedtls_x509_crt_restart_ctx__bindgen_ty_1 = ::core::ffi::c_uint;
unsafe extern "C" {
    pub static mbedtls_x509_crt_profile_default: mbedtls_x509_crt_profile;
}
unsafe extern "C" {
    pub static mbedtls_x509_crt_profile_next: mbedtls_x509_crt_profile;
}
unsafe extern "C" {
    pub static mbedtls_x509_crt_profile_suiteb: mbedtls_x509_crt_profile;
}
unsafe extern "C" {
    pub static mbedtls_x509_crt_profile_none: mbedtls_x509_crt_profile;
}
pub type mbedtls_x509_crt_ext_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut ::core::ffi::c_void,
        crt: *const mbedtls_x509_crt,
        oid: *const mbedtls_x509_buf,
        critical: ::core::ffi::c_int,
        p: *const ::core::ffi::c_uchar,
        end: *const ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
pub type mbedtls_x509_crt_ca_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut ::core::ffi::c_void,
        child: *const mbedtls_x509_crt,
        candidate_cas: *mut *mut mbedtls_x509_crt,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pem_context {
    pub private_buf: *mut ::core::ffi::c_uchar,
    pub private_buflen: size_t,
    pub private_info: *mut ::core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_oid_descriptor_t {
    pub private_asn1: *const ::core::ffi::c_char,
    pub private_asn1_len: size_t,
    pub private_name: *const ::core::ffi::c_char,
    pub private_description: *const ::core::ffi::c_char,
}
pub const PKCS7_SUCC: PKCS7_RetCode = 0;
pub const PKCS7_PARSING_ERROR: PKCS7_RetCode = 1;
pub const PKCS7_INVALID_PARAM: PKCS7_RetCode = 2;
pub const PKCS7_INVALID_VALUE: PKCS7_RetCode = 3;
pub const PKCS7_INVALID_CONTENT_TYPE_OR_NO_CONTENT: PKCS7_RetCode = 4;
pub const PKCS7_CERTIFICATE_NOT_FOUND: PKCS7_RetCode = 5;
pub const PKCS7_INVALID_VERSION: PKCS7_RetCode = 6;
pub const PKCS7_INVALID_DIGEST_ALG: PKCS7_RetCode = 7;
pub const PKCS7_INVALID_SIGNING_ALG: PKCS7_RetCode = 8;
pub const PKCS7_MEMORY_EXHAUST: PKCS7_RetCode = 9;
pub const PKCS7_ROOT_CA_NOT_VALID: PKCS7_RetCode = 10;
pub const PKCS7_BUILD_CERT_PATH_FAIL: PKCS7_RetCode = 11;
pub const PKCS7_HAS_NO_AUTH_ATTR_IN_SIGNER: PKCS7_RetCode = 12;
pub const PKCS7_HAS_NO_SIGNER_INFO: PKCS7_RetCode = 13;
pub const PKCS7_HAS_NO_SIGNER_CRT: PKCS7_RetCode = 14;
pub const PKCS7_IS_REVOKED: PKCS7_RetCode = 15;
pub const PKCS7_VERIFY_FAIL: PKCS7_RetCode = 16;
pub type PKCS7_RetCode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignerResovledInfo {
    pub issuer: [::core::ffi::c_char; 512usize],
    pub subject: [::core::ffi::c_char; 512usize],
    pub depth: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignersResovedInfo {
    pub signers: *mut SignerResovledInfo,
    pub nrOfSigners: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignerCertPath {
    pub depth: i32,
    pub crt: *mut mbedtls_x509_crt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSignerInfo {
    pub version: i32,
    pub serial: mbedtls_x509_buf,
    pub issuer: mbedtls_x509_name,
    pub rootCert: *mut mbedtls_x509_crt,
    pub issuerRaw: mbedtls_x509_buf,
    pub digestAlgId: mbedtls_x509_buf,
    pub authAttr: mbedtls_x509_buf,
    pub authAttrRaw: mbedtls_x509_buf,
    pub digestEncAlgId: mbedtls_x509_buf,
    pub signature: mbedtls_x509_buf,
    pub unAuthAttr: mbedtls_x509_buf,
    pub certPath: SignerCertPath,
    pub next: *mut tagSignerInfo,
}
pub type SignerInfo = tagSignerInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagContent {
    pub oid: mbedtls_asn1_buf,
    pub data: mbedtls_asn1_buf,
}
pub type Content = tagContent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDigestAlgId {
    pub algBuf: mbedtls_asn1_buf,
    pub next: *mut tagDigestAlgId,
}
pub type DigestAlgId = tagDigestAlgId;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignedData {
    pub version: i32,
    pub digestAlgIds: DigestAlgId,
    pub content: Content,
    pub certs: *mut mbedtls_x509_crt,
    pub crl: mbedtls_x509_crl,
    pub signers: SignerInfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pkcs7 {
    pub contentTypeOid: mbedtls_asn1_buf,
    pub signedData: SignedData,
}
pub type PKCS7_CalcDigest = ::core::option::Option<
    unsafe extern "C" fn(
        pkcs7: *const Pkcs7,
        signer: *const SignerInfo,
        algType: mbedtls_md_type_t,
        hash: *mut ::core::ffi::c_uchar,
        hashLen: *mut size_t,
    ) -> i32,
>;
unsafe extern "C" {
    pub static EMPTY_STR: [::core::ffi::c_char; 1usize];
}
pub type ParameterChgPtr = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
        context: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cJSON {
    pub next: *mut cJSON,
    pub prev: *mut cJSON,
    pub child: *mut cJSON,
    pub type_: ::core::ffi::c_int,
    pub valuestring: *mut ::core::ffi::c_char,
    pub valueint: ::core::ffi::c_int,
    pub valuedouble: f64,
    pub string: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cJSON_Hooks {
    pub malloc_fn:
        ::core::option::Option<unsafe extern "C" fn(sz: size_t) -> *mut ::core::ffi::c_void>,
    pub free_fn: ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void)>,
}
pub type cJSON_bool = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
unsafe extern "C" {
    pub static mut program_invocation_short_name: *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub static mut program_invocation_name: *mut ::core::ffi::c_char;
}
pub type errno_t = ::core::ffi::c_int;
pub type time_t = ::core::ffi::c_longlong;
pub type suseconds_t = ::core::ffi::c_longlong;
pub type timer_t = *mut ::core::ffi::c_void;
pub type clockid_t = ::core::ffi::c_int;
pub type clock_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: ::core::ffi::c_longlong,
    pub tv_usec: ::core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: ::core::ffi::c_longlong,
    pub tv_nsec: ::core::ffi::c_longlong,
}
pub type pid_t = ::core::ffi::c_int;
pub type sigset_t = ::core::ffi::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_attr_s {
    pub detachstate: ::core::ffi::c_uint,
    pub schedpolicy: ::core::ffi::c_uint,
    pub schedparam: sched_param,
    pub inheritsched: ::core::ffi::c_uint,
    pub scope: ::core::ffi::c_uint,
    pub stackaddr_set: ::core::ffi::c_uint,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize_set: ::core::ffi::c_uint,
    pub stacksize: size_t,
}
pub type pthread_attr_t = __pthread_attr_s;
pub type uid_t = ::core::ffi::c_uint;
pub type pthread_t = ::core::ffi::c_long;
pub type stack_t = sigaltstack;
pub type greg_t = ::core::ffi::c_int;
pub type gregset_t = [::core::ffi::c_int; 18usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub trap_no: ::core::ffi::c_ulong,
    pub error_code: ::core::ffi::c_ulong,
    pub oldmask: ::core::ffi::c_ulong,
    pub arm_r0: ::core::ffi::c_ulong,
    pub arm_r1: ::core::ffi::c_ulong,
    pub arm_r2: ::core::ffi::c_ulong,
    pub arm_r3: ::core::ffi::c_ulong,
    pub arm_r4: ::core::ffi::c_ulong,
    pub arm_r5: ::core::ffi::c_ulong,
    pub arm_r6: ::core::ffi::c_ulong,
    pub arm_r7: ::core::ffi::c_ulong,
    pub arm_r8: ::core::ffi::c_ulong,
    pub arm_r9: ::core::ffi::c_ulong,
    pub arm_r10: ::core::ffi::c_ulong,
    pub arm_fp: ::core::ffi::c_ulong,
    pub arm_ip: ::core::ffi::c_ulong,
    pub arm_sp: ::core::ffi::c_ulong,
    pub arm_lr: ::core::ffi::c_ulong,
    pub arm_pc: ::core::ffi::c_ulong,
    pub arm_cpsr: ::core::ffi::c_ulong,
    pub fault_address: ::core::ffi::c_ulong,
}
pub type mcontext_t = sigcontext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_flags: ::core::ffi::c_int,
    pub ss_size: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext {
    pub uc_flags: ::core::ffi::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub uc_regspace: [::core::ffi::c_ulonglong; 64usize],
}
pub type ucontext_t = ucontext;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::core::ffi::c_int,
    pub sival_ptr: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::core::ffi::c_int,
    pub si_errno: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub __si_fields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub __pad: [::core::ffi::c_char; 116usize],
    pub __si_common: siginfo_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub __first: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __second: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __piduid: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __timer: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: pid_t,
    pub si_uid: uid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub si_timerid: ::core::ffi::c_int,
    pub si_overrun: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub si_value: sigval,
    pub __sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub si_status: ::core::ffi::c_int,
    pub si_utime: clock_t,
    pub si_stime: clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub sa_sigactionhandler: sigaction__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_flags: ::core::ffi::c_int,
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub sa_sigaction: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::core::ffi::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::core::ffi::c_void,
        ),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_notify: ::core::ffi::c_int,
    pub __sev_fields: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub __pad: [::core::ffi::c_char; 52usize],
    pub sigev_notify_thread_id: pid_t,
    pub __sev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub sigev_notify_function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
pub type sig_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
pub type sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
pub type sig_atomic_t = ::core::ffi::c_int;
pub type fd_mask = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [::core::ffi::c_ulong; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::core::ffi::c_int,
    pub tz_dsttime: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval64 {
    pub it_interval: timeval64,
    pub it_value: timeval64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
    pub tm_gmtoff: ::core::ffi::c_long,
    pub tm_zone: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec64 {
    pub it_interval: timespec64,
    pub it_value: timespec64,
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::core::ffi::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut daylight: ::core::ffi::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::core::ffi::c_long;
}
unsafe extern "C" {
    pub static mut getdate_err: ::core::ffi::c_int;
}
pub type mbedtls_time_t = time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
pub type mbedtls_ms_time_t = i64;
unsafe extern "C" {
    pub static mut mbedtls_time:
        ::core::option::Option<unsafe extern "C" fn(time: *mut mbedtls_time_t) -> mbedtls_time_t>;
}
unsafe extern "C" {
    pub static mut mbedtls_snprintf: ::core::option::Option<
        unsafe extern "C" fn(
            s: *mut ::core::ffi::c_char,
            n: size_t,
            format: *const ::core::ffi::c_char,
            ...
        ) -> ::core::ffi::c_int,
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_platform_context {
    pub private_dummy: ::core::ffi::c_char,
}

// ==========================================
// Auto-generated placeholders for external types
// These allow compilation without the actual headers
// ==========================================

/// Standard C FFI type `c_char`
pub use core::ffi::c_char;
