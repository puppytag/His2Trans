/* automatically generated by rust-bindgen 0.72.1 */
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(unused)]

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type time_t = ::core::ffi::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [::core::ffi::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: ::core::ffi::c_longlong,
    pub tv_nsec: ::core::ffi::c_longlong,
}
pub type pid_t = ::core::ffi::c_int;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __ll: ::core::ffi::c_longlong,
    pub __ld: f64,
}
pub type size_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_param {
    pub __bindgen_anon_1: sched_param__bindgen_ty_1,
    pub sched_deadline: ::core::ffi::c_int,
    pub sched_period: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sched_param__bindgen_ty_1 {
    pub sched_priority: ::core::ffi::c_int,
    pub sched_runtime: ::core::ffi::c_int,
}
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i32;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u32;
pub type uint_fast32_t = u32;
pub type va_list = u32;
pub type __isoc_va_list = u32;
pub type ssize_t = ::core::ffi::c_int;
pub type off_t = ::core::ffi::c_longlong;
pub type loff_t = ::core::ffi::c_longlong;
pub type off64_t = off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _G_fpos64_t {
    pub __opaque: [::core::ffi::c_char; 16usize],
    pub __lldata: ::core::ffi::c_longlong,
    pub __align: f64,
}
pub type fpos_t = _G_fpos64_t;
unsafe extern "C" {
}
unsafe extern "C" {
}
unsafe extern "C" {
}
pub const FDSAN_OWNER_TYPE_DEFAULT: fdsan_owner_type = 0;
pub const FDSAN_OWNER_TYPE_MAX: fdsan_owner_type = 255;
pub const FDSAN_OWNER_TYPE_FILE: fdsan_owner_type = 1;
pub const FDSAN_OWNER_TYPE_DIRECTORY: fdsan_owner_type = 2;
pub const FDSAN_OWNER_TYPE_UNIQUE_FD: fdsan_owner_type = 3;
pub const FDSAN_OWNER_TYPE_ZIP_ARCHIVE: fdsan_owner_type = 4;
pub type fdsan_owner_type = ::core::ffi::c_uint;
pub const FDSAN_ERROR_LEVEL_DISABLED: fdsan_error_level = 0;
pub const FDSAN_ERROR_LEVEL_WARN_ONCE: fdsan_error_level = 1;
pub const FDSAN_ERROR_LEVEL_WARN_ALWAYS: fdsan_error_level = 2;
pub const FDSAN_ERROR_LEVEL_FATAL: fdsan_error_level = 3;
pub type fdsan_error_level = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_struct;
pub type suseconds_t = ::core::ffi::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_attr_s {
    pub detachstate: ::core::ffi::c_uint,
    pub schedpolicy: ::core::ffi::c_uint,
    pub schedparam: sched_param,
    pub inheritsched: ::core::ffi::c_uint,
    pub scope: ::core::ffi::c_uint,
    pub stackaddr_set: ::core::ffi::c_uint,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize_set: ::core::ffi::c_uint,
    pub stacksize: size_t,
    pub cpuset: cpu_set_t,
}
pub type pthread_attr_t = __pthread_attr_s;
pub type register_t = ::core::ffi::c_int;
pub type u_int64_t = ::core::ffi::c_ulonglong;
pub type mode_t = ::core::ffi::c_uint;
pub type nlink_t = ::core::ffi::c_uint;
pub type ino_t = ::core::ffi::c_ulonglong;
pub type dev_t = ::core::ffi::c_ulonglong;
pub type blksize_t = ::core::ffi::c_long;
pub type blkcnt_t = ::core::ffi::c_longlong;
pub type fsblkcnt_t = ::core::ffi::c_ulonglong;
pub type fsfilcnt_t = ::core::ffi::c_ulonglong;
pub type timer_t = *mut ::core::ffi::c_void;
pub type clockid_t = ::core::ffi::c_int;
pub type clock_t = ::core::ffi::c_long;
pub type id_t = ::core::ffi::c_uint;
pub type uid_t = ::core::ffi::c_uint;
pub type gid_t = ::core::ffi::c_uint;
pub type key_t = ::core::ffi::c_int;
pub type useconds_t = ::core::ffi::c_uint;
pub type pthread_t = ::core::ffi::c_long;
pub type pthread_once_t = ::core::ffi::c_int;
pub type pthread_key_t = ::core::ffi::c_int;
pub type pthread_condattr_t = ::core::ffi::c_int;
pub type u_int8_t = ::core::ffi::c_uchar;
pub type u_int16_t = ::core::ffi::c_ushort;
pub type u_int32_t = ::core::ffi::c_uint;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type ushort = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type uint = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type ulong = ::core::ffi::c_ulong;
pub type quad_t = ::core::ffi::c_longlong;
pub type u_quad_t = ::core::ffi::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: ::core::ffi::c_longlong,
    pub tv_usec: ::core::ffi::c_longlong,
}
pub type sigset_t = ::core::ffi::c_ulonglong;
pub type fd_mask = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [::core::ffi::c_ulong; 32usize],
}
pub const HDF_SUCCESS: HDF_STATUS = 0;
pub const HDF_FAILURE: HDF_STATUS = -1;
pub const HDF_ERR_NOT_SUPPORT: HDF_STATUS = -2;
pub const HDF_ERR_INVALID_PARAM: HDF_STATUS = -3;
pub const HDF_ERR_INVALID_OBJECT: HDF_STATUS = -4;
pub const HDF_ERR_MALLOC_FAIL: HDF_STATUS = -6;
pub const HDF_ERR_TIMEOUT: HDF_STATUS = -7;
pub const HDF_ERR_THREAD_CREATE_FAIL: HDF_STATUS = -10;
pub const HDF_ERR_QUEUE_FULL: HDF_STATUS = -15;
pub const HDF_ERR_DEVICE_BUSY: HDF_STATUS = -16;
pub const HDF_ERR_IO: HDF_STATUS = -17;
pub const HDF_ERR_BAD_FD: HDF_STATUS = -18;
pub const HDF_ERR_NOPERM: HDF_STATUS = -19;
pub const HDF_ERR_OUT_OF_RANGE: HDF_STATUS = -20;
pub const HDF_BSP_ERR_OP: HDF_STATUS = -101;
pub const HDF_ERR_BSP_PLT_API_ERR: HDF_STATUS = -102;
pub const HDF_PAL_ERR_DEV_CREATE: HDF_STATUS = -103;
pub const HDF_PAL_ERR_INNER: HDF_STATUS = -104;
pub const HDF_DEV_ERR_NO_MEMORY: HDF_STATUS = -201;
pub const HDF_DEV_ERR_NO_DEVICE: HDF_STATUS = -202;
pub const HDF_DEV_ERR_NO_DEVICE_SERVICE: HDF_STATUS = -203;
pub const HDF_DEV_ERR_DEV_INIT_FAIL: HDF_STATUS = -204;
pub const HDF_DEV_ERR_PUBLISH_FAIL: HDF_STATUS = -205;
pub const HDF_DEV_ERR_ATTACHDEV_FAIL: HDF_STATUS = -206;
pub const HDF_DEV_ERR_NODATA: HDF_STATUS = -207;
pub const HDF_DEV_ERR_NORANGE: HDF_STATUS = -208;
pub const HDF_DEV_ERR_OP: HDF_STATUS = -210;
pub const HDF_DEV_ERR_NETDOWN: HDF_STATUS = -211;
pub type HDF_STATUS = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfObject {
    pub objectId: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DListHead {
    pub next: *mut DListHead,
    pub prev: *mut DListHead,
}
pub type devid_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IHdfDevice {
    pub object: HdfObject,
    pub Attach: ::core::option::Option<
        unsafe extern "C" fn(
            device: *mut IHdfDevice,
            deviceNode: *mut HdfDeviceNode,
        ) -> ::core::ffi::c_int,
    >,
    pub Detach: ::core::option::Option<
        unsafe extern "C" fn(
            device: *mut IHdfDevice,
            deviceNode: *mut HdfDeviceNode,
        ) -> ::core::ffi::c_int,
    >,
    pub GetDeviceNode: ::core::option::Option<
        unsafe extern "C" fn(device: *mut IHdfDevice, devid: devid_t) -> *mut HdfDeviceNode,
    >,
    pub DetachWithDevid: ::core::option::Option<
        unsafe extern "C" fn(device: *mut IHdfDevice, devid: devid_t) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDevice {
    pub super_: IHdfDevice,
    pub node: DListHead,
    pub devNodes: DListHead,
    pub deviceId: devid_t,
    pub devidIndex: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IHdfDeviceToken {
    pub object: HdfObject,
    pub devid: devid_t,
    pub servName: *const ::core::ffi::c_char,
    pub deviceName: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSListNode {
    pub next: *mut HdfSListNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSList {
    pub root: *mut HdfSListNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSListIterator {
    pub stepOnNext: ::core::ffi::c_int,
    pub prev: *mut HdfSListNode,
    pub curr: *mut HdfSListNode,
}
pub type HdfSListDeleter = ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfSListNode)>;
pub type HdfSListSearchComparer =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfSListNode, arg2: u32) -> bool>;
pub type HdfSListAddComparer = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut HdfSListNode, arg2: *mut HdfSListNode) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceToken {
    pub super_: IHdfDeviceToken,
    pub node: HdfSListNode,
}
pub const DEVICE_CLASS_DEFAULT: DeviceClass = 1;
pub const DEVICE_CLASS_PLAT: DeviceClass = 2;
pub const DEVICE_CLASS_SENSOR: DeviceClass = 4;
pub const DEVICE_CLASS_INPUT: DeviceClass = 8;
pub const DEVICE_CLASS_DISPLAY: DeviceClass = 16;
pub const DEVICE_CLASS_AUDIO: DeviceClass = 32;
pub const DEVICE_CLASS_CAMERA: DeviceClass = 64;
pub const DEVICE_CLASS_USB: DeviceClass = 128;
pub const DEVICE_CLASS_USERAUTH: DeviceClass = 256;
pub const DEVICE_CLASS_HIMEDIACOMM: DeviceClass = 512;
pub const DEVICE_CLASS_MAX: DeviceClass = 1024;
pub type DeviceClass = ::core::ffi::c_uint;
pub type char16_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSBuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSBufImpl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfRemoteService {
    _unused: [u8; 0],
}
pub const SBUF_RAW: HdfSbufType = 0;
pub const SBUF_IPC: HdfSbufType = 1;
pub const SBUF_IPC_HW: HdfSbufType = 2;
pub const SBUF_TYPE_MAX: HdfSbufType = 3;
pub type HdfSbufType = ::core::ffi::c_uint;
pub type OnEventReceived = ::core::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::core::ffi::c_void,
        id: u32,
        data: *mut HdfSBuf,
    ) -> ::core::ffi::c_int,
>;
pub type OnDevEventReceive = ::core::option::Option<
    unsafe extern "C" fn(
        listener: *mut HdfDevEventlistener,
        service: *mut HdfIoService,
        id: u32,
        data: *mut HdfSBuf,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDevEventlistener {
    pub callBack: OnEventReceived,
    pub onReceive: OnDevEventReceive,
    pub listNode: DListHead,
    pub priv_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfIoDispatcher {
    pub Dispatch: ::core::option::Option<
        unsafe extern "C" fn(
            service: *mut HdfObject,
            cmdId: ::core::ffi::c_int,
            data: *mut HdfSBuf,
            reply: *mut HdfSBuf,
        ) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfIoService {
    pub object: HdfObject,
    pub target: *mut HdfObject,
    pub dispatcher: *mut HdfIoDispatcher,
    pub priv_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfIoServiceGroup {
    pub object: HdfObject,
}
pub const SERVICE_POLICY_NONE: ServicePolicy = 0;
pub const SERVICE_POLICY_PUBLIC: ServicePolicy = 1;
pub const SERVICE_POLICY_CAPACITY: ServicePolicy = 2;
pub const SERVICE_POLICY_FRIENDLY: ServicePolicy = 3;
pub const SERVICE_POLICY_PRIVATE: ServicePolicy = 4;
pub const SERVICE_POLICY_INVALID: ServicePolicy = 5;
pub type ServicePolicy = ::core::ffi::c_uint;
pub const DEVICE_PRELOAD_ENABLE: DevicePreload = 0;
pub const DEVICE_PRELOAD_ENABLE_STEP2: DevicePreload = 1;
pub const DEVICE_PRELOAD_DISABLE: DevicePreload = 2;
pub const DEVICE_PRELOAD_INVALID: DevicePreload = 3;
pub type DevicePreload = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceObject {
    pub service: *mut IDeviceIoService,
    pub property: *const DeviceResourceNode,
    pub deviceClass: DeviceClass,
    pub priv_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceIoClient {
    pub device: *mut HdfDeviceObject,
    pub priv_: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDeviceIoService {
    pub object: HdfObject,
    pub Open: ::core::option::Option<unsafe extern "C" fn(client: *mut HdfDeviceIoClient) -> i32>,
    pub Dispatch: ::core::option::Option<
        unsafe extern "C" fn(
            client: *mut HdfDeviceIoClient,
            cmdId: ::core::ffi::c_int,
            data: *mut HdfSBuf,
            reply: *mut HdfSBuf,
        ) -> i32,
    >,
    pub Release: ::core::option::Option<unsafe extern "C" fn(client: *mut HdfDeviceIoClient)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubscriberCallback {
    pub deviceObject: *mut HdfDeviceObject,
    pub OnServiceConnected: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject, service: *const HdfObject) -> i32,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDriverEntry {
    pub moduleVersion: i32,
    pub moduleName: *const ::core::ffi::c_char,
    pub Bind:
        ::core::option::Option<unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> i32>,
    pub Init:
        ::core::option::Option<unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> i32>,
    pub Release: ::core::option::Option<unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OsalMutex {
    pub realMutex: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfServiceObserver {
    pub services: HdfSList,
    pub observerMutex: OsalMutex,
}
pub const HDF_SERVICE_UNUSABLE: _bindgen_ty_1 = 0;
pub const HDF_SERVICE_USABLE: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
pub const HDF_DEV_LOCAL_SERVICE: _bindgen_ty_2 = 0;
pub const HDF_DEV_REMOTE_SERVICE: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceInfo {
    pub node: HdfSListNode,
    pub isDynamic: bool,
    pub status: u16,
    pub deviceType: u16,
    pub deviceId: u32,
    pub policy: u16,
    pub priority: u16,
    pub preload: u16,
    pub permission: u16,
    pub moduleName: *const ::core::ffi::c_char,
    pub svcName: *const ::core::ffi::c_char,
    pub deviceMatchAttr: *const ::core::ffi::c_char,
    pub deviceName: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfPrivateInfo {
    pub length: u32,
    pub data: *const ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDriver {
    pub entry: *const HdfDriverEntry,
    pub type_: u16,
    pub bus: u16,
    pub node: DListHead,
    pub priv_: *mut ::core::ffi::c_void,
}
pub const KEVENT_POWER_SUSPEND: PowerKeventId = 0;
pub const KEVENT_POWER_DISPLAY_OFF: PowerKeventId = 1;
pub const KEVENT_POWER_RESUME: PowerKeventId = 2;
pub const KEVENT_POWER_DISPLAY_ON: PowerKeventId = 3;
pub const KEVENT_POWER_EVENT_MAX: PowerKeventId = 4;
pub type PowerKeventId = ::core::ffi::c_uint;
pub const KEVENT_MODULE_INSTALL: DriverModuleKeventId = 0;
pub const KEVENT_MODULE_REMOVE: DriverModuleKeventId = 1;
pub const KEVENT_MODULE_EVENT_MAX: DriverModuleKeventId = 2;
pub type DriverModuleKeventId = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSysEvent {
    pub eventClass: u64,
    pub syncToken: u64,
    pub eventid: u32,
    pub reserved: u32,
}
pub type HdfSysEventNotifierFn = ::core::option::Option<
    unsafe extern "C" fn(
        self_: *mut HdfSysEventNotifyNode,
        eventClass: u64,
        event: u32,
        content: *const ::core::ffi::c_char,
    ) -> i32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSysEventNotifyNode {
    pub callback: HdfSysEventNotifierFn,
    pub listNode: DListHead,
    pub classFilter: u64,
}
pub const HDF_POWER_SYS_CTRL: PowerManagementMode = 0;
pub const HDF_POWER_DYNAMIC_CTRL: PowerManagementMode = 1;
pub const HDF_POWER_MODE_MAX: PowerManagementMode = 2;
pub type PowerManagementMode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPowerEventListener {
    pub DozeResume: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> ::core::ffi::c_int,
    >,
    pub DozeSuspend: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> ::core::ffi::c_int,
    >,
    pub Resume: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> ::core::ffi::c_int,
    >,
    pub Suspend: ::core::option::Option<
        unsafe extern "C" fn(deviceObject: *mut HdfDeviceObject) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDeviceNode {
    pub object: HdfObject,
    pub PublishService: ::core::option::Option<
        unsafe extern "C" fn(devNode: *mut HdfDeviceNode) -> ::core::ffi::c_int,
    >,
    pub RemoveService: ::core::option::Option<
        unsafe extern "C" fn(devNode: *mut HdfDeviceNode) -> ::core::ffi::c_int,
    >,
    pub LaunchNode: ::core::option::Option<
        unsafe extern "C" fn(devNode: *mut HdfDeviceNode) -> ::core::ffi::c_int,
    >,
    pub UnlaunchNode: ::core::option::Option<unsafe extern "C" fn(devNode: *mut HdfDeviceNode)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDeviceNode {
    pub super_: IDeviceNode,
    pub entry: DListHead,
    pub powerToken: *mut PowerStateToken,
    pub hostService: *mut DevHostService,
    pub deviceObject: HdfDeviceObject,
    pub token: *mut IHdfDeviceToken,
    pub driver: *mut HdfDriver,
    pub device: *mut HdfDevice,
    pub servName: *mut ::core::ffi::c_char,
    pub servInfo: *const ::core::ffi::c_char,
    pub driverName: *mut ::core::ffi::c_char,
    pub devId: devid_t,
    pub policy: u16,
    pub permission: u16,
    pub devStatus: u8,
    pub servStatus: bool,
    pub interfaceDesc: *mut ::core::ffi::c_char,
}
pub const DEVNODE_NONE: DevNodeStaus = 0;
pub const DEVNODE_INITED: DevNodeStaus = 1;
pub const DEVNODE_LAUNCHED: DevNodeStaus = 2;
pub type DevNodeStaus = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDriverLoader {
    pub object: HdfObject,
    pub GetDriver: ::core::option::Option<
        unsafe extern "C" fn(driverName: *const ::core::ffi::c_char) -> *mut HdfDriver,
    >,
    pub ReclaimDriver: ::core::option::Option<unsafe extern "C" fn(driver: *mut HdfDriver)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfDriverLoader {
    pub super_: IDriverLoader,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDevHostService {
    pub object: HdfObject,
    pub AddDevice: ::core::option::Option<
        unsafe extern "C" fn(
            hostService: *mut IDevHostService,
            devInfo: *const HdfDeviceInfo,
        ) -> ::core::ffi::c_int,
    >,
    pub DelDevice: ::core::option::Option<
        unsafe extern "C" fn(
            hostService: *mut IDevHostService,
            devId: devid_t,
        ) -> ::core::ffi::c_int,
    >,
    pub StartService: ::core::option::Option<
        unsafe extern "C" fn(hostService: *mut IDevHostService) -> ::core::ffi::c_int,
    >,
    pub PmNotify: ::core::option::Option<
        unsafe extern "C" fn(service: *mut IDevHostService, powerState: u32) -> ::core::ffi::c_int,
    >,
    pub Dump: ::core::option::Option<
        unsafe extern "C" fn(
            hostService: *mut IDevHostService,
            data: *mut HdfSBuf,
            reply: *mut HdfSBuf,
        ) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DevHostService {
    pub super_: IDevHostService,
    pub hostId: u16,
    pub hostName: *const ::core::ffi::c_char,
    pub devices: DListHead,
    pub observer: HdfServiceObserver,
    pub sysEventNotifyNode: HdfSysEventNotifyNode,
}
pub const POWER_STATE_DOZE_RESUME: HdfPowerState = 0;
pub const POWER_STATE_DOZE_SUSPEND: HdfPowerState = 1;
pub const POWER_STATE_RESUME: HdfPowerState = 2;
pub const POWER_STATE_SUSPEND: HdfPowerState = 3;
pub const POWER_STATE_MAX: HdfPowerState = 4;
pub type HdfPowerState = ::core::ffi::c_uint;
pub const PSM_STATE_IDLE: HdfPsmState = 0;
pub const PSM_STATE_ACTIVE: HdfPsmState = 1;
pub const PSM_STATE_INACTIVE: HdfPsmState = 2;
pub type HdfPsmState = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPowerStateToken {
    pub AcquireWakeLock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut IPowerStateToken)>,
    pub ReleaseWakeLock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut IPowerStateToken)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDevmgrService {
    pub base: HdfObject,
    pub object: HdfDeviceObject,
    pub AttachDeviceHost: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            arg2: u16,
            arg3: *mut IDevHostService,
        ) -> ::core::ffi::c_int,
    >,
    pub AttachDevice: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            arg2: *mut IHdfDeviceToken,
        ) -> ::core::ffi::c_int,
    >,
    pub DetachDevice: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevmgrService, arg2: devid_t) -> ::core::ffi::c_int,
    >,
    pub LoadDevice: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            arg2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    pub UnloadDevice: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            arg2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    pub StartService: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevmgrService) -> ::core::ffi::c_int,
    >,
    pub PowerStateChange: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevmgrService,
            pEvent: HdfPowerState,
        ) -> ::core::ffi::c_int,
    >,
    pub ListAllDevice: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevmgrService, arg2: *mut HdfSBuf) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DevmgrServiceClnt {
    pub devMgrSvcIf: *mut IDevmgrService,
}
pub type UINT8 = ::core::ffi::c_uchar;
pub type UINT16 = ::core::ffi::c_ushort;
pub type UINT32 = ::core::ffi::c_uint;
pub type INT8 = ::core::ffi::c_schar;
pub type INT16 = ::core::ffi::c_short;
pub type INT32 = ::core::ffi::c_int;
pub type FLOAT = f32;
pub type DOUBLE = f64;
pub type CHAR = ::core::ffi::c_char;
pub type UINT64 = ::core::ffi::c_ulonglong;
pub type INT64 = ::core::ffi::c_longlong;
pub type UINTPTR = ::core::ffi::c_uint;
pub type INTPTR = ::core::ffi::c_int;
pub type AARCHPTR = UINTPTR;
pub type BOOL = size_t;
pub type status_t = ::core::ffi::c_int;
pub type vaddr_t = ::core::ffi::c_ulong;
pub type PADDR_T = ::core::ffi::c_ulong;
pub type VADDR_T = ::core::ffi::c_ulong;
pub type paddr_t = ::core::ffi::c_ulong;
pub type DMA_ADDR_T = ::core::ffi::c_ulong;
pub type ADDR_T = ::core::ffi::c_ulong;
pub type VM_OFFSET_T = ::core::ffi::c_ulong;
pub type PTE_T = ::core::ffi::c_ulong;
pub type ULONG_T = ::core::ffi::c_uint;
pub type STATUS_T = ::core::ffi::c_int;
pub type Atomic = INT32;
pub type Atomic64 = INT64;
pub type LOS_ERRORHANDLE_FUNC = ::core::option::Option<
    unsafe extern "C" fn(
        fileName: *mut CHAR,
        lineNo: UINT32,
        errorNo: UINT32,
        paraLen: UINT32,
        para: *mut ::core::ffi::c_void,
    ),
>;
pub const LOS_MOD_SYS: LOS_MOUDLE_ID = 0;
pub const LOS_MOD_MEM: LOS_MOUDLE_ID = 1;
pub const LOS_MOD_TSK: LOS_MOUDLE_ID = 2;
pub const LOS_MOD_SWTMR: LOS_MOUDLE_ID = 3;
pub const LOS_MOD_TICK: LOS_MOUDLE_ID = 4;
pub const LOS_MOD_MSG: LOS_MOUDLE_ID = 5;
pub const LOS_MOD_QUE: LOS_MOUDLE_ID = 6;
pub const LOS_MOD_SEM: LOS_MOUDLE_ID = 7;
pub const LOS_MOD_MBOX: LOS_MOUDLE_ID = 8;
pub const LOS_MOD_HWI: LOS_MOUDLE_ID = 9;
pub const LOS_MOD_HWWDG: LOS_MOUDLE_ID = 10;
pub const LOS_MOD_CACHE: LOS_MOUDLE_ID = 11;
pub const LOS_MOD_HWTMR: LOS_MOUDLE_ID = 12;
pub const LOS_MOD_MMU: LOS_MOUDLE_ID = 13;
pub const LOS_MOD_LOG: LOS_MOUDLE_ID = 14;
pub const LOS_MOD_ERR: LOS_MOUDLE_ID = 15;
pub const LOS_MOD_EXC: LOS_MOUDLE_ID = 16;
pub const LOS_MOD_CSTK: LOS_MOUDLE_ID = 17;
pub const LOS_MOD_MPU: LOS_MOUDLE_ID = 18;
pub const LOS_MOD_NMHWI: LOS_MOUDLE_ID = 19;
pub const LOS_MOD_TRACE: LOS_MOUDLE_ID = 20;
pub const LOS_MOD_KNLSTAT: LOS_MOUDLE_ID = 21;
pub const LOS_MOD_EVTTIME: LOS_MOUDLE_ID = 22;
pub const LOS_MOD_THRDCPUP: LOS_MOUDLE_ID = 23;
pub const LOS_MOD_IPC: LOS_MOUDLE_ID = 24;
pub const LOS_MOD_STKMON: LOS_MOUDLE_ID = 25;
pub const LOS_MOD_TIMER: LOS_MOUDLE_ID = 26;
pub const LOS_MOD_RESLEAKMON: LOS_MOUDLE_ID = 27;
pub const LOS_MOD_EVENT: LOS_MOUDLE_ID = 28;
pub const LOS_MOD_MUX: LOS_MOUDLE_ID = 29;
pub const LOS_MOD_CPUP: LOS_MOUDLE_ID = 30;
pub const LOS_MOD_HOOK: LOS_MOUDLE_ID = 31;
pub const LOS_MOD_PERF: LOS_MOUDLE_ID = 32;
pub const LOS_MOD_PM: LOS_MOUDLE_ID = 33;
pub const LOS_MOD_SHELL: LOS_MOUDLE_ID = 49;
pub const LOS_MOD_DRIVER: LOS_MOUDLE_ID = 65;
pub const LOS_MOD_BUTT: LOS_MOUDLE_ID = 66;
pub type LOS_MOUDLE_ID = ::core::ffi::c_uint;
unsafe extern "C" {
    pub static mut g_sysClock: UINT32;
}
unsafe extern "C" {
    pub static mut g_tickPerSecond: UINT32;
}
unsafe extern "C" {
    pub static mut __int_stack_start: CHAR;
}
unsafe extern "C" {
    pub static mut __rodata_start: CHAR;
}
unsafe extern "C" {
    pub static mut __rodata_end: CHAR;
}
unsafe extern "C" {
    pub static mut __bss_start: CHAR;
}
unsafe extern "C" {
    pub static mut __bss_end: CHAR;
}
unsafe extern "C" {
    pub static mut __text_start: CHAR;
}
unsafe extern "C" {
    pub static mut __text_end: CHAR;
}
unsafe extern "C" {
    pub static mut __ram_data_start: CHAR;
}
unsafe extern "C" {
    pub static mut __ram_data_end: CHAR;
}
unsafe extern "C" {
    pub static mut __heap_start: UINT32;
}
unsafe extern "C" {
    pub static mut __heap_end: UINT32;
}
pub type SystemRebootFunc = ::core::option::Option<unsafe extern "C" fn()>;
pub type pf_OUTPUT = ::core::option::Option<unsafe extern "C" fn(fmt: *const CHAR, ...)>;
pub const NO_OUTPUT: OutputType = 0;
pub const UART_OUTPUT: OutputType = 1;
pub const CONSOLE_OUTPUT: OutputType = 2;
pub const EXC_OUTPUT: OutputType = 3;
pub type OutputType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOS_DL_LIST {
    pub pstPrev: *mut LOS_DL_LIST,
    pub pstNext: *mut LOS_DL_LIST,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuVendor {
    pub partNo: UINT32,
    pub cpuName: *const CHAR,
}
unsafe extern "C" {
    pub static mut g_cpuTable: [CpuVendor; 0usize];
}
unsafe extern "C" {
    pub static mut g_cpuMap: [UINT64; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
pub type errno_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExcContext {
    pub R4: UINT32,
    pub R5: UINT32,
    pub R6: UINT32,
    pub R7: UINT32,
    pub R8: UINT32,
    pub R9: UINT32,
    pub R10: UINT32,
    pub R11: UINT32,
    pub SP: UINT32,
    pub reserved: UINT32,
    pub USP: UINT32,
    pub ULR: UINT32,
    pub R0: UINT32,
    pub R1: UINT32,
    pub R2: UINT32,
    pub R3: UINT32,
    pub R12: UINT32,
    pub LR: UINT32,
    pub PC: UINT32,
    pub regCPSR: UINT32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExcInfo {
    pub phase: UINT16,
    pub type_: UINT16,
    pub nestCnt: UINT16,
    pub reserved: UINT16,
    pub context: *mut ExcContext,
}
pub type EXC_PROC_FUNC = ::core::option::Option<
    unsafe extern "C" fn(arg1: UINT32, arg2: *mut ExcContext, arg3: UINT32, arg4: UINT32),
>;
unsafe extern "C" {
    pub static mut g_intCount: [size_t; 0usize];
}
pub type HWI_HANDLE_T = UINT32;
pub type HWI_PRIOR_T = UINT16;
pub type HWI_MODE_T = UINT16;
pub type HWI_ARG_T = UINTPTR;
pub type HWI_PROC_FUNC = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHwiHandleForm {
    pub pfnHook: HWI_PROC_FUNC,
    pub uwParam: HWI_ARG_T,
    pub pstNext: *mut tagHwiHandleForm,
}
pub type HwiHandleForm = tagHwiHandleForm;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIrqParam {
    pub swIrq: ::core::ffi::c_int,
    pub pDevId: *mut ::core::ffi::c_void,
    pub pName: *const CHAR,
}
pub type HwiIrqParam = tagIrqParam;
unsafe extern "C" {
    pub static mut g_hwiForm: [HwiHandleForm; 128usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OsalAtomic {
    pub counter: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IHdfSRefListener {
    pub OnFirstAcquire: ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfSRef)>,
    pub OnLastRelease: ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfSRef)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfSRef {
    pub refs: OsalAtomic,
    pub listener: *mut IHdfSRefListener,
    pub Acquire: ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfSRef)>,
    pub Release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfSRef)>,
    pub Count:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const HdfSRef) -> ::core::ffi::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PowerStateToken {
    pub super_: IPowerStateToken,
    pub listener: *const IPowerEventListener,
    pub deviceObject: *mut HdfDeviceObject,
    pub wakeRef: HdfSRef,
    pub psmState: HdfPsmState,
    pub mode: u32,
}
pub const SERVIE_STATUS_START: ServiceStatusType = 0;
pub const SERVIE_STATUS_CHANGE: ServiceStatusType = 1;
pub const SERVIE_STATUS_STOP: ServiceStatusType = 2;
pub const SERVIE_STATUS_REGISTER: ServiceStatusType = 3;
pub const SERVIE_STATUS_MAX: ServiceStatusType = 4;
pub type ServiceStatusType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ServiceStatus {
    pub serviceName: *const ::core::ffi::c_char,
    pub deviceClass: u16,
    pub status: u16,
    pub info: *const ::core::ffi::c_char,
}
pub type OnServiceStatusReceived = ::core::option::Option<
    unsafe extern "C" fn(listener: *mut ServiceStatusListener, status: *mut ServiceStatus),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ServiceStatusListener {
    pub callback: OnServiceStatusReceived,
    pub priv_: *mut ::core::ffi::c_void,
}
pub const SERVIE_STATUS_LISTENER_NOTIFY: ServiceStatusListenerCmd = 0;
pub const SERVIE_STATUS_LISTENER_MAX: ServiceStatusListenerCmd = 1;
pub type ServiceStatusListenerCmd = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ServStatListenerHolder {
    pub listenClass: u16,
    pub node: DListHead,
    pub index: u64,
    pub NotifyStatus: ::core::option::Option<
        unsafe extern "C" fn(
            holder: *mut ServStatListenerHolder,
            status: *mut ServiceStatus,
        ) -> i32,
    >,
    pub Recycle: ::core::option::Option<unsafe extern "C" fn(holder: *mut ServStatListenerHolder)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfServiceInfo {
    pub servName: *const ::core::ffi::c_char,
    pub servInfo: *const ::core::ffi::c_char,
    pub devClass: u16,
    pub devId: devid_t,
    pub interfaceDesc: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDevSvcManager {
    pub object: HdfObject,
    pub StartService: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevSvcManager) -> ::core::ffi::c_int,
    >,
    pub AddService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *mut HdfDeviceObject,
            arg3: *const HdfServiceInfo,
        ) -> ::core::ffi::c_int,
    >,
    pub UpdateService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *mut HdfDeviceObject,
            arg3: *const HdfServiceInfo,
        ) -> ::core::ffi::c_int,
    >,
    pub SubscribeService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
            arg3: SubscriberCallback,
        ) -> ::core::ffi::c_int,
    >,
    pub UnsubscribeService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int,
    >,
    pub GetService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
        ) -> *mut HdfObject,
    >,
    pub GetObject: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
        ) -> *mut HdfDeviceObject,
    >,
    pub RemoveService: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
            arg3: *const HdfDeviceObject,
        ),
    >,
    pub RegsterServListener: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *mut ServStatListenerHolder,
        ) -> ::core::ffi::c_int,
    >,
    pub UnregsterServListener: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut IDevSvcManager, arg2: *mut ServStatListenerHolder),
    >,
    pub ListAllService:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut IDevSvcManager, arg2: *mut HdfSBuf)>,
    pub ListServiceByInterfaceDesc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut IDevSvcManager,
            arg2: *const ::core::ffi::c_char,
            arg3: *mut HdfSBuf,
        ) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DevSvcManagerClnt {
    pub devSvcMgrIf: *mut IDevSvcManager,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OsalSem {
    pub realSemaphore: *mut ::core::ffi::c_void,
}
pub const OSAL_THREAD_PRI_LOW: OSAL_THREAD_PRIORITY = 0;
pub const OSAL_THREAD_PRI_DEFAULT: OSAL_THREAD_PRIORITY = 1;
pub const OSAL_THREAD_PRI_HIGH: OSAL_THREAD_PRIORITY = 2;
pub const OSAL_THREAD_PRI_HIGHEST: OSAL_THREAD_PRIORITY = 3;
pub type OSAL_THREAD_PRIORITY = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OsalThreadParam {
    pub name: *mut ::core::ffi::c_char,
    pub stackSize: size_t,
    pub priority: OSAL_THREAD_PRIORITY,
    pub policy: ::core::ffi::c_int,
}
pub type OsalThreadEntry = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OsalThread {
    pub realThread: *mut ::core::ffi::c_void,
}
pub type HdfTaskFunc = ::core::option::Option<unsafe extern "C" fn(para: *mut HdfTaskType) -> i32>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfTaskType {
    pub node: DListHead,
    pub func: HdfTaskFunc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfTaskQueue {
    pub sem: OsalSem,
    pub mutex: OsalMutex,
    pub head: DListHead,
    pub thread: OsalThread,
    pub threadRunFlag: bool,
    pub queueFunc: HdfTaskFunc,
    pub queueName: *const ::core::ffi::c_char,
}
pub const HDF_PM_REQUEST_ACQUIRE: HDF_PM_REQUEST_TYPE = 0;
pub const HDF_PM_REQUEST_RELEASE: HDF_PM_REQUEST_TYPE = 1;
pub type HDF_PM_REQUEST_TYPE = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfPmRequest {
    pub token: *mut PowerStateToken,
    pub pmType: HDF_PM_REQUEST_TYPE,
    pub task: HdfTaskType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PmTaskQueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfServiceSubscriber {
    pub entry: HdfSListNode,
    pub state: u32,
    pub devId: u32,
    pub callback: SubscriberCallback,
}
pub const HDF_SUBSCRIBER_STATE_PENDING: _bindgen_ty_3 = 0;
pub const HDF_SUBSCRIBER_STATE_READY: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfServiceObserverRecord {
    pub entry: HdfSListNode,
    pub serviceKey: u32,
    pub policy: u16,
    pub devId: devid_t,
    pub obsRecMutex: OsalMutex,
    pub subscribers: HdfSList,
    pub publisher: *mut HdfObject,
}
pub const HILOG_MODULE_HIVIEW: HiLogModuleType = 0;
pub const HILOG_MODULE_SAMGR: HiLogModuleType = 1;
pub const HILOG_MODULE_ACE: HiLogModuleType = 2;
pub const HILOG_MODULE_GRAPHIC: HiLogModuleType = 3;
pub const HILOG_MODULE_APP: HiLogModuleType = 4;
pub const HILOG_MODULE_MAX: HiLogModuleType = 5;
pub type HiLogModuleType = ::core::ffi::c_uint;
pub const LOG_TYPE_MIN: LogType = 0;
pub const LOG_INIT: LogType = 1;
pub const LOG_CORE: LogType = 3;
pub const LOG_TYPE_MAX: LogType = 4;
pub type LogType = ::core::ffi::c_uint;
pub const LOG_DEBUG: LogLevel = 3;
pub const LOG_INFO: LogLevel = 4;
pub const LOG_WARN: LogLevel = 5;
pub const LOG_ERROR: LogLevel = 6;
pub const LOG_FATAL: LogLevel = 7;
pub type LogLevel = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct HdfCString {
    pub size: ::core::ffi::c_int,
    pub value: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfVdiBase {
    pub moduleVersion: u32,
    pub moduleName: *const ::core::ffi::c_char,
    pub CreateVdiInstance: ::core::option::Option<
        unsafe extern "C" fn(vdiBase: *mut HdfVdiBase) -> ::core::ffi::c_int,
    >,
    pub DestoryVdiInstance: ::core::option::Option<
        unsafe extern "C" fn(vdiBase: *mut HdfVdiBase) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfVdiObject {
    pub dlHandler: usize,
    pub vdiBase: *mut HdfVdiBase,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapNode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Map {
    pub nodes: *mut *mut MapNode,
    pub nodeSize: u32,
    pub bucketSize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DevHostServiceClnt {
    pub node: DListHead,
    pub devices: HdfSList,
    pub unloadDevInfos: HdfSList,
    pub dynamicDevInfos: HdfSList,
    pub deviceHashMap: *mut Map,
    pub hostService: *mut IDevHostService,
    pub hostLock: OsalMutex,
    pub devCount: u16,
    pub hostId: u16,
    pub hostPid: ::core::ffi::c_int,
    pub hostName: *const ::core::ffi::c_char,
    pub stopFlag: bool,
}
pub const HDF_CONFIG_SOURCE: DeviceResourceType = 0;
pub const INVALID: DeviceResourceType = 1;
pub type DeviceResourceType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceResourceAttr {
    pub name: *const ::core::ffi::c_char,
    pub value: *const ::core::ffi::c_char,
    pub next: *mut DeviceResourceAttr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceResourceNode {
    pub name: *const ::core::ffi::c_char,
    pub hashValue: u32,
    pub attrData: *mut DeviceResourceAttr,
    pub parent: *mut DeviceResourceNode,
    pub child: *mut DeviceResourceNode,
    pub sibling: *mut DeviceResourceNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceResourceIface {
    pub GetRootNode: ::core::option::Option<unsafe extern "C" fn() -> *const DeviceResourceNode>,
    pub GetBool: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
        ) -> bool,
    >,
    pub GetUint8: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            value: *mut u8,
            def: u8,
        ) -> i32,
    >,
    pub GetUint8ArrayElem: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            index: u32,
            value: *mut u8,
            def: u8,
        ) -> i32,
    >,
    pub GetUint8Array: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            value: *mut u8,
            len: u32,
            def: u8,
        ) -> i32,
    >,
    pub GetUint16: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            value: *mut u16,
            def: u16,
        ) -> i32,
    >,
    pub GetUint16ArrayElem: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            index: u32,
            value: *mut u16,
            def: u16,
        ) -> i32,
    >,
    pub GetUint16Array: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            value: *mut u16,
            len: u32,
            def: u16,
        ) -> i32,
    >,
    pub GetUint32: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            value: *mut u32,
            def: u32,
        ) -> i32,
    >,
    pub GetUint32ArrayElem: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            index: u32,
            value: *mut u32,
            def: u32,
        ) -> i32,
    >,
    pub GetUint32Array: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            value: *mut u32,
            len: u32,
            def: u32,
        ) -> i32,
    >,
    pub GetUint64: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            value: *mut u64,
            def: u64,
        ) -> i32,
    >,
    pub GetUint64ArrayElem: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            index: u32,
            value: *mut u64,
            def: u64,
        ) -> i32,
    >,
    pub GetUint64Array: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            value: *mut u64,
            len: u32,
            def: u64,
        ) -> i32,
    >,
    pub GetString: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            value: *mut *const ::core::ffi::c_char,
            def: *const ::core::ffi::c_char,
        ) -> i32,
    >,
    pub GetStringArrayElem: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
            index: u32,
            value: *mut *const ::core::ffi::c_char,
            def: *const ::core::ffi::c_char,
        ) -> i32,
    >,
    pub GetElemNum: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
        ) -> i32,
    >,
    pub GetNodeByMatchAttr: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrValue: *const ::core::ffi::c_char,
        ) -> *const DeviceResourceNode,
    >,
    pub GetChildNode: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            nodeName: *const ::core::ffi::c_char,
        ) -> *const DeviceResourceNode,
    >,
    pub GetNodeByRefAttr: ::core::option::Option<
        unsafe extern "C" fn(
            node: *const DeviceResourceNode,
            attrName: *const ::core::ffi::c_char,
        ) -> *const DeviceResourceNode,
    >,
}
pub const HDF_OBJECT_ID_DEVMGR_SERVICE: _bindgen_ty_4 = 0;
pub const HDF_OBJECT_ID_DEVSVC_MANAGER: _bindgen_ty_4 = 1;
pub const HDF_OBJECT_ID_DEVHOST_SERVICE: _bindgen_ty_4 = 2;
pub const HDF_OBJECT_ID_DRIVER_INSTALLER: _bindgen_ty_4 = 3;
pub const HDF_OBJECT_ID_DRIVER_LOADER: _bindgen_ty_4 = 4;
pub const HDF_OBJECT_ID_DEVICE: _bindgen_ty_4 = 5;
pub const HDF_OBJECT_ID_DEVICE_TOKEN: _bindgen_ty_4 = 6;
pub const HDF_OBJECT_ID_DEVICE_SERVICE: _bindgen_ty_4 = 7;
pub const HDF_OBJECT_ID_REMOTE_SERVICE: _bindgen_ty_4 = 8;
pub const HDF_OBJECT_ID_MAX: _bindgen_ty_4 = 9;
pub type _bindgen_ty_4 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HdfObjectCreator {
    pub Create: ::core::option::Option<unsafe extern "C" fn() -> *mut HdfObject>,
    pub Release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut HdfObject)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dl_namespace {
    pub name: [::core::ffi::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dl_info {
    pub dli_fname: *const ::core::ffi::c_char,
    pub dli_fbase: *mut ::core::ffi::c_void,
    pub dli_sname: *const ::core::ffi::c_char,
    pub dli_saddr: *mut ::core::ffi::c_void,
}
