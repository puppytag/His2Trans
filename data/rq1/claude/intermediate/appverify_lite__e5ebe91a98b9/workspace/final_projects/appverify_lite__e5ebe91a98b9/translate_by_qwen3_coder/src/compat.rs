//! Compatibility / Fallback Layer
//!
//! This module is auto-generated to keep the translated project compiling.
//!
//! Design goals:
//! - Centralize placeholders and shims in ONE place (easy to audit & remove later).
//! - Keep function bodies as close to translated semantics as possible.
//!
//! IMPORTANT:
//! - Items here may be placeholders (value/layout unknown). Always review before relying on semantics.

#![allow(dead_code)]
#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]

/// Minimal FFI prelude (for legacy skeletons that import `crate::compat::ffi::*`).
pub mod ffi {
    pub use core::ffi::*;
}

// === C2R_C2RUST_FALLBACK_MODS_BEGIN ===
// Auto-generated: C2Rust transpile fallback modules (used when LLM translation fails).
// NOTE: This is NOT truth-layer; it is a deterministic mechanical fallback.
#[path = "__c2r_generated/c2rust_fallback/mod.rs"]
pub mod __c2rust_fallback;
// === C2R_C2RUST_FALLBACK_MODS_END ===

// === C2R_COMPAT_PLACEHOLDERS_BEGIN ===
// (auto-appended placeholders will be inserted here)
// === C2R_COMPAT_PLACEHOLDERS_END ===

// === C2R_EXTERN_TYPES_BEGIN ===
// Auto-generated by C2R step 2.55 (bindgen allowlist extern prelude).
// Only includes missing type items required by extern decls below.
use crate::types::{off_t, timespec, uid_t};

pub type blkcnt_t = ::core::ffi::c_longlong;

pub type blksize_t = ::core::ffi::c_long;

pub type dev_t = ::core::ffi::c_ulonglong;

pub type gid_t = ::core::ffi::c_uint;

pub type ino_t = ::core::ffi::c_ulonglong;

pub type mode_t = ::core::ffi::c_uint;

pub type nlink_t = ::core::ffi::c_uint;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub __st_dev_padding: ::core::ffi::c_int,
    pub __st_ino_truncated: ::core::ffi::c_long,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub __st_rdev_padding: ::core::ffi::c_int,
    pub st_size: off_t,
    pub st_blksize: blksize_t,
    pub st_blocks: blkcnt_t,
    pub __st_atim32: stat__bindgen_ty_1,
    pub __st_mtim32: stat__bindgen_ty_1,
    pub __st_ctim32: stat__bindgen_ty_1,
    pub st_ino: ino_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat__bindgen_ty_1 {
    pub tv_sec: ::core::ffi::c_long,
    pub tv_nsec: ::core::ffi::c_long,
}

// === C2R_EXTERN_TYPES_END ===

// === C2R_EXTERN_VARS_BEGIN ===
// Auto-generated by C2R step 2.56 (bindgen allowlist vars/consts).
// Source: /data/home/wangshb/c2-rust_framework/translation_outputs/deepseek-coder-ohos5_reuseS1_topk1/intermediate/appverify_lite__e5ebe91a98b9/workspace/.preprocessed/*.i (preprocessed translation units)
// Details: /data/home/wangshb/c2-rust_framework/translation_outputs/deepseek-coder-ohos5_reuseS1_topk1/intermediate/appverify_lite__e5ebe91a98b9/workspace/repair_history/appverify_lite__e5ebe91a98b9/translate_by_qwen3_coder/_manual_fix/extern_vars_from_bindgen_allowlist.json
use crate::types::{ProductDiff, TrustAppCert, mbedtls_x509_crt};

pub const g_isActsMode: bool = false;

pub const g_isDebugMode: bool = false;

pub const g_memoryPageSize: i32 = 0;

#[allow(improper_ctypes)]
#[allow(non_snake_case)]
extern "C" {
    pub static mut g_debugModeEnabled: bool;
    pub static mut g_debugModeRootCert: crate::types::mbedtls_x509_crt;
    pub static mut g_ohosRootCert: crate::types::mbedtls_x509_crt;
    pub static mut g_productDiffFunc: crate::types::ProductDiff;
    pub static mut g_rootCaG2Cert: crate::types::mbedtls_x509_crt;
    pub static mut g_rootCertLoaded: bool;
    pub static g_trustAppList: [crate::types::TrustAppCert; 3usize];
    pub static g_trustAppListTest: [crate::types::TrustAppCert; 2usize];
}

// === C2R_EXTERN_VARS_END ===

// === C2R_EXTERN_DECLS_BEGIN ===
// Auto-generated extern decls (C2R step 2.55; bindgen allowlist).
// Source: /data/home/wangshb/c2-rust_framework/translation_outputs/deepseek-coder-ohos5_reuseS1_topk1/intermediate/appverify_lite__e5ebe91a98b9/workspace/.preprocessed/*.i (preprocessed translation units)
// Details: /data/home/wangshb/c2-rust_framework/translation_outputs/deepseek-coder-ohos5_reuseS1_topk1/intermediate/appverify_lite__e5ebe91a98b9/workspace/repair_history/appverify_lite__e5ebe91a98b9/translate_by_qwen3_coder/_manual_fix/extern_decls_from_bindgen_allowlist.json
#[allow(improper_ctypes)]
#[allow(non_snake_case)]
extern "C" {
    pub fn GetDevUdid(udid: *mut ::core::ffi::c_char, size: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn HiLogPrint(type_: crate::types::LogType, level: crate::types::LogLevel, domain: ::core::ffi::c_uint, tag: *const ::core::ffi::c_char, fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn cJSON_Delete(item: *mut crate::types::cJSON);
    pub fn cJSON_GetArrayItem(array: *const crate::types::cJSON, index: ::core::ffi::c_int) -> *mut crate::types::cJSON;
    pub fn cJSON_GetArraySize(array: *const crate::types::cJSON) -> ::core::ffi::c_int;
    pub fn cJSON_GetObjectItem(object: *const crate::types::cJSON, string: *const ::core::ffi::c_char) -> *mut crate::types::cJSON;
    pub fn cJSON_Parse(value: *const ::core::ffi::c_char) -> *mut crate::types::cJSON;
    pub fn calloc(arg1: crate::types::size_t, arg2: crate::types::size_t) -> *mut ::core::ffi::c_void;
    pub fn close(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn free(arg1: *mut ::core::ffi::c_void);
    pub fn fstat(arg1: ::core::ffi::c_int, arg2: *mut stat) -> ::core::ffi::c_int;
    pub fn islower(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn isupper(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn lseek(arg1: ::core::ffi::c_int, arg2: crate::types::off_t, arg3: ::core::ffi::c_int) -> crate::types::off_t;
    pub fn malloc(arg1: crate::types::size_t) -> *mut ::core::ffi::c_void;
    pub fn mbedtls_asn1_get_alg(p: *mut *mut ::core::ffi::c_uchar, end: *const ::core::ffi::c_uchar, alg: *mut crate::types::mbedtls_asn1_buf, params: *mut crate::types::mbedtls_asn1_buf) -> ::core::ffi::c_int;
    pub fn mbedtls_asn1_get_alg_null(p: *mut *mut ::core::ffi::c_uchar, end: *const ::core::ffi::c_uchar, alg: *mut crate::types::mbedtls_asn1_buf) -> ::core::ffi::c_int;
    pub fn mbedtls_asn1_get_int(p: *mut *mut ::core::ffi::c_uchar, end: *const ::core::ffi::c_uchar, val: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn mbedtls_asn1_get_tag(p: *mut *mut ::core::ffi::c_uchar, end: *const ::core::ffi::c_uchar, len: *mut crate::types::size_t, tag: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn mbedtls_base64_encode(dst: *mut ::core::ffi::c_uchar, dlen: crate::types::size_t, olen: *mut crate::types::size_t, src: *const ::core::ffi::c_uchar, slen: crate::types::size_t) -> ::core::ffi::c_int;
    pub fn mbedtls_calloc(n: crate::types::size_t, size: crate::types::size_t) -> *mut ::core::ffi::c_void;
    pub fn mbedtls_ecp_point_write_binary(grp: *const crate::types::mbedtls_ecp_group, P: *const crate::types::mbedtls_ecp_point, format: ::core::ffi::c_int, olen: *mut crate::types::size_t, buf: *mut ::core::ffi::c_uchar, buflen: crate::types::size_t) -> ::core::ffi::c_int;
    pub fn mbedtls_free(ptr: *mut ::core::ffi::c_void);
    pub fn mbedtls_md(md_info: *const crate::types::mbedtls_md_info_t, input: *const ::core::ffi::c_uchar, ilen: crate::types::size_t, output: *mut ::core::ffi::c_uchar) -> ::core::ffi::c_int;
    pub fn mbedtls_md_finish(ctx: *mut crate::types::mbedtls_md_context_t, output: *mut ::core::ffi::c_uchar) -> ::core::ffi::c_int;
    pub fn mbedtls_md_free(ctx: *mut crate::types::mbedtls_md_context_t);
    pub fn mbedtls_md_get_size(md_info: *const crate::types::mbedtls_md_info_t) -> ::core::ffi::c_uchar;
    pub fn mbedtls_md_info_from_type(md_type: crate::types::mbedtls_md_type_t) -> *const crate::types::mbedtls_md_info_t;
    pub fn mbedtls_md_init(ctx: *mut crate::types::mbedtls_md_context_t);
    pub fn mbedtls_md_setup(ctx: *mut crate::types::mbedtls_md_context_t, md_info: *const crate::types::mbedtls_md_info_t, hmac: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn mbedtls_md_starts(ctx: *mut crate::types::mbedtls_md_context_t) -> ::core::ffi::c_int;
    pub fn mbedtls_md_update(ctx: *mut crate::types::mbedtls_md_context_t, input: *const ::core::ffi::c_uchar, ilen: crate::types::size_t) -> ::core::ffi::c_int;
    pub fn mbedtls_pem_free(ctx: *mut crate::types::mbedtls_pem_context);
    pub fn mbedtls_pem_init(ctx: *mut crate::types::mbedtls_pem_context);
    pub fn mbedtls_pem_read_buffer(ctx: *mut crate::types::mbedtls_pem_context, header: *const ::core::ffi::c_char, footer: *const ::core::ffi::c_char, data: *const ::core::ffi::c_uchar, pwd: *const ::core::ffi::c_uchar, pwdlen: crate::types::size_t, use_len: *mut crate::types::size_t) -> ::core::ffi::c_int;
    pub fn mbedtls_pk_get_type(ctx: *const crate::types::mbedtls_pk_context) -> crate::types::mbedtls_pk_type_t;
    pub fn mbedtls_pk_verify(ctx: *mut crate::types::mbedtls_pk_context, md_alg: crate::types::mbedtls_md_type_t, hash: *const ::core::ffi::c_uchar, hash_len: crate::types::size_t, sig: *const ::core::ffi::c_uchar, sig_len: crate::types::size_t) -> ::core::ffi::c_int;
    pub fn mbedtls_pk_write_pubkey(p: *mut *mut ::core::ffi::c_uchar, start: *mut ::core::ffi::c_uchar, key: *const crate::types::mbedtls_pk_context) -> ::core::ffi::c_int;
    pub fn mbedtls_rsa_set_padding(ctx: *mut crate::types::mbedtls_rsa_context, padding: ::core::ffi::c_int, hash_id: crate::types::mbedtls_md_type_t) -> ::core::ffi::c_int;
    pub fn mbedtls_x509_crl_free(crl: *mut crate::types::mbedtls_x509_crl);
    pub fn mbedtls_x509_crl_init(crl: *mut crate::types::mbedtls_x509_crl);
    pub fn mbedtls_x509_crl_parse(chain: *mut crate::types::mbedtls_x509_crl, buf: *const ::core::ffi::c_uchar, buflen: crate::types::size_t) -> ::core::ffi::c_int;
    pub fn mbedtls_x509_crt_free(crt: *mut crate::types::mbedtls_x509_crt);
    pub fn mbedtls_x509_crt_init(crt: *mut crate::types::mbedtls_x509_crt);
    pub fn mbedtls_x509_crt_parse(chain: *mut crate::types::mbedtls_x509_crt, buf: *const ::core::ffi::c_uchar, buflen: crate::types::size_t) -> ::core::ffi::c_int;
    pub fn mbedtls_x509_crt_verify(crt: *mut crate::types::mbedtls_x509_crt, trust_ca: *mut crate::types::mbedtls_x509_crt, ca_crl: *mut crate::types::mbedtls_x509_crl, cn: *const ::core::ffi::c_char, flags: *mut u32, f_vrfy: ::core::option::Option< unsafe extern "C" fn( arg1: *mut ::core::ffi::c_void, arg2: *mut crate::types::mbedtls_x509_crt, arg3: ::core::ffi::c_int, arg4: *mut u32, ) -> ::core::ffi::c_int, >, p_vrfy: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn mbedtls_x509_crt_verify_info(buf: *mut ::core::ffi::c_char, size: crate::types::size_t, prefix: *const ::core::ffi::c_char, flags: u32) -> ::core::ffi::c_int;
    pub fn mbedtls_x509_dn_gets(buf: *mut ::core::ffi::c_char, size: crate::types::size_t, dn: *const crate::types::mbedtls_x509_name) -> ::core::ffi::c_int;
    pub fn memcmp(arg1: *const ::core::ffi::c_void, arg2: *const ::core::ffi::c_void, arg3: crate::types::size_t) -> ::core::ffi::c_int;
    pub fn memcpy_s(dest: *mut ::core::ffi::c_void, destMax: crate::types::size_t, src: *const ::core::ffi::c_void, count: crate::types::size_t) -> crate::types::errno_t;
    pub fn memset_s(dest: *mut ::core::ffi::c_void, destMax: crate::types::size_t, c: ::core::ffi::c_int, count: crate::types::size_t) -> crate::types::errno_t;
    pub fn mmap(arg1: *mut ::core::ffi::c_void, arg2: crate::types::size_t, arg3: ::core::ffi::c_int, arg4: ::core::ffi::c_int, arg5: ::core::ffi::c_int, arg6: crate::types::off_t) -> *mut ::core::ffi::c_void;
    pub fn munmap(arg1: *mut ::core::ffi::c_void, arg2: crate::types::size_t) -> ::core::ffi::c_int;
    pub fn open(arg1: *const ::core::ffi::c_char, arg2: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
    pub fn read(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_void, arg3: crate::types::size_t) -> crate::types::ssize_t;
    pub fn realpath(arg1: *const ::core::ffi::c_char, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn snprintf_s(strDest: *mut ::core::ffi::c_char, destMax: crate::types::size_t, count: crate::types::size_t, format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn strchr(arg1: *const ::core::ffi::c_char, arg2: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
    pub fn strcmp(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn strcpy_s(strDest: *mut ::core::ffi::c_char, destMax: crate::types::size_t, strSrc: *const ::core::ffi::c_char) -> crate::types::errno_t;
    pub fn strlen(arg1: *const ::core::ffi::c_char) -> crate::types::size_t;
    pub fn strncpy_s(strDest: *mut ::core::ffi::c_char, destMax: crate::types::size_t, strSrc: *const ::core::ffi::c_char, count: crate::types::size_t) -> crate::types::errno_t;
    pub fn strstr(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn sysconf(arg1: ::core::ffi::c_int) -> ::core::ffi::c_long;
}
// === C2R_EXTERN_DECLS_END ===

// === C2R_ACCESSOR_SHIMS_BEGIN ===
// (auto-appended accessor shim declarations will be inserted here)
// === C2R_ACCESSOR_SHIMS_END ===
