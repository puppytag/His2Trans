{
  "project": "shared__541f4e547bdb",
  "func_key": "src_svcmgr_ioservice_4",
  "function_name": "SvcMgrIoserviceRegSvcStatListener",
  "source_c_file": "src/svcmgr_ioservice.c",
  "c_code": "int32_t SvcMgrIoserviceRegSvcStatListener(struct ISvcMgrIoservice * self, struct ServiceStatusListener * listener, uint16_t deviceClass)\n{\n    if (self == NULL || listener == NULL || deviceClass >= DEVICE_CLASS_MAX) {\n        return HDF_ERR_INVALID_PARAM;\n    }\n\n    struct SvcMgrIoservice *svcmgrInst = CONTAINER_OF(self, struct SvcMgrIoservice, svcmgr);\n    struct IoServiceStatusListener *listenerInst\n        = CONTAINER_OF(listener, struct IoServiceStatusListener, svcstatListener);\n\n    listenerInst->deviceClass = deviceClass;\n    int ret = SetListenClass(svcmgrInst, deviceClass);\n    if (ret != HDF_SUCCESS) {\n        HDF_LOGE(\"failed to set listen class\");\n        return ret;\n    }\n\n    return HdfDeviceRegisterEventListener(svcmgrInst->iosvc, &listenerInst->ioservListener);\n}",
  "rust_signature": "pub extern \"C\" fn SvcMgrIoserviceRegSvcStatListener(self_: *mut crate::types::ISvcMgrIoservice, listener: *mut crate::types::ServiceStatusListener, deviceClass: u16) -> i32",
  "rust_code": "pub extern \\\"C\\\" fn SvcMgrIoserviceRegSvcStatListener(self_: *mut ISvcMgrIoservice, listener: *mut ServiceStatusListener, deviceClass: u16) -> i32 {\n    if self_.is_null() || listener.is_null() || (deviceClass as u32) >= DEVICE_CLASS_MAX {\n        return HDF_ERR_INVALID_PARAM;\n    }\n    unsafe {\n        let svcmgrInst = (self_ as *mut u8).offset(-(core::mem::offset_of!(SvcMgrIoservice, svcmgr) as isize)) as *mut SvcMgrIoservice;\n        let listenerInst = (listener as *mut u8).offset(-(core::mem::offset_of!(IoServiceStatusListener, svcstatListener) as isize)) as *mut IoServiceStatusListener;\n\n        (*listenerInst).deviceClass = deviceClass;\n        let ret = SetListenClass(svcmgrInst, deviceClass);\n        if ret != HDF_SUCCESS {\n            return ret;\n        }\n        HdfDeviceRegisterEventListener((*svcmgrInst).iosvc, core::ptr::addr_of_mut!((*listenerInst).ioservListener))\n    }\n}\n",
  "extracted_knowledge": [
    {
      "knowledge_type": "API_Mapping",
      "c_api": "HdfDeviceRegisterEventListener",
      "rust_api": "HdfDeviceRegisterEventListener",
      "description": "Register device event listener",
      "mapping_type": "",
      "source": "oracle_manual"
    },
    {
      "knowledge_type": "Partial",
      "c_fragment": "if (ptr == NULL) { ... }",
      "rust_fragment": "if ptr.is_null() { ... }",
      "description": "Translate C NULL checks to Rust `is_null()` checks",
      "match_type": "partial",
      "source": "oracle_manual"
    },
    {
      "knowledge_type": "Partial",
      "c_fragment": "CONTAINER_OF(p, T, field)",
      "rust_fragment": "(p as *mut u8).offset(-(offset_of!(T, field) as isize)) as *mut T",
      "description": "Implement container_of via `offset_of!` + pointer arithmetic",
      "match_type": "partial",
      "source": "oracle_manual"
    }
  ]
}
