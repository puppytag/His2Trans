C_Code: 
static size_t
leb128_len (const unsigned char *p)
{
  size_t ret;

  ret = 1;
  while ((*p & 0x80) != 0)
    {
      ++p;
      ++ret;
    }
  return ret;
}
Function: 
pub unsafe fn read_sleb128(&mut self) -> i64 {
        let mut shift: u32 = 0;
        let mut result: u64 = 0;
        let mut byte: u8;
        loop {
            byte = unsafe { self.read::<u8>() };
            result |= ((byte & 0x7F) as u64) << shift;
            shift += 7;
            if byte & 0x80 == 0 {
                break;
            }
        }
        // sign-extend
        if shift < u64::BITS && (byte & 0x40) != 0 {
            result |= (!0 as u64) << shift;
        }
        result as i64
    }
Unixcoder Score: 0.012738311663269997
--------------------------------------------------
C_Code: 
static size_t
leb128_len (const unsigned char *p)
{
  size_t ret;

  ret = 1;
  while ((*p & 0x80) != 0)
    {
      ++p;
      ++ret;
    }
  return ret;
}
Function: 
pub unsafe fn read_uleb128(&mut self) -> u64 {
        let mut shift: usize = 0;
        let mut result: u64 = 0;
        let mut byte: u8;
        loop {
            byte = unsafe { self.read::<u8>() };
            result |= ((byte & 0x7F) as u64) << shift;
            shift += 7;
            if byte & 0x80 == 0 {
                break;
            }
        }
        result
    }
Unixcoder Score: -0.00206824392080307
--------------------------------------------------
C_Code: 
static size_t
leb128_len (const unsigned char *p)
{
  size_t ret;

  ret = 1;
  while ((*p & 0x80) != 0)
    {
      ++p;
      ++ret;
    }
  return ret;
}
Function: 
pub unsafe fn read_sleb128(&mut self) -> i64 {
        let mut shift: u32 = 0;
        let mut result: u64 = 0;
        let mut byte: u8;
        loop {
            byte = self.read::<u8>();
            result |= ((byte & 0x7F) as u64) << shift;
            shift += 7;
            if byte & 0x80 == 0 {
                break;
            }
        }
        // sign-extend
        if shift < u64::BITS && (byte & 0x40) != 0 {
            result |= (!0 as u64) << shift;
        }
        result as i64
    }
Unixcoder Score: -0.003684045048430562
--------------------------------------------------
C_Code: 
rust::string GetCallingBundle(rust::u64 tokenId)
{
    auto tokenType = AccessTokenKit::GetTokenTypeFlag(static_cast<uint32_t>(tokenId));
    if (tokenType != TOKEN_HAP) {
        REQUEST_HILOGE("invalid token");
        return rust::string("");
    }
    HapTokenInfo info;
    int ret = AccessTokenKit::GetHapTokenInfo(tokenId, info);
    if (ret != 0) {
        REQUEST_HILOGE("failed to get hap info, ret: %{public}d", ret);
        return rust::string("");
    }
    return rust::string(info.bundleName);
}
Function: 
pub(crate) fn update_accounts(
        &mut self,
        foreground_account: u64,
        active_accounts: HashSet<u64>,
    ) -> Option<SqlList> {
        if self.active_accounts == active_accounts {
            return None;
        }
        info!("update active accounts {:?}", active_accounts);
        let mut sql_list = SqlList::new();
        sql_list.add_account_change(&active_accounts);
        self.active_accounts = active_accounts;
        self.top_user = foreground_account;
        Some(sql_list)
    }
Unixcoder Score: -0.005430575925856829
--------------------------------------------------
C_Code: 
static size_t
leb128_len (const unsigned char *p)
{
  size_t ret;

  ret = 1;
  while ((*p & 0x80) != 0)
    {
      ++p;
      ++ret;
    }
  return ret;
}
Function: 
pub unsafe fn read_uleb128(&mut self) -> u64 {
        let mut shift: usize = 0;
        let mut result: u64 = 0;
        let mut byte: u8;
        loop {
            byte = self.read::<u8>();
            result |= ((byte & 0x7F) as u64) << shift;
            shift += 7;
            if byte & 0x80 == 0 {
                break;
            }
        }
        result
    }
Unixcoder Score: -0.007306694984436035
--------------------------------------------------
C_Code: 
rust::string GetCallingBundle(rust::u64 tokenId)
{
    auto tokenType = AccessTokenKit::GetTokenTypeFlag(static_cast<uint32_t>(tokenId));
    if (tokenType != TOKEN_HAP) {
        REQUEST_HILOGE("invalid token");
        return rust::string("");
    }
    HapTokenInfo info;
    int ret = AccessTokenKit::GetHapTokenInfo(tokenId, info);
    if (ret != 0) {
        REQUEST_HILOGE("failed to get hap info, ret: %{public}d", ret);
        return rust::string("");
    }
    return rust::string(info.bundleName);
}
Function: 
pub(crate) fn query_calling_bundle() -> String {
    let token_id = ipc::Skeleton::calling_full_token_id();
    ffi::GetCallingBundle(token_id)
}
Unixcoder Score: -0.008924021385610104
--------------------------------------------------
C_Code: 
rust::string GetCallingBundle(rust::u64 tokenId)
{
    auto tokenType = AccessTokenKit::GetTokenTypeFlag(static_cast<uint32_t>(tokenId));
    if (tokenType != TOKEN_HAP) {
        REQUEST_HILOGE("invalid token");
        return rust::string("");
    }
    HapTokenInfo info;
    int ret = AccessTokenKit::GetHapTokenInfo(tokenId, info);
    if (ret != 0) {
        REQUEST_HILOGE("failed to get hap info, ret: %{public}d", ret);
        return rust::string("");
    }
    return rust::string(info.bundleName);
}
Function: 
pub(crate) fn query_calling_bundle() -> String {
    let token_id = ipc::Skeleton::calling_full_token_id();
    ffi::GetCallingBundle(token_id)
}
Unixcoder Score: -0.01007071789354086
--------------------------------------------------
C_Code: 
void HandleAppRestore(const OHOS::AAFwk::Want &want, OnAppRestore onAppRestore)
{
    if (onAppRestore != nullptr) {
        int userId = want.GetIntParam(USER_ID, INVALID_USERID);
        std::string bundleName = want.GetStringParam(BUNDLE_NAME);

        int appIndex = want.GetIntParam(SANDBOX_APP_INDEX, -1);
        if (appIndex == -1) {
            LOGI("[INFO]Get app restore info failed, default as index 0.");
            appIndex = 0;
        }

        onAppRestore(userId, reinterpret_cast<const uint8_t *>(bundleName.c_str()), appIndex);
        LOGI("[INFO]Receive event: RESTORE_START.");
    }
}
Function: 
pub(crate) fn subscribe() {
    unsafe {
        let call_back = EventCallBack {
            on_package_removed,
            on_user_removed,
            on_screen_off: delete_crypto_need_unlock,
            on_charging: backup_db,
            on_app_restore,
            on_user_unlocked,
            on_connectivity_change,
        };
        if SubscribeSystemEvent(call_back.clone()) {
            logi!("Subscribe system event success.");
        } else {
            loge!("Subscribe system event failed. Subscribe System Ability wait system event service start.");
            if SubscribeSystemAbility(call_back) {
                logi!("Subscribe system ability success.");
            } else {
                loge!("Subscribe system ability failed.")
            }
        }
    }
}
Unixcoder Score: -0.01337437890470028
--------------------------------------------------
C_Code: 
std::pair<int32_t, SchemaMeta> CloudServiceImpl::GetAppSchemaFromServer(int32_t user, const std::string &bundleName)
{
    SchemaMeta schemaMeta;
    if (!NetworkDelegate::GetInstance()->IsNetworkAvailable()) {
        ZLOGD("network is not available");
        return { NETWORK_ERROR, schemaMeta };
    }
    auto instance = CloudServer::GetInstance();
    if (instance == nullptr) {
        return { SERVER_UNAVAILABLE, schemaMeta };
    }
    int32_t status = E_OK;
    std::tie(status, schemaMeta) = instance->GetAppSchema(user, bundleName);
    if (status != E_OK || !schemaMeta.IsValid()) {
        ZLOGE("schema is InValid, user:%{public}d, bundleName:%{public}s, status:%{public}d", user, bundleName.c_str(),
            status);
        return { status == E_NOT_SUPPORT ? NOT_SUPPORT : SCHEMA_INVALID, schemaMeta };
    }
    return { SUCCESS, schemaMeta };
}
Function: 
pub(crate) fn get_app_brief_info(
        &mut self,
        user_id: i32,
    ) -> ConnectResult<RwLockReadGuard<AppInfos>> {
        self.infos.entry(user_id).or_default();
        let infos = self.infos.get_mut(&user_id).unwrap();

        let mut lock = infos.app_infos.write().unwrap();

        let mut msg_parcel = MsgParcel::new();

        let function_number = GetAppBriefInfo as u32;
        let remote_obj = self
            .remote_obj
            .as_ref()
            .ok_or(Error::GetProxyObjectFailed)?;
        let mut receive = remote_obj
            .send_request(function_number, &mut msg_parcel)
            .map_err(|_| Error::SendRequestFailed)?;

        lock.0 = receive
            .read::<AppInfos>()
            .map_err(|_| Error::ReadMsgParcelFailed)?
            .0;

        drop(lock);

        Ok(infos.app_infos.read().unwrap())
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandleAppRestore__idx4483_rank4.c", "source_rust_file": "API_Mapping__HandleAppRestore__idx4483_rank4.rs", "c_api": "want.GetIntParam(USER_ID, INVALID_USERID)", "rust_api": "user_id: i32", "mapping_type": "function", "description": "Extract integer parameter from Want object", "reasoning": "[Task Analysis] C function handles app restore logic with parameter extraction and callback invocation; Rust function constructs calling info with complex data processing and FFI calls. [Similarity] Names refer to different concepts (HandleAppRestore vs construct_calling_infos), domains differ (app lifecycle vs calling info construction), and code lengths are significantly different (>3x). [Knowledge Extraction] No full structural match due to domain mismatch and length difference. No partial match due to lack of aligned code blocks. API mappings found: Want parameter access (GetIntParam, GetStringParam) ↔ Vec<u8> construction, callback invocation ↔ FFI call GetUninstallGroups, logging ↔ loge! macro."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandleAppRestore__idx4483_rank4.c", "source_rust_file": "API_Mapping__HandleAppRestore__idx4483_rank4.rs", "c_api": "LOGI(...)", "rust_api": "loge!(...)", "mapping_type": "function", "description": "Logging macro for info/fatal messages", "reasoning": "[Task Analysis] C function handles app restore logic with parameter extraction and callback invocation; Rust function constructs calling info with complex data processing and FFI calls. [Similarity] Names refer to different concepts (HandleAppRestore vs construct_calling_infos), domains differ (app lifecycle vs calling info construction), and code lengths are significantly different (>3x). [Knowledge Extraction] No full structural match due to domain mismatch and length difference. No partial match due to lack of aligned code blocks. API mappings found: Want parameter access (GetIntParam, GetStringParam) ↔ Vec<u8> construction, callback invocation ↔ FFI call GetUninstallGroups, logging ↔ loge! macro."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandleAppRestore__idx4483_rank4.c", "source_rust_file": "API_Mapping__HandleAppRestore__idx4483_rank4.rs", "c_api": "onAppRestore(userId, reinterpret_cast<const uint8_t *>(bundleName.c_str()), appIndex)", "rust_api": "GetUninstallGroups(user_id, &developer_id, &mut the_group_ids)", "mapping_type": "function", "description": "Invoke callback function with parameters (C) vs FFI call with parameters (Rust)", "reasoning": "[Task Analysis] C function handles app restore logic with parameter extraction and callback invocation; Rust function constructs calling info with complex data processing and FFI calls. [Similarity] Names refer to different concepts (HandleAppRestore vs construct_calling_infos), domains differ (app lifecycle vs calling info construction), and code lengths are significantly different (>3x). [Knowledge Extraction] No full structural match due to domain mismatch and length difference. No partial match due to lack of aligned code blocks. API mappings found: Want parameter access (GetIntParam, GetStringParam) ↔ Vec<u8> construction, callback invocation ↔ FFI call GetUninstallGroups, logging ↔ loge! macro."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandleAppRestore__idx4483_rank4.c", "source_rust_file": "API_Mapping__HandleAppRestore__idx4483_rank4.rs", "c_api": "want.GetStringParam(BUNDLE_NAME)", "rust_api": "owner: Vec<u8>", "mapping_type": "function", "description": "Extract string parameter from Want object and convert to byte vector", "reasoning": "[Task Analysis] C function handles app restore logic with parameter extraction and callback invocation; Rust function constructs calling info with complex data processing and FFI calls. [Similarity] Names refer to different concepts (HandleAppRestore vs construct_calling_infos), domains differ (app lifecycle vs calling info construction), and code lengths are significantly different (>3x). [Knowledge Extraction] No full structural match due to domain mismatch and length difference. No partial match due to lack of aligned code blocks. API mappings found: Want parameter access (GetIntParam, GetStringParam) ↔ Vec<u8> construction, callback invocation ↔ FFI call GetUninstallGroups, logging ↔ loge! macro."}]
Unixcoder Score: -0.02038443088531494
--------------------------------------------------
C_Code: 
ExceptionErrorCode RequestServiceProxy::QueryTasks(const std::vector<std::string> &tids, std::vector<TaskInfoRet> &rets)
{
    TaskInfoRet infoRet{ .code = ExceptionErrorCode::E_OTHER };
    uint32_t len = static_cast<uint32_t>(tids.size());
    rets.resize(len, infoRet);
    MessageParcel data;
    MessageParcel reply;
    MessageOption option;
    data.WriteInterfaceToken(RequestServiceProxy::GetDescriptor());
    data.WriteUint32(len);
    for (const std::string &tid : tids) {
        data.WriteString(tid);
    }
    int32_t ret = Remote()->SendRequest(static_cast<uint32_t>(RequestInterfaceCode::CMD_QUERY), data, reply, option);
    if (ret != ERR_NONE) {
        REQUEST_HILOGE("End Request QueryTasks, failed: %{public}d", ret);
        if (ret != REMOTE_DIED_ERROR) {
            SysEventLog::SendSysEventLog(FAULT_EVENT, IPC_FAULT_00, std::to_string(ret));
        }
        return ExceptionErrorCode::E_SERVICE_ERROR;
    }
    ExceptionErrorCode code = static_cast<ExceptionErrorCode>(reply.ReadInt32());
    if (code != ExceptionErrorCode::E_OK) {
        REQUEST_HILOGE("End Request QueryTasks, failed: %{public}d", code);
        SysEventLog::SendSysEventLog(FAULT_EVENT, IPC_FAULT_01, std::to_string(code));
        return code;
    }
    for (uint32_t i = 0; i < len; i++) {
        rets[i].code = static_cast<ExceptionErrorCode>(reply.ReadInt32());
        TaskInfo info;
        ParcelHelper::UnMarshal(reply, info);
        rets[i].info = info;
    }
    return ExceptionErrorCode::E_OK;
}
Function: 
pub(crate) fn show(&self, data: &mut MsgParcel, reply: &mut MsgParcel) -> IpcResult<()> {
        debug!("Service show");
        let permission = PermissionChecker::check_down_permission();
        let len: u32 = data.read()?;
        let len = len as usize;

        if len > GET_INFO_MAX {
            info!("Service show: out of size: {}", len);
            reply.write(&(ErrorCode::Other as i32))?;
            return Err(IpcStatusCode::Failed);
        }

        let ipc_uid = ipc::Skeleton::calling_uid();
        let mut vec = vec![(ErrorCode::Other, TaskInfo::new()); len];
        for i in 0..len {
            let task_id: String = data.read()?;
            info!("Service show tid {}", task_id);

            let Ok(task_id) = task_id.parse::<u32>() else {
                error!("Service show, failed: tid not valid: {}", task_id);
                sys_event!(
                    ExecError,
                    DfxCode::INVALID_IPC_MESSAGE_A18,
                    &format!("Service show, failed: tid not valid: {}", task_id)
                );
                set_code_with_index_other(&mut vec, i, ErrorCode::TaskNotFound);
                continue;
            };

            let task_uid = match RequestDb::get_instance().query_task_uid(task_id) {
                Some(uid) => uid,
                None => {
                    set_code_with_index_other(&mut vec, i, ErrorCode::TaskNotFound);
                    continue;
                }
            };

            if !check_current_account(task_uid) {
                set_code_with_index_other(&mut vec, i, ErrorCode::TaskNotFound);
                continue;
            }

            if (task_uid != ipc_uid) && !permission {
                set_code_with_index_other(&mut vec, i, ErrorCode::TaskNotFound);
                error!(
                    "Service show, failed: check task uid. tid: {}, uid: {}",
                    task_id, ipc_uid
                );
                sys_event!(
                    ExecError,
                    DfxCode::INVALID_IPC_MESSAGE_A18,
                    &format!(
                        "Service show, failed: check task uid. tid: {}, uid: {}",
                        task_id, ipc_uid
                    )
                );
                continue;
            }

            let info = self.task_manager.lock().unwrap().show(task_uid, task_id);
            match info {
                Some(task_info) => {
                    if let Some((c, info)) = vec.get_mut(i) {
                        *c = ErrorCode::ErrOk;
                        *info = task_info;
                    }
                }
                None => {
                    error!("Service show, failed: task_id not found, tid: {}", task_id);
                    sys_event!(
                        ExecError,
                        DfxCode::INVALID_IPC_MESSAGE_A18,
                        &format!("Service show, failed: task_id not found, tid: {}", task_id)
                    );
                    set_code_with_index_other(&mut vec, i, ErrorCode::TaskNotFound);
                }
            };
        }
        reply.write(&(ErrorCode::ErrOk as i32))?;
        for (c, info) in vec {
            reply.write(&(c as i32))?;
            // TODO: Sends info only when ErrOk.
            serialize_task_info(info, reply)?;
        }
        Ok(())
    }
Unixcoder Score: -0.025432685390114784
--------------------------------------------------
