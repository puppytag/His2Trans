C_Code: 
struct CertInfo
Function: 
struct CertInfo {
    cert: Option<Vec<Certificate>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx358_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx358_rank5.rs", "c_api": "if (!WriteUpdateData(insertValues, taskInfo)) {\n        return false;\n    }", "rust_api": "let Some(file) = self.files.get(index) else {\n            error!(\"task {} file {} not found\", self.task_id(), index);\n            return false;\n        };", "mapping_type": "pattern", "description": "Conditional check with early return on failure", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles file upload logic with async operations and error handling. [Similarity] No structural similarity at the function level due to different domains (data insertion vs file I/O). [Knowledge Extraction] No full match, no partial match, but there are API mappings related to error handling and conditional logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx358_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx358_rank5.rs", "c_api": "return true;", "rust_api": ".is_ok()", "mapping_type": "pattern", "description": "Successful operation indicator", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles file upload logic with async operations and error handling. [Similarity] No structural similarity at the function level due to different domains (data insertion vs file I/O). [Knowledge Extraction] No full match, no partial match, but there are API mappings related to error handling and conditional logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx358_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx358_rank5.rs", "c_api": "return false;", "rust_api": "return false;", "mapping_type": "pattern", "description": "Early return on error condition", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles file upload logic with async operations and error handling. [Similarity] No structural similarity at the function level due to different domains (data insertion vs file I/O). [Knowledge Extraction] No full match, no partial match, but there are API mappings related to error handling and conditional logic patterns."}]
Unixcoder Score: 0.2651605010032654
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
struct CertInfo {
    cert: Option<Vec<Certificate>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__CTaskConfig__idx16_rank2.h", "source_rust_file": "Partial__CTaskConfig__idx16_rank2.rs", "c_fragment": "struct CTaskConfig {", "rust_fragment": "pub struct ConfigBuilder {", "description": "Both define a data structure for task configuration, though Rust uses a builder pattern.", "reasoning": "[Task Analysis] C struct defines a task configuration with various fields including strings, pointers to arrays, and nested structs; Rust struct is a builder pattern for TaskConfig. [Similarity] Names do not match exactly but refer to same concept (configuring a task). Both represent data structures with similar fields (strings, arrays, nested data). [Knowledge Extraction] Found partial structural match in field definitions and API mapping for builder pattern usage."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__CTaskConfig__idx16_rank2.h", "source_rust_file": "Partial__CTaskConfig__idx16_rank2.rs", "c_api": "CTaskConfig", "rust_api": "ConfigBuilder", "mapping_type": "type", "description": "Both represent a configuration structure for task data, with Rust using a builder pattern.", "reasoning": "[Task Analysis] C struct defines a task configuration with various fields including strings, pointers to arrays, and nested structs; Rust struct is a builder pattern for TaskConfig. [Similarity] Names do not match exactly but refer to same concept (configuring a task). Both represent data structures with similar fields (strings, arrays, nested data). [Knowledge Extraction] Found partial structural match in field definitions and API mapping for builder pattern usage."}]
Unixcoder Score: 0.23941496014595032
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
pub(crate) struct CertManager {
    info: Arc<RwLock<CertInfo>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx464_rank4.c", "source_rust_file": "Partial__WriteMutableData__idx464_rank4.rs", "c_api": "insertValues.PutInt", "rust_api": "task_info.build_info_set", "mapping_type": "function", "description": "Data insertion into a container (C) vs building an info set (Rust)", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function inserts a task into a database with similar intent but different abstraction. [Similarity] Names don't match exactly but both perform data insertion logic; C uses a ValuesBucket, Rust uses a database insert. [Knowledge Extraction] Found partial structural match in data insertion logic and API mappings for database operations and task handling."}, {"knowledge_type": "Partial", "source_c_file": "Partial__WriteMutableData__idx464_rank4.c", "source_rust_file": "Partial__WriteMutableData__idx464_rank4.rs", "c_fragment": "if (!WriteUpdateData(insertValues, taskInfo)) {\n        return false;\n    }", "rust_fragment": "if !unsafe { RecordRequestTask(&c_task_info, &c_task_config) } {\n            info!(\"task {} insert database fail\", task_id);\n        }", "description": "Both functions check for success of data insertion and return false on failure.", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function inserts a task into a database with similar intent but different abstraction. [Similarity] Names don't match exactly but both perform data insertion logic; C uses a ValuesBucket, Rust uses a database insert. [Knowledge Extraction] Found partial structural match in data insertion logic and API mappings for database operations and task handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx464_rank4.c", "source_rust_file": "Partial__WriteMutableData__idx464_rank4.rs", "c_api": "WriteUpdateData", "rust_api": "RecordRequestTask", "mapping_type": "function", "description": "Database update/write operation (C) vs FFI call to record task (Rust)", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function inserts a task into a database with similar intent but different abstraction. [Similarity] Names don't match exactly but both perform data insertion logic; C uses a ValuesBucket, Rust uses a database insert. [Knowledge Extraction] Found partial structural match in data insertion logic and API mappings for database operations and task handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx464_rank4.c", "source_rust_file": "Partial__WriteMutableData__idx464_rank4.rs", "c_api": "insertValues.PutBlob", "rust_api": "task_config.to_c_struct", "mapping_type": "function", "description": "Blob insertion (C) vs converting to C struct (Rust)", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function inserts a task into a database with similar intent but different abstraction. [Similarity] Names don't match exactly but both perform data insertion logic; C uses a ValuesBucket, Rust uses a database insert. [Knowledge Extraction] Found partial structural match in data insertion logic and API mappings for database operations and task handling."}, {"knowledge_type": "Partial", "source_c_file": "Partial__WriteMutableData__idx464_rank4.c", "source_rust_file": "Partial__WriteMutableData__idx464_rank4.rs", "c_fragment": "insertValues.PutLong(\"mtime\", taskInfo->commonData.mtime);\n    insertValues.PutInt(\"reason\", taskInfo->commonData.reason);\n    insertValues.PutLong(\"tries\", taskInfo->commonData.tries);", "rust_fragment": "let task_config = task.config();\n        let config_set = task_config.build_config_set();\n        let c_task_config = task_config.to_c_struct(task_id, uid, &config_set);\n\n        let task_info = &task.info();\n        let info_set = task_info.build_info_set();\n        let c_task_info = task_info.to_c_struct(&info_set);", "description": "Both functions prepare data structures for insertion into a database-like system, with C using Put* methods and Rust building C-compatible structs.", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function inserts a task into a database with similar intent but different abstraction. [Similarity] Names don't match exactly but both perform data insertion logic; C uses a ValuesBucket, Rust uses a database insert. [Knowledge Extraction] Found partial structural match in data insertion logic and API mappings for database operations and task handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx464_rank4.c", "source_rust_file": "Partial__WriteMutableData__idx464_rank4.rs", "c_api": "insertValues.PutLong", "rust_api": "task_config.build_config_set", "mapping_type": "function", "description": "Data insertion into a container (C) vs building a configuration set (Rust)", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function inserts a task into a database with similar intent but different abstraction. [Similarity] Names don't match exactly but both perform data insertion logic; C uses a ValuesBucket, Rust uses a database insert. [Knowledge Extraction] Found partial structural match in data insertion logic and API mappings for database operations and task handling."}]
Unixcoder Score: 0.22661219537258148
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
pub(crate) struct CertManager {
    info: Arc<RwLock<CertInfo>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx361_rank1.c", "source_rust_file": "Partial__WriteMutableData__idx361_rank1.rs", "c_api": "return false;", "rust_api": "return Err(TaskError::Failed(Reason::OthersError));", "mapping_type": "pattern", "description": "Early return on failure in C vs returning an error in Rust", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles async upload logic with file processing and error handling. [Similarity] Names don't match (WriteMutableData vs upload_inner), and domains are different (data insertion vs file upload). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and control flow, and some API mappings related to data insertion and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx361_rank1.c", "source_rust_file": "Partial__WriteMutableData__idx361_rank1.rs", "c_api": "insertValues.PutInt", "rust_api": "task.conf.common_data.multipart", "mapping_type": "function", "description": "Data insertion into a container (C) vs checking a boolean flag (Rust)", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles async upload logic with file processing and error handling. [Similarity] Names don't match (WriteMutableData vs upload_inner), and domains are different (data insertion vs file upload). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and control flow, and some API mappings related to data insertion and error handling."}, {"knowledge_type": "Partial", "source_c_file": "Partial__WriteMutableData__idx361_rank1.c", "source_rust_file": "Partial__WriteMutableData__idx361_rank1.rs", "c_fragment": "return true;", "rust_fragment": "Ok(())", "description": "Both represent successful completion of a function.", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles async upload logic with file processing and error handling. [Similarity] Names don't match (WriteMutableData vs upload_inner), and domains are different (data insertion vs file upload). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and control flow, and some API mappings related to data insertion and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx361_rank1.c", "source_rust_file": "Partial__WriteMutableData__idx361_rank1.rs", "c_api": "insertValues.PutLong", "rust_api": "task.conf.file_specs.len()", "mapping_type": "function", "description": "Data insertion into a container (C) vs accessing length of a collection (Rust)", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles async upload logic with file processing and error handling. [Similarity] Names don't match (WriteMutableData vs upload_inner), and domains are different (data insertion vs file upload). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and control flow, and some API mappings related to data insertion and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx361_rank1.c", "source_rust_file": "Partial__WriteMutableData__idx361_rank1.rs", "c_api": "WriteUpdateData", "rust_api": "task.prepare_batch_upload", "mapping_type": "function", "description": "Updating data in a database-like structure (C) vs preparing batch upload (Rust)", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles async upload logic with file processing and error handling. [Similarity] Names don't match (WriteMutableData vs upload_inner), and domains are different (data insertion vs file upload). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and control flow, and some API mappings related to data insertion and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx361_rank1.c", "source_rust_file": "Partial__WriteMutableData__idx361_rank1.rs", "c_api": "insertValues.PutBlob", "rust_api": "task.prepare_batch_upload", "mapping_type": "function", "description": "Adding binary data to a container (C) vs preparing batch upload (Rust)", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles async upload logic with file processing and error handling. [Similarity] Names don't match (WriteMutableData vs upload_inner), and domains are different (data insertion vs file upload). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and control flow, and some API mappings related to data insertion and error handling."}, {"knowledge_type": "Partial", "source_c_file": "Partial__WriteMutableData__idx361_rank1.c", "source_rust_file": "Partial__WriteMutableData__idx361_rank1.rs", "c_fragment": "if (!WriteUpdateData(insertValues, taskInfo)) {\n        return false;\n    }", "rust_fragment": "if !task.prepare_batch_upload(start, size).await {\n            return Err(TaskError::Failed(Reason::OthersError));\n        }", "description": "Both blocks check a condition and return an error if it fails.", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function handles async upload logic with file processing and error handling. [Similarity] Names don't match (WriteMutableData vs upload_inner), and domains are different (data insertion vs file upload). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and control flow, and some API mappings related to data insertion and error handling."}]
Unixcoder Score: 0.20910820364952087
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
struct CertInfo {
    cert: Option<Vec<Certificate>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx480_rank2.c", "source_rust_file": "API_Mapping__WriteMutableData__idx480_rank2.rs", "c_api": "insertValues.PutInt(\"reason\", taskInfo->commonData.reason)", "rust_api": "let task_config = TaskConfig::from_c_struct(unsafe { &*c_task_config })", "mapping_type": "function", "description": "Data insertion in C vs data conversion from C struct in Rust", "reasoning": "[Task Analysis] C function writes data to a database using ValuesBucket, while Rust function queries and constructs a TaskConfig from C FFI. [Similarity] No structural similarity in control flow or logic. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to database operations and FFI calls."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx480_rank2.c", "source_rust_file": "API_Mapping__WriteMutableData__idx480_rank2.rs", "c_api": "insertValues.PutLong(\"mtime\", taskInfo->commonData.mtime)", "rust_api": "let c_task_config = unsafe { QueryTaskConfig(task_id) }", "mapping_type": "function", "description": "Database write operation in C vs database query in Rust", "reasoning": "[Task Analysis] C function writes data to a database using ValuesBucket, while Rust function queries and constructs a TaskConfig from C FFI. [Similarity] No structural similarity in control flow or logic. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to database operations and FFI calls."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx480_rank2.c", "source_rust_file": "API_Mapping__WriteMutableData__idx480_rank2.rs", "c_api": "insertValues.PutBlob(\"certs_paths\", CStringToBlob(taskConfig->certsPathPtr, taskConfig->certsPathLen))", "rust_api": "Some(task_config)", "mapping_type": "function", "description": "Blob data insertion in C vs returning result in Rust", "reasoning": "[Task Analysis] C function writes data to a database using ValuesBucket, while Rust function queries and constructs a TaskConfig from C FFI. [Similarity] No structural similarity in control flow or logic. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to database operations and FFI calls."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx480_rank2.c", "source_rust_file": "API_Mapping__WriteMutableData__idx480_rank2.rs", "c_api": "insertValues.PutBlob(\"form_items\", CFormItemToBlob(taskConfig->formItemsPtr, taskConfig->formItemsLen))", "rust_api": "sys_event!(ExecFault, DfxCode::RDB_FAULT_06, &format!(\"can not find task in database, task id: {}\", task_id))", "mapping_type": "function", "description": "Blob data insertion in C vs error logging in Rust", "reasoning": "[Task Analysis] C function writes data to a database using ValuesBucket, while Rust function queries and constructs a TaskConfig from C FFI. [Similarity] No structural similarity in control flow or logic. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to database operations and FFI calls."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx480_rank2.c", "source_rust_file": "API_Mapping__WriteMutableData__idx480_rank2.rs", "c_api": "insertValues.PutBlob(\"body_file_names\", CStringToBlob(taskConfig->bodyFileNamesPtr, taskConfig->bodyFileNamesLen))", "rust_api": "debug!(\"query single task config in database\")", "mapping_type": "function", "description": "Blob data insertion in C vs debug logging in Rust", "reasoning": "[Task Analysis] C function writes data to a database using ValuesBucket, while Rust function queries and constructs a TaskConfig from C FFI. [Similarity] No structural similarity in control flow or logic. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to database operations and FFI calls."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx480_rank2.c", "source_rust_file": "API_Mapping__WriteMutableData__idx480_rank2.rs", "c_api": "insertValues.PutBlob(\"file_specs\", CFileSpecToBlob(taskConfig->fileSpecsPtr, taskConfig->fileSpecsLen))", "rust_api": "error!(\"can not find task in database, task id: {}\", task_id)", "mapping_type": "function", "description": "Blob data insertion in C vs error reporting in Rust", "reasoning": "[Task Analysis] C function writes data to a database using ValuesBucket, while Rust function queries and constructs a TaskConfig from C FFI. [Similarity] No structural similarity in control flow or logic. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to database operations and FFI calls."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx480_rank2.c", "source_rust_file": "API_Mapping__WriteMutableData__idx480_rank2.rs", "c_api": "insertValues.PutLong(\"tries\", taskInfo->commonData.tries)", "rust_api": "unsafe { DeleteCTaskConfig(c_task_config) }", "mapping_type": "function", "description": "Data insertion in C vs memory cleanup in Rust", "reasoning": "[Task Analysis] C function writes data to a database using ValuesBucket, while Rust function queries and constructs a TaskConfig from C FFI. [Similarity] No structural similarity in control flow or logic. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to database operations and FFI calls."}]
Unixcoder Score: 0.19016176462173462
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
pub(crate) struct CertManager {
    info: Arc<RwLock<CertInfo>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx536_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx536_rank5.rs", "c_api": "insertValues.PutBlob(\"body_file_names\", CStringToBlob(taskConfig->bodyFileNamesPtr, taskConfig->bodyFileNamesLen))", "rust_api": "if *task_count >= limit { error!(...) } else { *task_count += 1 }", "mapping_type": "method", "description": "Checking and incrementing task count", "reasoning": "[Task Analysis] C function writes data to a database-like structure, Rust function creates and validates a task with similar data flow. [Similarity] Names don't match but both involve data insertion and validation logic. [Knowledge Extraction] No full structural match due to different domains (data insertion vs task creation/validation). However, there are API mappings for data insertion patterns and conditional validation logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx536_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx536_rank5.rs", "c_api": "return true;", "rust_api": "Ok(task_id)", "mapping_type": "pattern", "description": "Successful completion return", "reasoning": "[Task Analysis] C function writes data to a database-like structure, Rust function creates and validates a task with similar data flow. [Similarity] Names don't match but both involve data insertion and validation logic. [Knowledge Extraction] No full structural match due to different domains (data insertion vs task creation/validation). However, there are API mappings for data insertion patterns and conditional validation logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx536_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx536_rank5.rs", "c_api": "insertValues.PutInt(\"reason\", taskInfo->commonData.reason)", "rust_api": "config.common_data.uid = uid", "mapping_type": "method", "description": "Setting user ID in configuration data", "reasoning": "[Task Analysis] C function writes data to a database-like structure, Rust function creates and validates a task with similar data flow. [Similarity] Names don't match but both involve data insertion and validation logic. [Knowledge Extraction] No full structural match due to different domains (data insertion vs task creation/validation). However, there are API mappings for data insertion patterns and conditional validation logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx536_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx536_rank5.rs", "c_api": "insertValues.PutBlob(\"form_items\", CFormItemToBlob(taskConfig->formItemsPtr, taskConfig->formItemsLen))", "rust_api": "let (frontend, background) = self.task_count.entry(config.common_data.uid).or_insert((0, 0))", "mapping_type": "method", "description": "Managing task count per user", "reasoning": "[Task Analysis] C function writes data to a database-like structure, Rust function creates and validates a task with similar data flow. [Similarity] Names don't match but both involve data insertion and validation logic. [Knowledge Extraction] No full structural match due to different domains (data insertion vs task creation/validation). However, there are API mappings for data insertion patterns and conditional validation logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx536_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx536_rank5.rs", "c_api": "insertValues.PutLong(\"tries\", taskInfo->commonData.tries)", "rust_api": "config.version = version", "mapping_type": "method", "description": "Setting version in configuration data", "reasoning": "[Task Analysis] C function writes data to a database-like structure, Rust function creates and validates a task with similar data flow. [Similarity] Names don't match but both involve data insertion and validation logic. [Knowledge Extraction] No full structural match due to different domains (data insertion vs task creation/validation). However, there are API mappings for data insertion patterns and conditional validation logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx536_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx536_rank5.rs", "c_api": "insertValues.PutBlob(\"certs_paths\", CStringToBlob(taskConfig->certsPathPtr, taskConfig->certsPathLen))", "rust_api": "let (files, client) = check_config(...)", "mapping_type": "method", "description": "Validating configuration and retrieving files/client", "reasoning": "[Task Analysis] C function writes data to a database-like structure, Rust function creates and validates a task with similar data flow. [Similarity] Names don't match but both involve data insertion and validation logic. [Knowledge Extraction] No full structural match due to different domains (data insertion vs task creation/validation). However, there are API mappings for data insertion patterns and conditional validation logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx536_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx536_rank5.rs", "c_api": "insertValues.PutLong(\"mtime\", taskInfo->commonData.mtime)", "rust_api": "config.common_data.task_id = task_id", "mapping_type": "method", "description": "Setting task ID in configuration data", "reasoning": "[Task Analysis] C function writes data to a database-like structure, Rust function creates and validates a task with similar data flow. [Similarity] Names don't match but both involve data insertion and validation logic. [Knowledge Extraction] No full structural match due to different domains (data insertion vs task creation/validation). However, there are API mappings for data insertion patterns and conditional validation logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx536_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx536_rank5.rs", "c_api": "insertValues.PutBlob(\"file_specs\", CFileSpecToBlob(taskConfig->fileSpecsPtr, taskConfig->fileSpecsLen))", "rust_api": "let (task_count, limit) = match config.common_data.mode { Mode::FrontEnd => (frontend, MAX_FRONTEND_TASK), _ => (background, MAX_BACKGROUND_TASK) }", "mapping_type": "method", "description": "Determining task limits based on mode", "reasoning": "[Task Analysis] C function writes data to a database-like structure, Rust function creates and validates a task with similar data flow. [Similarity] Names don't match but both involve data insertion and validation logic. [Knowledge Extraction] No full structural match due to different domains (data insertion vs task creation/validation). However, there are API mappings for data insertion patterns and conditional validation logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx536_rank5.c", "source_rust_file": "API_Mapping__WriteMutableData__idx536_rank5.rs", "c_api": "if (!WriteUpdateData(insertValues, taskInfo)) { return false; }", "rust_api": "if *task_count >= limit { return Err(ErrorCode::TaskEnqueueErr); }", "mapping_type": "pattern", "description": "Conditional early return on validation failure", "reasoning": "[Task Analysis] C function writes data to a database-like structure, Rust function creates and validates a task with similar data flow. [Similarity] Names don't match but both involve data insertion and validation logic. [Knowledge Extraction] No full structural match due to different domains (data insertion vs task creation/validation). However, there are API mappings for data insertion patterns and conditional validation logic."}]
Unixcoder Score: 0.18267811834812164
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
struct CertInfo {
    cert: Option<Vec<Certificate>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx355_rank3.c", "source_rust_file": "Partial__WriteMutableData__idx355_rank3.rs", "c_api": "insertValues.PutBlob(\"form_items\", CFormItemToBlob(...))", "rust_api": "multi_part = multi_part.part(part);", "mapping_type": "function", "description": "Adding form item data to a multipart request", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function builds an HTTP multipart request. [Similarity] Names refer to different concepts (WriteMutableData vs build_multipart_request), and domains are different (database operations vs HTTP request building). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and loop structures, and some API mappings related to data insertion and iteration."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx355_rank3.c", "source_rust_file": "Partial__WriteMutableData__idx355_rank3.rs", "c_api": "insertValues.PutLong(\"mtime\", taskInfo->commonData.mtime)", "rust_api": "let part = Part::new().name(task.conf.file_specs[index].name.as_str()).file_name(task.conf.file_specs[index].file_name.as_str()).mime(task.conf.file_specs[index].mime_type.as_str()).length(Some(upload_length)).stream(task_reader);", "mapping_type": "function", "description": "Setting metadata for a part in a multipart request", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function builds an HTTP multipart request. [Similarity] Names refer to different concepts (WriteMutableData vs build_multipart_request), and domains are different (database operations vs HTTP request building). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and loop structures, and some API mappings related to data insertion and iteration."}, {"knowledge_type": "Partial", "source_c_file": "Partial__WriteMutableData__idx355_rank3.c", "source_rust_file": "Partial__WriteMutableData__idx355_rank3.rs", "c_fragment": "for (int i = 0; i < taskConfig->formItemsLen; i++) {\n        insertValues.PutBlob(\"form_items\", CFormItemToBlob(taskConfig->formItemsPtr + i, 1));\n    }", "rust_fragment": "for item in task.conf.form_items.iter() {\n        let part = Part::new()\n            .name(item.name.as_str())\n            .body(item.value.as_str());\n        multi_part = multi_part.part(part);\n    }", "description": "Both iterate over form items and add them to a collection.", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function builds an HTTP multipart request. [Similarity] Names refer to different concepts (WriteMutableData vs build_multipart_request), and domains are different (database operations vs HTTP request building). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and loop structures, and some API mappings related to data insertion and iteration."}]
Unixcoder Score: 0.16848012804985046
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
pub(crate) struct CertManager {
    info: Arc<RwLock<CertInfo>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "insertValues.PutInt(\"reason\", taskInfo->commonData.reason)", "rust_api": "TaskInfo::from_c_struct(c_task_info)", "mapping_type": "function", "description": "Data field assignment and retrieval", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "insertValues.PutLong(\"tries\", taskInfo->commonData.tries)", "rust_api": "TaskInfo::from_c_struct(c_task_info)", "mapping_type": "function", "description": "Data field assignment and retrieval", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "insertValues.PutLong(\"mtime\", taskInfo->commonData.mtime)", "rust_api": "TaskInfo::from_c_struct(c_task_info)", "mapping_type": "function", "description": "Data field assignment and retrieval", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "unsafe { DeleteCTaskInfo(c_task_info) }", "rust_api": "unsafe { DeleteCTaskInfo(c_task_info) }", "mapping_type": "function", "description": "Memory deallocation via FFI", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "unsafe { GetTaskInfo(task_id) }", "rust_api": "unsafe { &*c_task_info }", "mapping_type": "function", "description": "FFI function call and pointer dereference", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}]
Unixcoder Score: 0.16835767030715942
--------------------------------------------------
C_Code: 
int32_t RequestCertManager::InitCertInfo(struct CertInfo *certInfo)
{
    certInfo->certInfo.data = static_cast<uint8_t *>(malloc(MAX_LEN_CERTIFICATE));
    if (certInfo->certInfo.data == nullptr) {
        return CMR_ERROR_MALLOC_FAIL;
    }
    certInfo->certInfo.size = MAX_LEN_CERTIFICATE;

    return CM_SUCCESS;
}
Function: 
fn update_system_cert(info: &Arc<RwLock<CertInfo>>) {
    let mut info = info.write().unwrap();

    let mut certificates = Vec::new();

    let c_certs_ptr = unsafe { GetUserCertsData() };
    if !c_certs_ptr.is_null() {
        info!("GetUserCertsData valid");
        let certs = unsafe { &*c_certs_ptr };
        let c_cert_list_ptr =
            unsafe { std::slice::from_raw_parts(certs.cert_data_list, certs.len as usize) };
        for item in c_cert_list_ptr.iter() {
            let cert = unsafe { &**item };
            let cert_slice = unsafe { std::slice::from_raw_parts(cert.data, cert.size as usize) };
            match Certificate::from_pem(cert_slice) {
                Ok(cert) => {
                    certificates.push(cert);
                }
                Err(e) => {
                    error!("parse security cert path failed, error is {:?}", e);
                    return;
                }
            };
        }
        unsafe { FreeCertDataList(c_certs_ptr) };
    }

    match Certificate::from_path("/system/etc/security/certificates/") {
        Ok(cert) => {
            certificates.push(cert);
        }
        Err(e) => {
            error!("parse security cert path failed, error is {:?}", e);
            return;
        }
    };

    *info = CertInfo {
        cert: Some(certificates),
    };
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__FreeCertDataList__idx555_rank4.c", "source_rust_file": "Partial__FreeCertDataList__idx555_rank4.rs", "c_api": "FreeCertDataList", "rust_api": "FreeCertDataList", "mapping_type": "function", "description": "Memory cleanup function for certificate data list", "reasoning": "[Task Analysis] C function FreeCertDataList calls a C++ method, Rust function update_system_cert manages certificate data and calls the same C function via FFI. [Similarity] The C function is a thin wrapper around a C++ method, while the Rust function contains the full logic including FFI call to FreeCertDataList. [Knowledge Extraction] Full structural match in the FFI call pattern, partial match in the certificate processing logic, and API mapping for FreeCertDataList between C and Rust."}, {"knowledge_type": "Partial", "source_c_file": "Partial__FreeCertDataList__idx555_rank4.c", "source_rust_file": "Partial__FreeCertDataList__idx555_rank4.rs", "c_fragment": "void FreeCertDataList(struct CRequestCerts *certs)\n{\n    RequestCertManager::GetInstance().FreeCertDataList(certs);\n}", "rust_fragment": "unsafe { FreeCertDataList(c_certs_ptr) };", "description": "C function FreeCertDataList calls a C++ method, Rust function calls the same C function via FFI.", "reasoning": "[Task Analysis] C function FreeCertDataList calls a C++ method, Rust function update_system_cert manages certificate data and calls the same C function via FFI. [Similarity] The C function is a thin wrapper around a C++ method, while the Rust function contains the full logic including FFI call to FreeCertDataList. [Knowledge Extraction] Full structural match in the FFI call pattern, partial match in the certificate processing logic, and API mapping for FreeCertDataList between C and Rust."}]
Unixcoder Score: 0.09573512524366379
--------------------------------------------------
C_Code: 
int32_t RequestCertManager::InitCertInfo(struct CertInfo *certInfo)
{
    certInfo->certInfo.data = static_cast<uint8_t *>(malloc(MAX_LEN_CERTIFICATE));
    if (certInfo->certInfo.data == nullptr) {
        return CMR_ERROR_MALLOC_FAIL;
    }
    certInfo->certInfo.size = MAX_LEN_CERTIFICATE;

    return CM_SUCCESS;
}
Function: 
fn build_task_certificate_pins(
    config: &TaskConfig,
) -> Result<Option<PubKeyPins>, Box<dyn Error + Send + Sync>> {
    if config.certificate_pins.is_empty() {
        return Ok(None);
    }

    Ok(Some(cvt_res_error!(
        PubKeyPins::builder()
            .add(&config.url, &config.certificate_pins)
            .build()
            .map_err(Box::new),
        "Create task certificate pinned_key failed",
    )))
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__ParseParams__idx5340_rank2.c", "source_rust_file": "Partial__ParseParams__idx5340_rank2.rs", "c_api": "options.SetConnectTimeout(ops->connectTimeout)", "rust_api": "r.headers.insert(...)", "mapping_type": "function", "description": "Setting connection timeout via header insertion", "reasoning": "[Task Analysis] C function parses HTTP request parameters and sets options; Rust function sets HTTP headers. [Similarity] Names don't match but both involve setting HTTP request properties. [Knowledge Extraction] No full structural match due to different domains (parameter parsing vs header setting). Partial match in control flow pattern (if-else logic for optional fields). API mappings found for header setting operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ParseParams__idx5340_rank2.c", "source_rust_file": "Partial__ParseParams__idx5340_rank2.rs", "c_api": "options.SetMaxLimit(ops->maxLimit)", "rust_api": "r.headers.insert(...)", "mapping_type": "function", "description": "Setting limit parameters via header insertion", "reasoning": "[Task Analysis] C function parses HTTP request parameters and sets options; Rust function sets HTTP headers. [Similarity] Names don't match but both involve setting HTTP request properties. [Knowledge Extraction] No full structural match due to different domains (parameter parsing vs header setting). Partial match in control flow pattern (if-else logic for optional fields). API mappings found for header setting operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ParseParams__idx5340_rank2.c", "source_rust_file": "Partial__ParseParams__idx5340_rank2.rs", "c_api": "options.SetReadTimeout(ops->readTimeout)", "rust_api": "r.headers.insert(...)", "mapping_type": "function", "description": "Setting timeout parameters via header insertion", "reasoning": "[Task Analysis] C function parses HTTP request parameters and sets options; Rust function sets HTTP headers. [Similarity] Names don't match but both involve setting HTTP request properties. [Knowledge Extraction] No full structural match due to different domains (parameter parsing vs header setting). Partial match in control flow pattern (if-else logic for optional fields). API mappings found for header setting operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ParseParams__idx5340_rank2.c", "source_rust_file": "Partial__ParseParams__idx5340_rank2.rs", "c_api": "options.SetUrl(url)", "rust_api": "r.headers.insert(...)", "mapping_type": "function", "description": "Setting HTTP request properties (URL vs headers)", "reasoning": "[Task Analysis] C function parses HTTP request parameters and sets options; Rust function sets HTTP headers. [Similarity] Names don't match but both involve setting HTTP request properties. [Knowledge Extraction] No full structural match due to different domains (parameter parsing vs header setting). Partial match in control flow pattern (if-else logic for optional fields). API mappings found for header setting operations."}, {"knowledge_type": "Partial", "source_c_file": "Partial__ParseParams__idx5340_rank2.c", "source_rust_file": "Partial__ParseParams__idx5340_rank2.rs", "c_fragment": "if (ops != nullptr) {\n        options.SetMethod(std::string(ops->method));\n        options.SetReadTimeout(ops->readTimeout);\n        options.SetMaxLimit(ops->maxLimit);\n        options.SetConnectTimeout(ops->connectTimeout);", "rust_fragment": "self.inner = self.inner.and_then(|mut r| {\n            r.headers.insert(\n                HeaderName::from_bytes(name.as_bytes())\n                    .map_err(|e| HttpClientError::new_with_cause(ErrorKind::Build, Some(e)))?,\n                value\n                    .parse()\n                    .map_err(|e| HttpClientError::new_with_cause(ErrorKind::Build, Some(e)))?,\n            );\n            Ok(r)\n        });", "description": "Both use conditional logic to set properties when input is present", "reasoning": "[Task Analysis] C function parses HTTP request parameters and sets options; Rust function sets HTTP headers. [Similarity] Names don't match but both involve setting HTTP request properties. [Knowledge Extraction] No full structural match due to different domains (parameter parsing vs header setting). Partial match in control flow pattern (if-else logic for optional fields). API mappings found for header setting operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ParseParams__idx5340_rank2.c", "source_rust_file": "Partial__ParseParams__idx5340_rank2.rs", "c_api": "options.SetMethod(std::string(ops->method))", "rust_api": "r.headers.insert(...)", "mapping_type": "function", "description": "Setting HTTP method via header insertion", "reasoning": "[Task Analysis] C function parses HTTP request parameters and sets options; Rust function sets HTTP headers. [Similarity] Names don't match but both involve setting HTTP request properties. [Knowledge Extraction] No full structural match due to different domains (parameter parsing vs header setting). Partial match in control flow pattern (if-else logic for optional fields). API mappings found for header setting operations."}]
Unixcoder Score: 0.08058272302150726
--------------------------------------------------
