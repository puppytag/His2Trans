C_Code: 
struct CRequestCerts {
    struct CRequestCert **certDataList;
    uint32_t len;
}
Function: 
pub(crate) struct CRequestCerts {
    pub(crate) cert_data_list: *const *const CRequestCert,
    pub(crate) len: u32,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3122_rank4.c", "source_rust_file": "Partial__Verify__idx3122_rank4.rs", "c_api": "VerifyOffset(verifier, VT_V8)", "rust_api": "visit_field::<...>(\"refer_to_a1\", Self::VT_REFER_TO_A1, false)", "mapping_type": "function", "description": "Offset verification in FlatBuffers schema", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly refer to the same concept (Verify vs run_verifier), but both are related to FlatBuffers verification logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI call detected. [Filter 4: Semantic Domain Mismatch] -> Both operate on FlatBuffers schema verification, so domain is consistent. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are function definitions, not calls. [Full Classification] -> Code lengths are similar (~20 lines each), and both perform schema verification, but the logic differs in implementation (C uses VerifyField/VerifyOffset, Rust uses visit_field/finish). [Partial Classification] -> There are matching structural patterns in the control flow and logic of verification. [API Mappings] -> Multiple API correspondences found between C and Rust verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3122_rank4.c", "source_rust_file": "Partial__Verify__idx3122_rank4.rs", "c_api": "verifier.EndTable()", "rust_api": ".finish();", "mapping_type": "function", "description": "End table verification in FlatBuffers schema", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly refer to the same concept (Verify vs run_verifier), but both are related to FlatBuffers verification logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI call detected. [Filter 4: Semantic Domain Mismatch] -> Both operate on FlatBuffers schema verification, so domain is consistent. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are function definitions, not calls. [Full Classification] -> Code lengths are similar (~20 lines each), and both perform schema verification, but the logic differs in implementation (C uses VerifyField/VerifyOffset, Rust uses visit_field/finish). [Partial Classification] -> There are matching structural patterns in the control flow and logic of verification. [API Mappings] -> Multiple API correspondences found between C and Rust verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3122_rank4.c", "source_rust_file": "Partial__Verify__idx3122_rank4.rs", "c_api": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_api": "visit_field::<flatbuffers::ForwardsUOffset<...>>(\"refer_to_a1\", Self::VT_REFER_TO_A1, false)", "mapping_type": "function", "description": "Field verification in FlatBuffers schema", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly refer to the same concept (Verify vs run_verifier), but both are related to FlatBuffers verification logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI call detected. [Filter 4: Semantic Domain Mismatch] -> Both operate on FlatBuffers schema verification, so domain is consistent. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are function definitions, not calls. [Full Classification] -> Code lengths are similar (~20 lines each), and both perform schema verification, but the logic differs in implementation (C uses VerifyField/VerifyOffset, Rust uses visit_field/finish). [Partial Classification] -> There are matching structural patterns in the control flow and logic of verification. [API Mappings] -> Multiple API correspondences found between C and Rust verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3122_rank4.c", "source_rust_file": "Partial__Verify__idx3122_rank4.rs", "c_api": "verifier.VerifyVector(v8())", "rust_api": "visit_field::<...>(\"refer_to_a1\", Self::VT_REFER_TO_A1, false)", "mapping_type": "function", "description": "Vector verification in FlatBuffers schema", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly refer to the same concept (Verify vs run_verifier), but both are related to FlatBuffers verification logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI call detected. [Filter 4: Semantic Domain Mismatch] -> Both operate on FlatBuffers schema verification, so domain is consistent. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are function definitions, not calls. [Full Classification] -> Code lengths are similar (~20 lines each), and both perform schema verification, but the logic differs in implementation (C uses VerifyField/VerifyOffset, Rust uses visit_field/finish). [Partial Classification] -> There are matching structural patterns in the control flow and logic of verification. [API Mappings] -> Multiple API correspondences found between C and Rust verification operations."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Verify__idx3122_rank4.c", "source_rust_file": "Partial__Verify__idx3122_rank4.rs", "c_fragment": "return VerifyTableStart(verifier) &&\n           VerifyField<int8_t>(verifier, VT_I8, 1) &&\n           VerifyField<uint8_t>(verifier, VT_U8, 1) &&\n           VerifyField<int16_t>(verifier, VT_I16, 2) &&\n           VerifyField<uint16_t>(verifier, VT_U16, 2) &&\n           VerifyField<int32_t>(verifier, VT_I32, 4) &&\n           VerifyField<uint32_t>(verifier, VT_U32, 4) &&\n           VerifyField<int64_t>(verifier, VT_I64, 8) &&\n           VerifyField<uint64_t>(verifier, VT_U64, 8) &&\n           VerifyField<float>(verifier, VT_F32, 4) &&\n           VerifyField<double>(verifier, VT_F64, 8) &&\n           VerifyOffset(verifier, VT_V8) &&\n           verifier.VerifyVector(v8()) &&\n           VerifyOffset(verifier, VT_VF64) &&\n           verifier.VerifyVector(vf64()) &&\n           verifier.EndTable();", "rust_fragment": "v.visit_table(pos)?\n     .visit_field::<flatbuffers::ForwardsUOffset<super::namespace_a::TableInFirstNS>>(\"refer_to_a1\", Self::VT_REFER_TO_A1, false)?\n     .visit_field::<flatbuffers::ForwardsUOffset<super::namespace_a::SecondTableInA>>(\"refer_to_a2\", Self::VT_REFER_TO_A2, false)?\n     .finish();", "description": "Both perform schema verification on FlatBuffers tables, checking fields and vectors.", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly refer to the same concept (Verify vs run_verifier), but both are related to FlatBuffers verification logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI call detected. [Filter 4: Semantic Domain Mismatch] -> Both operate on FlatBuffers schema verification, so domain is consistent. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are function definitions, not calls. [Full Classification] -> Code lengths are similar (~20 lines each), and both perform schema verification, but the logic differs in implementation (C uses VerifyField/VerifyOffset, Rust uses visit_field/finish). [Partial Classification] -> There are matching structural patterns in the control flow and logic of verification. [API Mappings] -> Multiple API correspondences found between C and Rust verification operations."}]
Unixcoder Score: 0.08731884509325027
--------------------------------------------------
C_Code: 
struct CRequestCerts {
    struct CRequestCert **certDataList;
    uint32_t len;
}
Function: 
pub(crate) struct CRequestCerts {
    pub(crate) cert_data_list: *const *const CRequestCert,
    pub(crate) len: u32,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyTableStart(verifier)", "rust_api": "v.visit_table(pos)?", "mapping_type": "function", "description": "Start verification of a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "Full", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks.", "description": "Full structural translation"}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<float>(verifier, VT_F32, 4)", "rust_api": "visit_field::<f32>(\"f32_\", Self::VT_F32_, false)?", "mapping_type": "function", "description": "Verify a float field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "Partial", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_fragment": "VerifyTableStart(verifier) &&\n           VerifyField<int8_t>(verifier, VT_I8, 1) &&\n           VerifyField<uint8_t>(verifier, VT_U8, 1) &&\n           VerifyField<int16_t>(verifier, VT_I16, 2) &&\n           VerifyField<uint16_t>(verifier, VT_U16, 2) &&\n           VerifyField<int32_t>(verifier, VT_I32, 4) &&\n           VerifyField<uint32_t>(verifier, VT_U32, 4) &&\n           VerifyField<int64_t>(verifier, VT_I64, 8) &&\n           VerifyField<uint64_t>(verifier, VT_U64, 8) &&\n           VerifyField<float>(verifier, VT_F32, 4) &&\n           VerifyField<double>(verifier, VT_F64, 8) &&\n           VerifyOffset(verifier, VT_V8) &&\n           verifier.VerifyVector(v8()) &&\n           VerifyOffset(verifier, VT_VF64) &&\n           verifier.VerifyVector(vf64()) &&\n           verifier.EndTable();", "rust_fragment": "v.visit_table(pos)?\n     .visit_field::<i8>(\"i8_\", Self::VT_I8_, false)?\n     .visit_field::<u8>(\"u8_\", Self::VT_U8_, false)?\n     .visit_field::<i16>(\"i16_\", Self::VT_I16_, false)?\n     .visit_field::<u16>(\"u16_\", Self::VT_U16_, false)?\n     .visit_field::<i32>(\"i32_\", Self::VT_I32_, false)?\n     .visit_field::<u32>(\"u32_\", Self::VT_U32_, false)?\n     .visit_field::<i64>(\"i64_\", Self::VT_I64_, false)?\n     .visit_field::<u64>(\"u64_\", Self::VT_U64_, false)?\n     .visit_field::<f32>(\"f32_\", Self::VT_F32_, false)?\n     .visit_field::<f64>(\"f64_\", Self::VT_F64_, false)?\n     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(\"v8\", Self::VT_V8, false)?\n     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(\"vf64\", Self::VT_VF64, false)?\n     .finish();", "description": "Both verify table fields and vectors using similar logic and structure.", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "verifier.VerifyVector(v8())", "rust_api": "visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(\"v8\", Self::VT_V8, false)?", "mapping_type": "function", "description": "Verify a vector field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyOffset(verifier, VT_VF64)", "rust_api": "visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(\"vf64\", Self::VT_VF64, false)?", "mapping_type": "function", "description": "Verify offset to a vector field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<double>(verifier, VT_F64, 8)", "rust_api": "visit_field::<f64>(\"f64_\", Self::VT_F64_, false)?", "mapping_type": "function", "description": "Verify a double field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyOffset(verifier, VT_V8)", "rust_api": "visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(\"v8\", Self::VT_V8, false)?", "mapping_type": "function", "description": "Verify offset to a vector field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<uint64_t>(verifier, VT_U64, 8)", "rust_api": "visit_field::<u64>(\"u64_\", Self::VT_U64_, false)?", "mapping_type": "function", "description": "Verify a uint64 field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<uint32_t>(verifier, VT_U32, 4)", "rust_api": "visit_field::<u32>(\"u32_\", Self::VT_U32_, false)?", "mapping_type": "function", "description": "Verify a uint32 field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<int16_t>(verifier, VT_I16, 2)", "rust_api": "visit_field::<i16>(\"i16_\", Self::VT_I16_, false)?", "mapping_type": "function", "description": "Verify an int16 field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "verifier.EndTable()", "rust_api": ".finish();", "mapping_type": "function", "description": "End verification of a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<int32_t>(verifier, VT_I32, 4)", "rust_api": "visit_field::<i32>(\"i32_\", Self::VT_I32_, false)?", "mapping_type": "function", "description": "Verify an int32 field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<uint8_t>(verifier, VT_U8, 1)", "rust_api": "visit_field::<u8>(\"u8_\", Self::VT_U8_, false)?", "mapping_type": "function", "description": "Verify a uint8 field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "verifier.VerifyVector(vf64())", "rust_api": "visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(\"vf64\", Self::VT_VF64, false)?", "mapping_type": "function", "description": "Verify a vector field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<int64_t>(verifier, VT_I64, 8)", "rust_api": "visit_field::<i64>(\"i64_\", Self::VT_I64_, false)?", "mapping_type": "function", "description": "Verify an int64 field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<uint16_t>(verifier, VT_U16, 2)", "rust_api": "visit_field::<u16>(\"u16_\", Self::VT_U16_, false)?", "mapping_type": "function", "description": "Verify a uint16 field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__Verify__idx2923_rank1.c", "source_rust_file": "Full__Verify__idx2923_rank1.rs", "c_api": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_api": "visit_field::<i8>(\"i8_\", Self::VT_I8_, false)?", "mapping_type": "function", "description": "Verify an int8 field in a flatbuffer table", "reasoning": "[Task Analysis] C and Rust code both perform flatbuffer table verification. [Similarity] Both verify fields and vectors in a structured way, with similar logical flow. [Knowledge Extraction] Full structural match on verification logic, API mappings identified for field verification and vector checks."}]
Unixcoder Score: 0.073085255920887
--------------------------------------------------
C_Code: 
bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_I8, 1) &&
           VerifyField<uint8_t>(verifier, VT_U8, 1) &&
           VerifyField<int16_t>(verifier, VT_I16, 2) &&
           VerifyField<uint16_t>(verifier, VT_U16, 2) &&
           VerifyField<int32_t>(verifier, VT_I32, 4) &&
           VerifyField<uint32_t>(verifier, VT_U32, 4) &&
           VerifyField<int64_t>(verifier, VT_I64, 8) &&
           VerifyField<uint64_t>(verifier, VT_U64, 8) &&
           VerifyField<float>(verifier, VT_F32, 4) &&
           VerifyField<double>(verifier, VT_F64, 8) &&
           VerifyOffset(verifier, VT_V8) &&
           verifier.VerifyVector(v8()) &&
           VerifyOffset(verifier, VT_VF64) &&
           verifier.VerifyVector(vf64()) &&
           verifier.EndTable();
  }
Function: 
fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "verifier.EndTable()", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers table end verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<float>(verifier, VT_F32, 4)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<uint8_t>(verifier, VT_U8, 1)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<uint64_t>(verifier, VT_U64, 8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<int32_t>(verifier, VT_I32, 4)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<uint32_t>(verifier, VT_U32, 4)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<int64_t>(verifier, VT_I64, 8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<uint16_t>(verifier, VT_U16, 2)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<int16_t>(verifier, VT_I16, 2)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "verifier.VerifyVector(vf64())", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers vector verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_fragment": "VerifyTableStart(verifier) &&\n           VerifyField<int8_t>(verifier, VT_I8, 1) &&\n           VerifyField<uint8_t>(verifier, VT_U8, 1) &&\n           VerifyField<int16_t>(verifier, VT_I16, 2) &&\n           VerifyField<uint16_t>(verifier, VT_U16, 2) &&\n           VerifyField<int32_t>(verifier, VT_I32, 4) &&\n           VerifyField<uint32_t>(verifier, VT_U32, 4) &&\n           VerifyField<int64_t>(verifier, VT_I64, 8) &&\n           VerifyField<uint64_t>(verifier, VT_U64, 8) &&\n           VerifyField<float>(verifier, VT_F32, 4) &&\n           VerifyField<double>(verifier, VT_F64, 8) &&\n           VerifyOffset(verifier, VT_V8) &&\n           verifier.VerifyVector(v8()) &&\n           VerifyOffset(verifier, VT_VF64) &&\n           verifier.VerifyVector(vf64()) &&\n           verifier.EndTable();", "rust_fragment": "v.in_buffer::<Self>(pos)", "description": "Both perform FlatBuffers verification logic, though at different levels (field/offset validation vs buffer position check).", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "verifier.VerifyVector(v8())", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers vector verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyField<double>(verifier, VT_F64, 8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyTableStart(verifier)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers table verification start", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyOffset(verifier, VT_VF64)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers offset verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3524_rank4.c", "source_rust_file": "Partial__Verify__idx3524_rank4.rs", "c_api": "VerifyOffset(verifier, VT_V8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers offset verification", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (validation vs buffer access). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}]
Unixcoder Score: -7.93239232734777e-05
--------------------------------------------------
C_Code: 
bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_I8, 1) &&
           VerifyField<uint8_t>(verifier, VT_U8, 1) &&
           VerifyField<int16_t>(verifier, VT_I16, 2) &&
           VerifyField<uint16_t>(verifier, VT_U16, 2) &&
           VerifyField<int32_t>(verifier, VT_I32, 4) &&
           VerifyField<uint32_t>(verifier, VT_U32, 4) &&
           VerifyField<int64_t>(verifier, VT_I64, 8) &&
           VerifyField<uint64_t>(verifier, VT_U64, 8) &&
           VerifyField<float>(verifier, VT_F32, 4) &&
           VerifyField<double>(verifier, VT_F64, 8) &&
           VerifyOffset(verifier, VT_V8) &&
           verifier.VerifyVector(v8()) &&
           VerifyOffset(verifier, VT_VF64) &&
           verifier.VerifyVector(vf64()) &&
           verifier.EndTable();
  }
Function: 
fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3414_rank4.h", "source_rust_file": "Partial__Verify__idx3414_rank4.rs", "c_api": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_api": "visit_table(pos)?", "mapping_type": "function", "description": "Verify a field in a FlatBuffers table", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a FlatBuffers verifier on a table. [Similarity] Names don't match but both perform verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and multiple API mappings between FlatBuffers verification methods."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3414_rank4.h", "source_rust_file": "Partial__Verify__idx3414_rank4.rs", "c_api": "verifier.EndTable()", "rust_api": ".finish()", "mapping_type": "method", "description": "Complete verification of a FlatBuffers table", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a FlatBuffers verifier on a table. [Similarity] Names don't match but both perform verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and multiple API mappings between FlatBuffers verification methods."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Verify__idx3414_rank4.h", "source_rust_file": "Partial__Verify__idx3414_rank4.rs", "c_fragment": "VerifyTableStart(verifier) &&\n           VerifyField<int8_t>(verifier, VT_I8, 1) &&\n           VerifyField<uint8_t>(verifier, VT_U8, 1) &&\n           VerifyField<int16_t>(verifier, VT_I16, 2) &&\n           VerifyField<uint16_t>(verifier, VT_U16, 2) &&\n           VerifyField<int32_t>(verifier, VT_I32, 4) &&\n           VerifyField<uint32_t>(verifier, VT_U32, 4) &&\n           VerifyField<int64_t>(verifier, VT_I64, 8) &&\n           VerifyField<uint64_t>(verifier, VT_U64, 8) &&\n           VerifyField<float>(verifier, VT_F32, 4) &&\n           VerifyField<double>(verifier, VT_F64, 8) &&\n           VerifyOffset(verifier, VT_V8) &&\n           verifier.VerifyVector(v8()) &&\n           VerifyOffset(verifier, VT_VF64) &&\n           verifier.VerifyVector(vf64()) &&\n           verifier.EndTable();", "rust_fragment": "v.visit_table(pos)?\n     .finish();", "description": "Both perform verification of FlatBuffers table structures, though Rust version is more concise and uses a visitor pattern.", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a FlatBuffers verifier on a table. [Similarity] Names don't match but both perform verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and multiple API mappings between FlatBuffers verification methods."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3414_rank4.h", "source_rust_file": "Partial__Verify__idx3414_rank4.rs", "c_api": "VerifyOffset(verifier, VT_V8)", "rust_api": "visit_table(pos)?", "mapping_type": "function", "description": "Verify an offset in a FlatBuffers table", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a FlatBuffers verifier on a table. [Similarity] Names don't match but both perform verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and multiple API mappings between FlatBuffers verification methods."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3414_rank4.h", "source_rust_file": "Partial__Verify__idx3414_rank4.rs", "c_api": "VerifyTableStart(verifier)", "rust_api": "v.visit_table(pos)?", "mapping_type": "function", "description": "Start verification of a FlatBuffers table", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a FlatBuffers verifier on a table. [Similarity] Names don't match but both perform verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and multiple API mappings between FlatBuffers verification methods."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3414_rank4.h", "source_rust_file": "Partial__Verify__idx3414_rank4.rs", "c_api": "verifier.VerifyVector(v8())", "rust_api": "visit_table(pos)?", "mapping_type": "function", "description": "Verify a vector in a FlatBuffers table", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a FlatBuffers verifier on a table. [Similarity] Names don't match but both perform verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and multiple API mappings between FlatBuffers verification methods."}]
Unixcoder Score: -0.005957035347819328
--------------------------------------------------
C_Code: 
bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_I8, 1) &&
           VerifyField<uint8_t>(verifier, VT_U8, 1) &&
           VerifyField<int16_t>(verifier, VT_I16, 2) &&
           VerifyField<uint16_t>(verifier, VT_U16, 2) &&
           VerifyField<int32_t>(verifier, VT_I32, 4) &&
           VerifyField<uint32_t>(verifier, VT_U32, 4) &&
           VerifyField<int64_t>(verifier, VT_I64, 8) &&
           VerifyField<uint64_t>(verifier, VT_U64, 8) &&
           VerifyField<float>(verifier, VT_F32, 4) &&
           VerifyField<double>(verifier, VT_F64, 8) &&
           VerifyOffset(verifier, VT_V8) &&
           verifier.VerifyVector(v8()) &&
           VerifyOffset(verifier, VT_VF64) &&
           verifier.VerifyVector(vf64()) &&
           verifier.EndTable();
  }
Function: 
fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ArrayStruct>("a", Self::VT_A, false)?
     .finish();
    Ok(())
  }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx4022_rank4.c", "source_rust_file": "Partial__Verify__idx4022_rank4.rs", "c_api": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "Field verification in FlatBuffers", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a FlatBuffers table. [Similarity] Both involve FlatBuffers verification logic, but the C code performs detailed field and vector checks while the Rust code only does a basic position check. [Knowledge Extraction] The core verification task is present in both, but the implementation details differ significantly in scope and structure. No full match due to domain mismatch (detailed validation vs basic position check). Partial match exists in the general verification concept. API mappings found for field verification and vector verification patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Verify__idx4022_rank4.c", "source_rust_file": "Partial__Verify__idx4022_rank4.rs", "c_fragment": "VerifyTableStart(verifier) &&\n           VerifyField<int8_t>(verifier, VT_I8, 1) &&\n           VerifyField<uint8_t>(verifier, VT_U8, 1) &&\n           VerifyField<int16_t>(verifier, VT_I16, 2) &&\n           VerifyField<uint16_t>(verifier, VT_U16, 2) &&\n           VerifyField<int32_t>(verifier, VT_I32, 4) &&\n           VerifyField<uint32_t>(verifier, VT_U32, 4) &&\n           VerifyField<int64_t>(verifier, VT_I64, 8) &&\n           VerifyField<uint64_t>(verifier, VT_U64, 8) &&\n           VerifyField<float>(verifier, VT_F32, 4) &&\n           VerifyField<double>(verifier, VT_F64, 8) &&\n           VerifyOffset(verifier, VT_V8) &&\n           verifier.VerifyVector(v8()) &&\n           VerifyOffset(verifier, VT_VF64) &&\n           verifier.VerifyVector(vf64()) &&\n           verifier.EndTable();", "rust_fragment": "v.in_buffer::<Self>(pos)", "description": "Both perform FlatBuffers table verification, though C does detailed field and vector checks while Rust only checks buffer position.", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a FlatBuffers table. [Similarity] Both involve FlatBuffers verification logic, but the C code performs detailed field and vector checks while the Rust code only does a basic position check. [Knowledge Extraction] The core verification task is present in both, but the implementation details differ significantly in scope and structure. No full match due to domain mismatch (detailed validation vs basic position check). Partial match exists in the general verification concept. API mappings found for field verification and vector verification patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx4022_rank4.c", "source_rust_file": "Partial__Verify__idx4022_rank4.rs", "c_api": "VerifyOffset(verifier, VT_V8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "Offset verification in FlatBuffers", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a FlatBuffers table. [Similarity] Both involve FlatBuffers verification logic, but the C code performs detailed field and vector checks while the Rust code only does a basic position check. [Knowledge Extraction] The core verification task is present in both, but the implementation details differ significantly in scope and structure. No full match due to domain mismatch (detailed validation vs basic position check). Partial match exists in the general verification concept. API mappings found for field verification and vector verification patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx4022_rank4.c", "source_rust_file": "Partial__Verify__idx4022_rank4.rs", "c_api": "verifier.VerifyVector(v8())", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "Vector verification in FlatBuffers", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a FlatBuffers table. [Similarity] Both involve FlatBuffers verification logic, but the C code performs detailed field and vector checks while the Rust code only does a basic position check. [Knowledge Extraction] The core verification task is present in both, but the implementation details differ significantly in scope and structure. No full match due to domain mismatch (detailed validation vs basic position check). Partial match exists in the general verification concept. API mappings found for field verification and vector verification patterns."}]
Unixcoder Score: -0.01475056353956461
--------------------------------------------------
C_Code: 
uint32_t VerifyCert(const CertBlob *cert, const CertBlob *caCert)
{
    uint32_t verifyResult = SSL_X509_V_ERR_UNSPECIFIED;
    X509 *certX509 = nullptr;
    X509 *caX509 = nullptr;
    X509_STORE *store = nullptr;
    X509_STORE_CTX *ctx = nullptr;
    do {
        certX509 = CertBlobToX509(cert);
        if (certX509 == nullptr) {
            NETSTACK_LOGE("x509 of cert is nullptr\n");
        }
        caX509 = CertBlobToX509(caCert);
        if (caX509 == nullptr) {
            NETSTACK_LOGE("x509 of ca is nullptr\n");
        }
        store = X509_STORE_new();
        if (store == nullptr) {
            continue;
        }
        if (X509_STORE_add_cert(store, caX509) != VERIFY_RESULT_SUCCESS) {
            NETSTACK_LOGE("add ca to store failed\n");
        }
        ctx = X509_STORE_CTX_new();
        if (ctx == nullptr) {
            continue;
        }
        X509_STORE_CTX_init(ctx, store, certX509, nullptr);
        verifyResult = static_cast<uint32_t>(X509_verify_cert(ctx));
        if (verifyResult != VERIFY_RESULT_SUCCESS) {
            verifyResult = static_cast<uint32_t>(X509_STORE_CTX_get_error(ctx) + SSL_ERROR_CODE_BASE);
            NETSTACK_LOGE("failed to verify certificate: %{public}s (%{public}d)\n",
                          X509_verify_cert_error_string(X509_STORE_CTX_get_error(ctx)), verifyResult);
            break;
        } else {
            verifyResult = X509_V_OK;
            NETSTACK_LOGD("certificate validation succeeded.\n");
        }
    } while (false);

    FreeResources(&certX509, &caX509, &store, &ctx);
    return verifyResult;
}
Function: 
pub fn from_pem(pem: &[u8]) -> Result<Certificate, HttpClientError> {
        const CERT_BEGIN: &str = "-----BEGIN CERTIFICATE-----";
        const CERT_END: &str = "-----END CERTIFICATE-----";

        let mut inner = Vec::new();
        let str = std::str::from_utf8(pem).map_err(|_| {
            HttpClientError::new_with_cause(ErrorKind::Build, Some(InvalidCertificate))
        })?;
        let mut pos = 0;
        while pos < str.len() {
            let st = match str[pos..].find(CERT_BEGIN) {
                Some(size) => size,
                None => break,
            };

            let ed = match str[pos + st..].find(CERT_END) {
                Some(size) => size,
                None => break,
            };

            let slice = str[pos + st..pos + st + ed + CERT_END.len()].as_bytes();
            let cert = reqwest::Certificate::from_pem(slice)
                .map_err(|e| HttpClientError::new_with_cause(ErrorKind::Build, Some(e)))?;
            inner.push(cert);
            pos += st + ed + CERT_END.len();
        }

        if inner.is_empty() {
            return Err(HttpClientError::new_with_cause(
                ErrorKind::Build,
                Some(InvalidCertificate),
            ));
        }

        Ok(Self { inner })
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__InitCertInfo__idx555_rank3.c", "source_rust_file": "Partial__InitCertInfo__idx555_rank3.rs", "c_fragment": "if (certInfo->certInfo.data == nullptr) {\n        return CMR_ERROR_MALLOC_FAIL;\n    }", "rust_fragment": "if !c_certs_ptr.is_null() {\n        info!(\"GetUserCertsData valid\");", "description": "Both contain conditional checks for null pointers and handle failure cases.", "reasoning": "[Task Analysis] C function allocates memory for a certificate info struct and returns an error code; Rust function fetches certificate data from C FFI, parses it into Rust Certificate objects, and updates a shared CertInfo struct. [Similarity] No full structural similarity due to different domains (memory allocation vs certificate parsing), different control flow, and different data structures. [Knowledge Extraction] Found partial matching logic in error handling and memory management patterns, and API mappings for memory allocation and FFI calls."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__InitCertInfo__idx555_rank3.c", "source_rust_file": "Partial__InitCertInfo__idx555_rank3.rs", "c_api": "free(ptr)", "rust_api": "unsafe { FreeCertDataList(c_certs_ptr) }", "mapping_type": "function", "description": "Memory deallocation in C vs FFI call to free memory in Rust", "reasoning": "[Task Analysis] C function allocates memory for a certificate info struct and returns an error code; Rust function fetches certificate data from C FFI, parses it into Rust Certificate objects, and updates a shared CertInfo struct. [Similarity] No full structural similarity due to different domains (memory allocation vs certificate parsing), different control flow, and different data structures. [Knowledge Extraction] Found partial matching logic in error handling and memory management patterns, and API mappings for memory allocation and FFI calls."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__InitCertInfo__idx555_rank3.c", "source_rust_file": "Partial__InitCertInfo__idx555_rank3.rs", "c_api": "static_cast<uint8_t *>(malloc(...))", "rust_api": "std::slice::from_raw_parts(...)", "mapping_type": "pattern", "description": "Raw pointer handling and memory access in C vs Rust", "reasoning": "[Task Analysis] C function allocates memory for a certificate info struct and returns an error code; Rust function fetches certificate data from C FFI, parses it into Rust Certificate objects, and updates a shared CertInfo struct. [Similarity] No full structural similarity due to different domains (memory allocation vs certificate parsing), different control flow, and different data structures. [Knowledge Extraction] Found partial matching logic in error handling and memory management patterns, and API mappings for memory allocation and FFI calls."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__InitCertInfo__idx555_rank3.c", "source_rust_file": "Partial__InitCertInfo__idx555_rank3.rs", "c_api": "malloc(MAX_LEN_CERTIFICATE)", "rust_api": "Vec::new()", "mapping_type": "pattern", "description": "Memory allocation pattern in C vs vector initialization in Rust", "reasoning": "[Task Analysis] C function allocates memory for a certificate info struct and returns an error code; Rust function fetches certificate data from C FFI, parses it into Rust Certificate objects, and updates a shared CertInfo struct. [Similarity] No full structural similarity due to different domains (memory allocation vs certificate parsing), different control flow, and different data structures. [Knowledge Extraction] Found partial matching logic in error handling and memory management patterns, and API mappings for memory allocation and FFI calls."}]
Unixcoder Score: -0.015401266515254974
--------------------------------------------------
C_Code: 
bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_BASE_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_ELEMENT, 1) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyField<uint16_t>(verifier, VT_FIXED_LENGTH, 2) &&
           VerifyField<uint32_t>(verifier, VT_BASE_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENT_SIZE, 4) &&
           verifier.EndTable();
  }
Function: 
fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("ints", Self::VT_INTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("floats", Self::VT_FLOATS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("empty_string", Self::VT_EMPTY_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("some_string", Self::VT_SOME_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ABC>>>("abcs", Self::VT_ABCS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("bools", Self::VT_BOOLS, false)?
     .finish();
    Ok(())
  }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__Verify__idx3756_rank5.h", "source_rust_file": "Partial__Verify__idx3756_rank5.rs", "c_fragment": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_fragment": "self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TypeAliases::VT_VF64, None)", "description": "Both access table fields using verifier/getter patterns with type-specific handling.", "reasoning": "[Task Analysis] C code is a verification function using FlatBuffers verifier APIs; Rust code is a getter method for a field in a FlatBuffers table. [Similarity] Names do not match exactly but refer to the same concept (FlatBuffers table field access/verification). [Knowledge Extraction] Found partial structural match in field verification logic and API mappings for field access patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3756_rank5.h", "source_rust_file": "Partial__Verify__idx3756_rank5.rs", "c_api": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_api": "self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TypeAliases::VT_VF64, None)", "mapping_type": "function", "description": "Field verification in C vs field access in Rust for FlatBuffers table", "reasoning": "[Task Analysis] C code is a verification function using FlatBuffers verifier APIs; Rust code is a getter method for a field in a FlatBuffers table. [Similarity] Names do not match exactly but refer to the same concept (FlatBuffers table field access/verification). [Knowledge Extraction] Found partial structural match in field verification logic and API mappings for field access patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3756_rank5.h", "source_rust_file": "Partial__Verify__idx3756_rank5.rs", "c_api": "VerifyOffset(verifier, VT_V8)", "rust_api": "verifier.VerifyVector(v8())", "mapping_type": "function", "description": "Offset verification in C vs vector verification in Rust", "reasoning": "[Task Analysis] C code is a verification function using FlatBuffers verifier APIs; Rust code is a getter method for a field in a FlatBuffers table. [Similarity] Names do not match exactly but refer to the same concept (FlatBuffers table field access/verification). [Knowledge Extraction] Found partial structural match in field verification logic and API mappings for field access patterns."}]
Unixcoder Score: -0.016897335648536682
--------------------------------------------------
C_Code: 
bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_I8, 1) &&
           VerifyField<uint8_t>(verifier, VT_U8, 1) &&
           VerifyField<int16_t>(verifier, VT_I16, 2) &&
           VerifyField<uint16_t>(verifier, VT_U16, 2) &&
           VerifyField<int32_t>(verifier, VT_I32, 4) &&
           VerifyField<uint32_t>(verifier, VT_U32, 4) &&
           VerifyField<int64_t>(verifier, VT_I64, 8) &&
           VerifyField<uint64_t>(verifier, VT_U64, 8) &&
           VerifyField<float>(verifier, VT_F32, 4) &&
           VerifyField<double>(verifier, VT_F64, 8) &&
           VerifyOffset(verifier, VT_V8) &&
           verifier.VerifyVector(v8()) &&
           VerifyOffset(verifier, VT_VF64) &&
           verifier.VerifyVector(vf64()) &&
           verifier.EndTable();
  }
Function: 
fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<GameMessage, _>("Message_type", Self::VT_MESSAGE_TYPE, "Message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          GameMessage::PlayerStatEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayerStatEvent>>("GameMessage::PlayerStatEvent", pos),
          GameMessage::PlayerSpectate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayerSpectate>>("GameMessage::PlayerSpectate", pos),
          GameMessage::PlayerInputChange => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayerInputChange>>("GameMessage::PlayerInputChange", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx4022_rank3.c", "source_rust_file": "Partial__Verify__idx4022_rank3.rs", "c_api": "VerifyOffset(verifier, VT_V8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "Offset verification in FlatBuffers", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a FlatBuffers table. [Similarity] Both involve FlatBuffers verification logic, but the C code performs detailed field and vector checks while the Rust code only does a basic position check. [Knowledge Extraction] No full structural match due to different scopes and logic. Partial match exists in the general verification concept. API mappings found for field verification and vector verification patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx4022_rank3.c", "source_rust_file": "Partial__Verify__idx4022_rank3.rs", "c_api": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "Field verification in FlatBuffers", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a FlatBuffers table. [Similarity] Both involve FlatBuffers verification logic, but the C code performs detailed field and vector checks while the Rust code only does a basic position check. [Knowledge Extraction] No full structural match due to different scopes and logic. Partial match exists in the general verification concept. API mappings found for field verification and vector verification patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx4022_rank3.c", "source_rust_file": "Partial__Verify__idx4022_rank3.rs", "c_api": "verifier.VerifyVector(v8())", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "Vector verification in FlatBuffers", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a FlatBuffers table. [Similarity] Both involve FlatBuffers verification logic, but the C code performs detailed field and vector checks while the Rust code only does a basic position check. [Knowledge Extraction] No full structural match due to different scopes and logic. Partial match exists in the general verification concept. API mappings found for field verification and vector verification patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Verify__idx4022_rank3.c", "source_rust_file": "Partial__Verify__idx4022_rank3.rs", "c_fragment": "VerifyTableStart(verifier) &&\n           VerifyField<int8_t>(verifier, VT_I8, 1) &&\n           VerifyField<uint8_t>(verifier, VT_U8, 1) &&\n           VerifyField<int16_t>(verifier, VT_I16, 2) &&\n           VerifyField<uint16_t>(verifier, VT_U16, 2) &&\n           VerifyField<int32_t>(verifier, VT_I32, 4) &&\n           VerifyField<uint32_t>(verifier, VT_U32, 4) &&\n           VerifyField<int64_t>(verifier, VT_I64, 8) &&\n           VerifyField<uint64_t>(verifier, VT_U64, 8) &&\n           VerifyField<float>(verifier, VT_F32, 4) &&\n           VerifyField<double>(verifier, VT_F64, 8) &&\n           VerifyOffset(verifier, VT_V8) &&\n           verifier.VerifyVector(v8()) &&\n           VerifyOffset(verifier, VT_VF64) &&\n           verifier.VerifyVector(vf64()) &&\n           verifier.EndTable();", "rust_fragment": "v.in_buffer::<Self>(pos)", "description": "Both perform FlatBuffers table verification, though with different levels of detail and structure.", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a FlatBuffers table. [Similarity] Both involve FlatBuffers verification logic, but the C code performs detailed field and vector checks while the Rust code only does a basic position check. [Knowledge Extraction] No full structural match due to different scopes and logic. Partial match exists in the general verification concept. API mappings found for field verification and vector verification patterns."}]
Unixcoder Score: -0.017177864909172058
--------------------------------------------------
C_Code: 
bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_I8, 1) &&
           VerifyField<uint8_t>(verifier, VT_U8, 1) &&
           VerifyField<int16_t>(verifier, VT_I16, 2) &&
           VerifyField<uint16_t>(verifier, VT_U16, 2) &&
           VerifyField<int32_t>(verifier, VT_I32, 4) &&
           VerifyField<uint32_t>(verifier, VT_U32, 4) &&
           VerifyField<int64_t>(verifier, VT_I64, 8) &&
           VerifyField<uint64_t>(verifier, VT_U64, 8) &&
           VerifyField<float>(verifier, VT_F32, 4) &&
           VerifyField<double>(verifier, VT_F64, 8) &&
           VerifyOffset(verifier, VT_V8) &&
           verifier.VerifyVector(v8()) &&
           VerifyOffset(verifier, VT_VF64) &&
           verifier.VerifyVector(vf64()) &&
           verifier.EndTable();
  }
Function: 
fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyTableStart(verifier)", "rust_api": "flatbuffers::Verifier", "mapping_type": "function", "description": "Table start verification", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<double>(verifier, VT_F64, 8)", "rust_api": "f64::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of 64-bit floating point field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<int32_t>(verifier, VT_I32, 4)", "rust_api": "i32::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of signed 32-bit integer field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<uint64_t>(verifier, VT_U64, 8)", "rust_api": "u64::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of unsigned 64-bit integer field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<int16_t>(verifier, VT_I16, 2)", "rust_api": "i16::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of signed 16-bit integer field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_fragment": "VerifyTableStart(verifier) &&\n           VerifyField<int8_t>(verifier, VT_I8, 1) &&\n           VerifyField<uint8_t>(verifier, VT_U8, 1) &&\n           VerifyField<int16_t>(verifier, VT_I16, 2) &&\n           VerifyField<uint16_t>(verifier, VT_U16, 2) &&\n           VerifyField<int32_t>(verifier, VT_I32, 4) &&\n           VerifyField<uint32_t>(verifier, VT_U32, 4) &&\n           VerifyField<int64_t>(verifier, VT_I64, 8) &&\n           VerifyField<uint64_t>(verifier, VT_U64, 8) &&\n           VerifyField<float>(verifier, VT_F32, 4) &&\n           VerifyField<double>(verifier, VT_F64, 8) &&\n           VerifyOffset(verifier, VT_V8) &&\n           verifier.VerifyVector(v8()) &&\n           VerifyOffset(verifier, VT_VF64) &&\n           verifier.VerifyVector(vf64()) &&\n           verifier.EndTable();", "rust_fragment": "use self::flatbuffers::Verifiable;\n    i8::run_verifier(v, pos)", "description": "Both perform verification of FlatBuffers data structures, though Rust version is specialized for i8 type.", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<int64_t>(verifier, VT_I64, 8)", "rust_api": "i64::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of signed 64-bit integer field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<float>(verifier, VT_F32, 4)", "rust_api": "f32::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of 32-bit floating point field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<uint16_t>(verifier, VT_U16, 2)", "rust_api": "u16::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of unsigned 16-bit integer field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_api": "i8::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of signed 8-bit integer field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "verifier.VerifyVector(v8())", "rust_api": "flatbuffers::Verifier", "mapping_type": "function", "description": "Verification of vector data", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "verifier.EndTable()", "rust_api": "flatbuffers::Verifier", "mapping_type": "function", "description": "End table verification", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<uint32_t>(verifier, VT_U32, 4)", "rust_api": "u32::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of unsigned 32-bit integer field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyOffset(verifier, VT_V8)", "rust_api": "flatbuffers::Verifier", "mapping_type": "function", "description": "Verification of vector offset", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3364_rank5.h", "source_rust_file": "Partial__Verify__idx3364_rank5.rs", "c_api": "VerifyField<uint8_t>(verifier, VT_U8, 1)", "rust_api": "u8::run_verifier(v, pos)", "mapping_type": "function", "description": "Verification of unsigned 8-bit integer field", "reasoning": "[Task Analysis] C code is a table verification function using FlatBuffers verifier, Rust code is a verifier runner for i8 type. [Similarity] Names don't match but both operate on FlatBuffers verification logic. [Knowledge Extraction] Found partial structural match in verification pattern and API mappings for verification operations."}]
Unixcoder Score: -0.018165703862905502
--------------------------------------------------
C_Code: 
bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_I8, 1) &&
           VerifyField<uint8_t>(verifier, VT_U8, 1) &&
           VerifyField<int16_t>(verifier, VT_I16, 2) &&
           VerifyField<uint16_t>(verifier, VT_U16, 2) &&
           VerifyField<int32_t>(verifier, VT_I32, 4) &&
           VerifyField<uint32_t>(verifier, VT_U32, 4) &&
           VerifyField<int64_t>(verifier, VT_I64, 8) &&
           VerifyField<uint64_t>(verifier, VT_U64, 8) &&
           VerifyField<float>(verifier, VT_F32, 4) &&
           VerifyField<double>(verifier, VT_F64, 8) &&
           VerifyOffset(verifier, VT_V8) &&
           verifier.VerifyVector(v8()) &&
           VerifyOffset(verifier, VT_VF64) &&
           verifier.VerifyVector(vf64()) &&
           verifier.EndTable();
  }
Function: 
fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<float>(verifier, VT_F32, 4)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for 32-bit float", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyOffset(verifier, VT_VF64)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers offset verification for vector of 64-bit floats", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<int32_t>(verifier, VT_I32, 4)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for signed 32-bit integer", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<int16_t>(verifier, VT_I16, 2)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for signed 16-bit integer", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<double>(verifier, VT_F64, 8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for 64-bit float", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_fragment": "VerifyTableStart(verifier) &&\n           VerifyField<int8_t>(verifier, VT_I8, 1) &&\n           VerifyField<uint8_t>(verifier, VT_U8, 1) &&\n           VerifyField<int16_t>(verifier, VT_I16, 2) &&\n           VerifyField<uint16_t>(verifier, VT_U16, 2) &&\n           VerifyField<int32_t>(verifier, VT_I32, 4) &&\n           VerifyField<uint32_t>(verifier, VT_U32, 4) &&\n           VerifyField<int64_t>(verifier, VT_I64, 8) &&\n           VerifyField<uint64_t>(verifier, VT_U64, 8) &&\n           VerifyField<float>(verifier, VT_F32, 4) &&\n           VerifyField<double>(verifier, VT_F64, 8) &&\n           VerifyOffset(verifier, VT_V8) &&\n           verifier.VerifyVector(v8()) &&\n           VerifyOffset(verifier, VT_VF64) &&\n           verifier.VerifyVector(vf64()) &&\n           verifier.EndTable();", "rust_fragment": "v.in_buffer::<Self>(pos)", "description": "Both perform verification of FlatBuffers structures, though at different levels (field-level in C vs buffer-level in Rust).", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<uint16_t>(verifier, VT_U16, 2)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for unsigned 16-bit integer", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<uint8_t>(verifier, VT_U8, 1)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for unsigned 8-bit integer", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyTableStart(verifier)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers table verification start", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<uint32_t>(verifier, VT_U32, 4)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for unsigned 32-bit integer", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<int64_t>(verifier, VT_I64, 8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for signed 64-bit integer", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "verifier.VerifyVector(v8())", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers vector verification for 8-bit values", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "verifier.EndTable()", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers table verification end", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<int8_t>(verifier, VT_I8, 1)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for signed 8-bit integer", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "verifier.VerifyVector(vf64())", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers vector verification for 64-bit floats", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyField<uint64_t>(verifier, VT_U64, 8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers field verification for unsigned 64-bit integer", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Verify__idx3715_rank2.h", "source_rust_file": "Partial__Verify__idx3715_rank2.rs", "c_api": "VerifyOffset(verifier, VT_V8)", "rust_api": "v.in_buffer::<Self>(pos)", "mapping_type": "function", "description": "FlatBuffers offset verification for vector of 8-bit values", "reasoning": "[Task Analysis] C function verifies a FlatBuffers table structure; Rust function runs a verifier on a buffer position. [Similarity] Names don't match but both involve FlatBuffers verification logic. [Knowledge Extraction] No full structural match due to different domains (verification vs buffer position check). Partial match in verification logic. API mappings found for FlatBuffers verification operations."}]
Unixcoder Score: -0.018831344321370125
--------------------------------------------------
