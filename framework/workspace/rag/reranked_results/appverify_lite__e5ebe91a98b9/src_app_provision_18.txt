C_Code: 
bool CheckPermission(uint64_t tokenId, rust::str permission)
{
    auto perm = std::string(permission);
    TypeATokenTypeEnum tokenType = AccessTokenKit::GetTokenTypeFlag(static_cast<AccessTokenID>(tokenId));
    if (tokenType == TOKEN_INVALID) {
        REQUEST_HILOGE("invalid token id");
        return false;
    }
    int result = AccessTokenKit::VerifyAccessToken(tokenId, perm);
    if (result != PERMISSION_GRANTED) {
        return false;
    }
    return true;
}
Function: 
pub(crate) fn check_permission(permission: &str) -> bool {
    let token_id = ipc::Skeleton::calling_full_token_id();
    ffi::CheckPermission(token_id, permission)
}
Unixcoder Score: 0.014350265264511108
--------------------------------------------------
C_Code: 
bool CheckPermission(uint64_t tokenId, rust::str permission)
{
    auto perm = std::string(permission);
    TypeATokenTypeEnum tokenType = AccessTokenKit::GetTokenTypeFlag(static_cast<AccessTokenID>(tokenId));
    if (tokenType == TOKEN_INVALID) {
        REQUEST_HILOGE("invalid token id");
        return false;
    }
    int result = AccessTokenKit::VerifyAccessToken(tokenId, perm);
    if (result != PERMISSION_GRANTED) {
        return false;
    }
    return true;
}
Function: 
pub(crate) fn check_permission(permission: &str) -> bool {
    let token_id = ipc::Skeleton::calling_full_token_id();
    ffi::CheckPermission(token_id, permission)
}
Unixcoder Score: 0.007760461885482073
--------------------------------------------------
C_Code: 
int32_t RdbServiceStub::OnGetDebugInfo(MessageParcel &data, MessageParcel &reply)
{
    RdbSyncerParam param;
    if (!ITypesUtil::Unmarshal(data, param)) {
        ZLOGE("Unmarshal failed");
        return IPC_STUB_INVALID_DATA_ERR;
    }
    std::map<std::string, RdbDebugInfo> debugInfo;
    auto status = GetDebugInfo(param, debugInfo);
    if (!ITypesUtil::Marshal(reply, status, debugInfo)) {
        ZLOGE("Marshal status:0x%{public}x", status);
        return IPC_STUB_WRITE_PARCEL_ERR;
    }
    return RDB_OK;
}
Function: 
fn deserialize(parcel: &mut MsgParcel) -> IpcResult<Self> {
        let interval = parcel.read::<i32>()?;
        let session_id = parcel.read::<i32>()?;
        let result = Self {
            interval,
            session_id,
        };
        Ok(result)
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Full__LoadSystemAbility__idx4859_rank3.c", "source_rust_file": "Full__LoadSystemAbility__idx4859_rank3.rs", "c_fragment": "if (!CheckInputSysAbilityId(systemAbilityId) || callback == nullptr) {\n        HILOGW(\"LoadSystemAbility SAId or callback invalid!\");\n        return INVALID_INPUT_PARA;\n    }", "rust_fragment": "info!(\"load system ability {}\", said);", "description": "Input validation and logging of invalid parameters", "reasoning": "[Task Analysis] C function handles system ability loading with input validation, profile lookup, and event handling; Rust function wraps the operation with logging and delegates to a lower-level function. [Similarity] Names don't match exactly but refer to the same concept (loading system ability with callback). [Knowledge Extraction] Full structural similarity in logic flow and purpose, with minor naming differences and Rust idioms like pub fn and info! macro. API mappings found for logging and function call delegation."}, {"knowledge_type": "Full", "source_c_file": "Full__LoadSystemAbility__idx4859_rank3.c", "source_rust_file": "Full__LoadSystemAbility__idx4859_rank3.rs", "reasoning": "[Task Analysis] C function handles system ability loading with input validation, profile lookup, and event handling; Rust function wraps the operation with logging and delegates to a lower-level function. [Similarity] Names don't match exactly but refer to the same concept (loading system ability with callback). [Knowledge Extraction] Full structural similarity in logic flow and purpose, with minor naming differences and Rust idioms like pub fn and info! macro. API mappings found for logging and function call delegation.", "description": "Full structural translation"}, {"knowledge_type": "Partial", "source_c_file": "Full__LoadSystemAbility__idx4859_rank3.c", "source_rust_file": "Full__LoadSystemAbility__idx4859_rank3.rs", "c_fragment": "return abilityStateScheduler_->HandleLoadAbilityEvent(loadRequestInfo);", "rust_fragment": "LoadSystemAbilityWithCallback(said, on_success, on_fail)", "description": "Delegation to lower-level system ability loading function", "reasoning": "[Task Analysis] C function handles system ability loading with input validation, profile lookup, and event handling; Rust function wraps the operation with logging and delegates to a lower-level function. [Similarity] Names don't match exactly but refer to the same concept (loading system ability with callback). [Knowledge Extraction] Full structural similarity in logic flow and purpose, with minor naming differences and Rust idioms like pub fn and info! macro. API mappings found for logging and function call delegation."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__LoadSystemAbility__idx4859_rank3.c", "source_rust_file": "Full__LoadSystemAbility__idx4859_rank3.rs", "c_api": "HILOGW", "rust_api": "info!", "mapping_type": "function", "description": "Logging with warning level", "reasoning": "[Task Analysis] C function handles system ability loading with input validation, profile lookup, and event handling; Rust function wraps the operation with logging and delegates to a lower-level function. [Similarity] Names don't match exactly but refer to the same concept (loading system ability with callback). [Knowledge Extraction] Full structural similarity in logic flow and purpose, with minor naming differences and Rust idioms like pub fn and info! macro. API mappings found for logging and function call delegation."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__LoadSystemAbility__idx4859_rank3.c", "source_rust_file": "Full__LoadSystemAbility__idx4859_rank3.rs", "c_api": "abilityStateScheduler_->HandleLoadAbilityEvent", "rust_api": "LoadSystemAbilityWithCallback", "mapping_type": "function", "description": "System ability loading with callback", "reasoning": "[Task Analysis] C function handles system ability loading with input validation, profile lookup, and event handling; Rust function wraps the operation with logging and delegates to a lower-level function. [Similarity] Names don't match exactly but refer to the same concept (loading system ability with callback). [Knowledge Extraction] Full structural similarity in logic flow and purpose, with minor naming differences and Rust idioms like pub fn and info! macro. API mappings found for logging and function call delegation."}]
Unixcoder Score: -0.003944577183574438
--------------------------------------------------
C_Code: 
TEST(UnredactedDebugFormatAPITest, LiteUnredactedDebugFormat) {
  protobuf_unittest::TestAllTypesLite message;
  EXPECT_EQ(UnredactedDebugFormatForTest(message), message.DebugString());
}
Function: 
fn test_debug_string() {
    let mut msg = proto!(TestAllTypesProto2 {
        optional_int32: 42,
        optional_string: "Hello World",
        optional_nested_enum: NestedEnumProto2::Bar,
        oneof_uint32: 452235,
        optional_nested_message: proto!(NestedMessageProto2 { bb: 100 }),
    });
    let mut repeated_string = msg.repeated_string_mut();
    repeated_string.push("Hello World");
    repeated_string.push("Hello World");
    repeated_string.push("Hello World");

    let mut msg_map = TestMapWithMessages::new();
    println!("EMPTY MSG: {:?}", msg_map); // Make sure that we can print an empty message. 
    msg_map.map_string_all_types_mut().insert("hello", msg.as_view());
    msg_map.map_string_all_types_mut().insert("fizz", msg.as_view());
    msg_map.map_string_all_types_mut().insert("boo", msg.as_view());

    println!("{:?}", msg_map);
    println!("{:?}", msg_map.as_view()); // Make sure that we can print as_view
    println!("{:?}", msg_map.as_mut()); // Make sure that we can print as_mut
    let golden = r#"12 {
  key: "hello"
  value {
    1: 42
    14: "Hello World"
    18 {
      1: 100
    }
    21: 2
    44: "Hello World"
    44: "Hello World"
    44: "Hello World"
    111: 452235
  }
}
12 {
  key: "fizz"
  value {
    1: 42
    14: "Hello World"
    18 {
      1: 100
    }
    21: 2
    44: "Hello World"
    44: "Hello World"
    44: "Hello World"
    111: 452235
  }
}
12 {
  key: "boo"
  value {
    1: 42
    14: "Hello World"
    18 {
      1: 100
    }
    21: 2
    44: "Hello World"
    44: "Hello World"
    44: "Hello World"
    111: 452235
  }
}
"#;
    // C strings are null terminated while Rust strings are not.
    let null_terminated_str = format!("{}\0", golden);
    assert_that!(format!("{:?}", msg_map), eq(null_terminated_str.as_str()));
}
Unixcoder Score: -0.0041786800138652325
--------------------------------------------------
C_Code: 
bool CheckPermission(uint64_t tokenId, rust::str permission)
{
    auto perm = std::string(permission);
    TypeATokenTypeEnum tokenType = AccessTokenKit::GetTokenTypeFlag(static_cast<AccessTokenID>(tokenId));
    if (tokenType == TOKEN_INVALID) {
        REQUEST_HILOGE("invalid token id");
        return false;
    }
    int result = AccessTokenKit::VerifyAccessToken(tokenId, perm);
    if (result != PERMISSION_GRANTED) {
        return false;
    }
    return true;
}
Function: 
pub(crate) fn check_permission(permission: &str) -> bool {
    let token_id = ipc::Skeleton::calling_full_token_id();
    ffi::CheckPermission(token_id, permission)
}
Unixcoder Score: -0.013758018612861633
--------------------------------------------------
C_Code: 
static upb_MessageValue lupb_tomsgval(lua_State* L, upb_CType type, int narg,
                                      int container, lupb_copy_t copy) {
  upb_MessageValue ret;
  switch (type) {
    case kUpb_CType_Int32:
    case kUpb_CType_Enum:
      ret.int32_val = lupb_checkint32(L, narg);
      break;
    case kUpb_CType_Int64:
      ret.int64_val = lupb_checkint64(L, narg);
      break;
    case kUpb_CType_UInt32:
      ret.uint32_val = lupb_checkuint32(L, narg);
      break;
    case kUpb_CType_UInt64:
      ret.uint64_val = lupb_checkuint64(L, narg);
      break;
    case kUpb_CType_Double:
      ret.double_val = lupb_checkdouble(L, narg);
      break;
    case kUpb_CType_Float:
      ret.float_val = lupb_checkfloat(L, narg);
      break;
    case kUpb_CType_Bool:
      ret.bool_val = lupb_checkbool(L, narg);
      break;
    case kUpb_CType_String:
    case kUpb_CType_Bytes: {
      size_t len;
      const char* ptr = lupb_checkstring(L, narg, &len);
      switch (copy) {
        case LUPB_COPY: {
          upb_Arena* arena = lupb_Arenaget(L, container);
          char* data = upb_Arena_Malloc(arena, len);
          memcpy(data, ptr, len);
          ret.str_val = upb_StringView_FromDataAndSize(data, len);
          break;
        }
        case LUPB_REF:
          ret.str_val = upb_StringView_FromDataAndSize(ptr, len);
          break;
      }
      break;
    }
    case kUpb_CType_Message:
      ret.msg_val = lupb_msg_check(L, narg);
      /* Typecheck message. */
      lua_getiuservalue(L, container, LUPB_MSGDEF_INDEX);
      lua_getiuservalue(L, narg, LUPB_MSGDEF_INDEX);
      luaL_argcheck(L, lua_rawequal(L, -1, -2), narg, "message type mismatch");
      lua_pop(L, 2);
      break;
  }
  return ret;
}
Function: 
pub unsafe fn alloc(&self, layout: Layout) -> &mut [MaybeUninit<u8>] {
        debug_assert!(layout.align() <= UPB_MALLOC_ALIGN);
        // SAFETY: `self.raw` is a valid UPB arena
        let ptr = unsafe { upb_Arena_Malloc(self.raw, layout.size()) };
        if ptr.is_null() {
            alloc::handle_alloc_error(layout);
        }

        // SAFETY:
        // - `upb_Arena_Malloc` promises that if the return pointer is non-null, it is
        //   dereferencable for `size` bytes and has an alignment of `UPB_MALLOC_ALIGN`
        //   until the arena is destroyed.
        // - `[MaybeUninit<u8>]` has no alignment requirement, and `ptr` is aligned to a
        //   `UPB_MALLOC_ALIGN` boundary.
        unsafe { slice::from_raw_parts_mut(ptr.cast(), layout.size()) }
    }
Unixcoder Score: -0.020344195887446404
--------------------------------------------------
C_Code: 
int32_t SystemAbilityManager::SendStrategy(int32_t type, std::vector<int32_t>& systemAbilityIds,
    int32_t level, std::string& action)
{
    HILOGD("SendStrategy begin");
    uint32_t accessToken = IPCSkeleton::GetCallingTokenID();
    Security::AccessToken::NativeTokenInfo nativeTokenInfo;
    int32_t result = Security::AccessToken::AccessTokenKit::GetNativeTokenInfo(accessToken, nativeTokenInfo);
    if (result != ERR_OK || nativeTokenInfo.processName != RESOURCE_SCHEDULE_PROCESS_NAME) {
        HILOGW("SendStrategy reject used by %{public}s", nativeTokenInfo.processName.c_str());
        return ERR_PERMISSION_DENIED;
    }

    for (auto saId : systemAbilityIds) {
        CommonSaProfile saProfile;
        if (!GetSaProfile(saId, saProfile)) {
            HILOGW("not found SA: %{public}d.", saId);
            return ERR_INVALID_VALUE;
        }
        auto procName = saProfile.process;
        sptr<ILocalAbilityManager> procObject =
            iface_cast<ILocalAbilityManager>(GetSystemProcess(procName));
        if (procObject == nullptr) {
            HILOGW("get process:%{public}s fail", Str16ToStr8(procName).c_str());
            return ERR_INVALID_VALUE;
        }
        procObject->SendStrategyToSA(type, saId, level, action);
    }
    return ERR_OK;
}
Function: 
pub fn send_strategy(s_type: i32, saids: Vec<i32>, level: i32, action: &str) -> i32 {
        let_cxx_string!(action = action);
        SendStrategy(s_type, saids, level, action)
    }
Unixcoder Score: -0.023611154407262802
--------------------------------------------------
C_Code: 
static upb_MessageValue lupb_tomsgval(lua_State* L, upb_CType type, int narg,
                                      int container, lupb_copy_t copy) {
  upb_MessageValue ret;
  switch (type) {
    case kUpb_CType_Int32:
    case kUpb_CType_Enum:
      ret.int32_val = lupb_checkint32(L, narg);
      break;
    case kUpb_CType_Int64:
      ret.int64_val = lupb_checkint64(L, narg);
      break;
    case kUpb_CType_UInt32:
      ret.uint32_val = lupb_checkuint32(L, narg);
      break;
    case kUpb_CType_UInt64:
      ret.uint64_val = lupb_checkuint64(L, narg);
      break;
    case kUpb_CType_Double:
      ret.double_val = lupb_checkdouble(L, narg);
      break;
    case kUpb_CType_Float:
      ret.float_val = lupb_checkfloat(L, narg);
      break;
    case kUpb_CType_Bool:
      ret.bool_val = lupb_checkbool(L, narg);
      break;
    case kUpb_CType_String:
    case kUpb_CType_Bytes: {
      size_t len;
      const char* ptr = lupb_checkstring(L, narg, &len);
      switch (copy) {
        case LUPB_COPY: {
          upb_Arena* arena = lupb_Arenaget(L, container);
          char* data = upb_Arena_Malloc(arena, len);
          memcpy(data, ptr, len);
          ret.str_val = upb_StringView_FromDataAndSize(data, len);
          break;
        }
        case LUPB_REF:
          ret.str_val = upb_StringView_FromDataAndSize(ptr, len);
          break;
      }
      break;
    }
    case kUpb_CType_Message:
      ret.msg_val = lupb_msg_check(L, narg);
      /* Typecheck message. */
      lua_getiuservalue(L, container, LUPB_MSGDEF_INDEX);
      lua_getiuservalue(L, narg, LUPB_MSGDEF_INDEX);
      luaL_argcheck(L, lua_rawequal(L, -1, -2), narg, "message type mismatch");
      lua_pop(L, 2);
      break;
  }
  return ret;
}
Function: 
pub unsafe fn alloc(&self, layout: Layout) -> &mut [MaybeUninit<u8>] {
        debug_assert!(layout.align() <= UPB_MALLOC_ALIGN);
        // SAFETY: `self.raw` is a valid UPB arena
        let ptr = unsafe { upb_Arena_Malloc(self.raw, layout.size()) };
        if ptr.is_null() {
            alloc::handle_alloc_error(layout);
        }

        // SAFETY:
        // - `upb_Arena_Malloc` promises that if the return pointer is non-null, it is
        //   dereferencable for `size` bytes and has an alignment of `UPB_MALLOC_ALIGN`
        //   until the arena is destroyed.
        // - `[MaybeUninit<u8>]` has no alignment requirement, and `ptr` is aligned to a
        //   `UPB_MALLOC_ALIGN` boundary.
        unsafe { slice::from_raw_parts_mut(ptr.cast(), layout.size()) }
    }
Unixcoder Score: -0.02384713478386402
--------------------------------------------------
C_Code: 
static upb_MessageValue lupb_tomsgval(lua_State* L, upb_CType type, int narg,
                                      int container, lupb_copy_t copy) {
  upb_MessageValue ret;
  switch (type) {
    case kUpb_CType_Int32:
    case kUpb_CType_Enum:
      ret.int32_val = lupb_checkint32(L, narg);
      break;
    case kUpb_CType_Int64:
      ret.int64_val = lupb_checkint64(L, narg);
      break;
    case kUpb_CType_UInt32:
      ret.uint32_val = lupb_checkuint32(L, narg);
      break;
    case kUpb_CType_UInt64:
      ret.uint64_val = lupb_checkuint64(L, narg);
      break;
    case kUpb_CType_Double:
      ret.double_val = lupb_checkdouble(L, narg);
      break;
    case kUpb_CType_Float:
      ret.float_val = lupb_checkfloat(L, narg);
      break;
    case kUpb_CType_Bool:
      ret.bool_val = lupb_checkbool(L, narg);
      break;
    case kUpb_CType_String:
    case kUpb_CType_Bytes: {
      size_t len;
      const char* ptr = lupb_checkstring(L, narg, &len);
      switch (copy) {
        case LUPB_COPY: {
          upb_Arena* arena = lupb_Arenaget(L, container);
          char* data = upb_Arena_Malloc(arena, len);
          memcpy(data, ptr, len);
          ret.str_val = upb_StringView_FromDataAndSize(data, len);
          break;
        }
        case LUPB_REF:
          ret.str_val = upb_StringView_FromDataAndSize(ptr, len);
          break;
      }
      break;
    }
    case kUpb_CType_Message:
      ret.msg_val = lupb_msg_check(L, narg);
      /* Typecheck message. */
      lua_getiuservalue(L, container, LUPB_MSGDEF_INDEX);
      lua_getiuservalue(L, narg, LUPB_MSGDEF_INDEX);
      luaL_argcheck(L, lua_rawequal(L, -1, -2), narg, "message type mismatch");
      lua_pop(L, 2);
      break;
  }
  return ret;
}
Function: 
pub unsafe fn resize(&self, ptr: *mut u8, old: Layout, new: Layout) -> &mut [MaybeUninit<u8>] {
        debug_assert!(new.align() <= UPB_MALLOC_ALIGN);
        // SAFETY:
        // - `self.raw` is a valid UPB arena
        // - `ptr` was allocated by a previous call to `alloc` or `realloc` as promised
        //   by the caller.
        let ptr = unsafe { upb_Arena_Realloc(self.raw, ptr, old.size(), new.size()) };
        if ptr.is_null() {
            alloc::handle_alloc_error(new);
        }

        // SAFETY:
        // - `upb_Arena_Realloc` promises that if the return pointer is non-null, it is
        //   dereferencable for the new `size` in bytes until the arena is destroyed.
        // - `[MaybeUninit<u8>]` has no alignment requirement, and `ptr` is aligned to a
        //   `UPB_MALLOC_ALIGN` boundary.
        unsafe { slice::from_raw_parts_mut(ptr.cast(), new.size()) }
    }
Unixcoder Score: -0.025144372135400772
--------------------------------------------------
C_Code: 
int32_t SystemAbilityManager::SendStrategy(int32_t type, std::vector<int32_t>& systemAbilityIds,
    int32_t level, std::string& action)
{
    HILOGD("SendStrategy begin");
    uint32_t accessToken = IPCSkeleton::GetCallingTokenID();
    Security::AccessToken::NativeTokenInfo nativeTokenInfo;
    int32_t result = Security::AccessToken::AccessTokenKit::GetNativeTokenInfo(accessToken, nativeTokenInfo);
    if (result != ERR_OK || nativeTokenInfo.processName != RESOURCE_SCHEDULE_PROCESS_NAME) {
        HILOGW("SendStrategy reject used by %{public}s", nativeTokenInfo.processName.c_str());
        return ERR_PERMISSION_DENIED;
    }

    for (auto saId : systemAbilityIds) {
        CommonSaProfile saProfile;
        if (!GetSaProfile(saId, saProfile)) {
            HILOGW("not found SA: %{public}d.", saId);
            return ERR_INVALID_VALUE;
        }
        auto procName = saProfile.process;
        sptr<ILocalAbilityManager> procObject =
            iface_cast<ILocalAbilityManager>(GetSystemProcess(procName));
        if (procObject == nullptr) {
            HILOGW("get process:%{public}s fail", Str16ToStr8(procName).c_str());
            return ERR_INVALID_VALUE;
        }
        procObject->SendStrategyToSA(type, saId, level, action);
    }
    return ERR_OK;
}
Function: 
pub fn send_strategy(s_type: i32, saids: Vec<i32>, level: i32, action: &str) -> i32 {
        let_cxx_string!(action = action);
        SendStrategy(s_type, saids, level, action)
    }
Unixcoder Score: -0.027540648356080055
--------------------------------------------------
