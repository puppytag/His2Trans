C_Code: 
struct debug_section_info
{
  /* Section file offset.  */
  off_t offset;
  /* Section size.  */
  size_t size;
  /* Section contents, after read from file.  */
  const unsigned char *data;
}
Function: 
crate struct BorrowData<'tcx> {
    /// Location where the borrow reservation starts.
    /// In many cases, this will be equal to the activation location but not always.
    crate reserve_location: Location,
    /// Location where the borrow is activated. None if this is not a
    /// 2-phase borrow.
    crate activation_location: Option<Location>,
    /// What kind of borrow this is
    crate kind: mir::BorrowKind,
    /// The region for which this borrow is live
    crate region: Region<'tcx>,
    /// Place from which we are borrowing
    crate borrowed_place: mir::Place<'tcx>,
    /// Place to which the borrow was stored
    crate assigned_place: mir::Place<'tcx>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__CheckDownloadFilePath__idx1181_rank4.c", "source_rust_file": "API_Mapping__CheckDownloadFilePath__idx1181_rank4.rs", "c_api": "CreateDirs(pathVec)", "rust_api": "fs::create_dir_all(self.dir.as_path())", "mapping_type": "function", "description": "Directory creation", "reasoning": "[Task Analysis] C function checks and standardizes a file path, validates it, and creates directories; Rust function creates a directory if it doesn't exist. [Similarity] No structural similarity in control flow or logic blocks. [Knowledge Extraction] No full match, no partial match, but there is a mapping between directory creation logic."}]
Unixcoder Score: 0.011446315795183182
--------------------------------------------------
C_Code: 
struct debug_section_info
{
  /* Section file offset.  */
  off_t offset;
  /* Section size.  */
  size_t size;
  /* Section contents, after read from file.  */
  const unsigned char *data;
}
Function: 
crate struct BorrowData<'tcx> {
    /// Location where the borrow reservation starts.
    /// In many cases, this will be equal to the activation location but not always.
    crate reserve_location: Location,
    /// Location where the borrow is activated. None if this is not a
    /// 2-phase borrow.
    crate activation_location: Option<Location>,
    /// What kind of borrow this is
    crate kind: mir::BorrowKind,
    /// The region for which this borrow is live
    crate region: Region<'tcx>,
    /// Place from which we are borrowing
    crate borrowed_place: mir::Place<'tcx>,
    /// Place to which the borrow was stored
    crate assigned_place: mir::Place<'tcx>,
}
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__CheckDownloadFilePath__idx1181_rank3.c", "source_rust_file": "Partial__CheckDownloadFilePath__idx1181_rank3.rs", "c_fragment": "if (!JsInitialize::CreateDirs(pathVec)) {\n        REQUEST_HILOGE(\"CreateDirs Err\");\n        errInfo = \"Parameter verification failed, this is fail saveas path\";\n        return false;\n    }", "rust_fragment": "if let Err(e) = fs::create_dir_all(self.dir.as_path()) {\n            error!(\"try create history dir error {}\", e);\n            false\n        } else {\n            true\n        }", "description": "Both perform directory creation with error handling and return false on failure.", "reasoning": "[Task Analysis] C function checks download path and creates directories; Rust function creates a directory. [Similarity] Both involve directory creation logic, but domains differ (path validation vs simple dir creation). [Knowledge Extraction] No full match due to domain mismatch and different scopes. Partial match found in directory creation pattern. API mapping identified for directory creation operation."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__CheckDownloadFilePath__idx1181_rank3.c", "source_rust_file": "Partial__CheckDownloadFilePath__idx1181_rank3.rs", "c_api": "JsInitialize::CreateDirs", "rust_api": "fs::create_dir_all", "mapping_type": "function", "description": "Directory creation with error handling", "reasoning": "[Task Analysis] C function checks download path and creates directories; Rust function creates a directory. [Similarity] Both involve directory creation logic, but domains differ (path validation vs simple dir creation). [Knowledge Extraction] No full match due to domain mismatch and different scopes. Partial match found in directory creation pattern. API mapping identified for directory creation operation."}]
Unixcoder Score: 0.008515742607414722
--------------------------------------------------
C_Code: 
bool CheckSystemHapPermission(void)
{
    auto tokenId = IPCSkeleton::GetCallingTokenID();
    ATokenTypeEnum tokenType = AccessTokenKit::GetTokenTypeFlag(tokenId);
    return (tokenType == ATokenTypeEnum::TOKEN_HAP) ? CheckSystemApp() : true;
}
Function: 
pub(crate) fn check_system_permission(attrs: &AssetMap) -> Result<()> {
    if attrs.get(&Tag::UserId).is_some() {
        if unsafe { !CheckSystemHapPermission() } {
            return log_throw_error!(ErrCode::NotSystemApplication, "[FATAL]The caller is not system application.");
        }

        let permission = CString::new("ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS").unwrap();
        if unsafe { !CheckPermission(permission.as_ptr()) } {
            return log_throw_error!(ErrCode::PermissionDenied, "[FATAL][SA]Permission check failed.");
        }

        let uid = Skeleton::calling_uid();
        let user_id = get_user_id(uid)?;
        if user_id > ROOT_USER_UPPERBOUND {
            return log_throw_error!(
                ErrCode::AccessDenied,
                "[FATAL]The caller user_id is: {}. Not in range[0, 99]",
                user_id
            );
        }
    }
    Ok(())
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__CheckFilePath__idx329_rank2.c", "source_rust_file": "Partial__CheckFilePath__idx329_rank2.rs", "c_api": "SysEventLog::SendSysEventLog", "rust_api": "sys_event!", "mapping_type": "function", "description": "System event logging for error reporting", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Names refer to different concepts (CheckFilePath vs open_task_files)] -> [Filter 2: Neither side is empty/trivial] -> [Filter 3: Not an FFI wrapper] -> [Filter 4: Semantic domains differ - C uses config/action-based logic with sys events, Rust uses file handling and error propagation] -> [Filter 5: Both are non-empty structs with fields] -> [Filter 6: Both are implementations, not definitions vs usages] -> [Full BLOCKERS: Domain mismatch, different names, no full structural match] -> [Partial: Some control flow patterns match (if/else, match)] -> [API Mappings: File operations, error handling, sys event logging, config access] -> [Extract API mappings based on semantic equivalence]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__CheckFilePath__idx329_rank2.c", "source_rust_file": "Partial__CheckFilePath__idx329_rank2.rs", "c_api": "JsTask::SetDirsPermission", "rust_api": "cvt_res_error!", "mapping_type": "function", "description": "Setting directory permissions with error handling", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Names refer to different concepts (CheckFilePath vs open_task_files)] -> [Filter 2: Neither side is empty/trivial] -> [Filter 3: Not an FFI wrapper] -> [Filter 4: Semantic domains differ - C uses config/action-based logic with sys events, Rust uses file handling and error propagation] -> [Filter 5: Both are non-empty structs with fields] -> [Filter 6: Both are implementations, not definitions vs usages] -> [Full BLOCKERS: Domain mismatch, different names, no full structural match] -> [Partial: Some control flow patterns match (if/else, match)] -> [API Mappings: File operations, error handling, sys event logging, config access] -> [Extract API mappings based on semantic equivalence]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__CheckFilePath__idx329_rank2.c", "source_rust_file": "Partial__CheckFilePath__idx329_rank2.rs", "c_api": "context->GetCacheDir()", "rust_api": "bundle_cache.get_value()", "mapping_type": "method", "description": "Retrieving cache directory or bundle name", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Names refer to different concepts (CheckFilePath vs open_task_files)] -> [Filter 2: Neither side is empty/trivial] -> [Filter 3: Not an FFI wrapper] -> [Filter 4: Semantic domains differ - C uses config/action-based logic with sys events, Rust uses file handling and error propagation] -> [Filter 5: Both are non-empty structs with fields] -> [Filter 6: Both are implementations, not definitions vs usages] -> [Full BLOCKERS: Domain mismatch, different names, no full structural match] -> [Partial: Some control flow patterns match (if/else, match)] -> [API Mappings: File operations, error handling, sys event logging, config access] -> [Extract API mappings based on semantic equivalence]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__CheckFilePath__idx329_rank2.c", "source_rust_file": "Partial__CheckFilePath__idx329_rank2.rs", "c_api": "CheckUploadFiles", "rust_api": "open_file_readwrite", "mapping_type": "function", "description": "File validation and access for upload action", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Names refer to different concepts (CheckFilePath vs open_task_files)] -> [Filter 2: Neither side is empty/trivial] -> [Filter 3: Not an FFI wrapper] -> [Filter 4: Semantic domains differ - C uses config/action-based logic with sys events, Rust uses file handling and error propagation] -> [Filter 5: Both are non-empty structs with fields] -> [Filter 6: Both are implementations, not definitions vs usages] -> [Full BLOCKERS: Domain mismatch, different names, no full structural match] -> [Partial: Some control flow patterns match (if/else, match)] -> [API Mappings: File operations, error handling, sys event logging, config access] -> [Extract API mappings based on semantic equivalence]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__CheckFilePath__idx329_rank2.c", "source_rust_file": "Partial__CheckFilePath__idx329_rank2.rs", "c_api": "CheckUploadBodyFiles", "rust_api": "open_file_readwrite", "mapping_type": "function", "description": "File validation for upload body files", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Names refer to different concepts (CheckFilePath vs open_task_files)] -> [Filter 2: Neither side is empty/trivial] -> [Filter 3: Not an FFI wrapper] -> [Filter 4: Semantic domains differ - C uses config/action-based logic with sys events, Rust uses file handling and error propagation] -> [Filter 5: Both are non-empty structs with fields] -> [Filter 6: Both are implementations, not definitions vs usages] -> [Full BLOCKERS: Domain mismatch, different names, no full structural match] -> [Partial: Some control flow patterns match (if/else, match)] -> [API Mappings: File operations, error handling, sys event logging, config access] -> [Extract API mappings based on semantic equivalence]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__CheckFilePath__idx329_rank2.c", "source_rust_file": "Partial__CheckFilePath__idx329_rank2.rs", "c_api": "CheckDownloadFile", "rust_api": "open_file_readonly", "mapping_type": "function", "description": "File validation and access for download action", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Names refer to different concepts (CheckFilePath vs open_task_files)] -> [Filter 2: Neither side is empty/trivial] -> [Filter 3: Not an FFI wrapper] -> [Filter 4: Semantic domains differ - C uses config/action-based logic with sys events, Rust uses file handling and error propagation] -> [Filter 5: Both are non-empty structs with fields] -> [Filter 6: Both are implementations, not definitions vs usages] -> [Full BLOCKERS: Domain mismatch, different names, no full structural match] -> [Partial: Some control flow patterns match (if/else, match)] -> [API Mappings: File operations, error handling, sys event logging, config access] -> [Extract API mappings based on semantic equivalence]"}, {"knowledge_type": "Partial", "source_c_file": "Partial__CheckFilePath__idx329_rank2.c", "source_rust_file": "Partial__CheckFilePath__idx329_rank2.rs", "c_fragment": "if (config.action == Action::DOWNLOAD) {\n        if (!CheckDownloadFile(context, config, error)) {\n            SysEventLog::SendSysEventLog(STATISTIC_EVENT, APP_ERROR_00, config.bundleName, \"\", error.errInfo);\n            return false;\n        }\n    } else {\n        if (!CheckUploadFiles(context, config, error)) {\n            SysEventLog::SendSysEventLog(STATISTIC_EVENT, APP_ERROR_01, config.bundleName, \"\", error.errInfo);\n            return false;\n        }\n        std::string filePath = context->GetCacheDir();\n        if (!CheckUploadBodyFiles(filePath, config, error)) {\n            SysEventLog::SendSysEventLog(STATISTIC_EVENT, APP_ERROR_02, config.bundleName, \"\", error.errInfo);\n            return false;\n        }\n    }", "rust_fragment": "match config.common_data.action {\n            Action::Upload => {\n                let file = if fs.is_user_file {\n                    match fs.fd {\n                        Some(fd) => unsafe { File::from_raw_fd(fd) },\n                        None => {\n                            error!(\"None user file failed - task_id: {}, idx: {}\", tid, idx);\n                            sys_event!(\n                                ExecFault,\n                                DfxCode::SA_ERROR_01,\n                                &format!(\"None user file failed - task_id: {}, idx: {}\", tid, idx)\n                            );\n                            return Err(ServiceError::IoError(io::Error::new(\n                                io::ErrorKind::Other,\n                                \"none user file\",\n                            )));\n                        }\n                    }\n                } else {\n                    let bundle_name = bundle_cache.get_value()?;\n                    open_file_readonly(uid, &bundle_name, &fs.path)\n                        .map_err(ServiceError::IoError)?\n                };\n                let size = cvt_res_error!(\n                    file.metadata()\n                        .map(|data| data.len())\n                        .map_err(ServiceError::IoError),\n                    \"Cannot get upload file's size - task_id: {}, idx: {}\",\n                    tid,\n                    idx\n                );\n                files.push(Arc::new(Mutex::new(file)));\n                debug!(\n                    \"Get file size succeed - task_id: {}, idx: {}, size: {}\",\n                    tid, idx, size\n                );\n                sizes.push(size as i64);\n            }\n            Action::Download => {\n                let file = if fs.is_user_file {\n                    match fs.fd {\n                        Some(fd) => unsafe { File::from_raw_fd(fd) },\n                        None => {\n                            error!(\"None user file failed - task_id: {}, idx: {}\", tid, idx);\n                            sys_event!(\n                                ExecFault,\n                                DfxCode::SA_ERROR_01,\n                                &format!(\"None user file failed - task_id: {}, idx: {}\", tid, idx)\n                            );\n                            return Err(ServiceError::IoError(io::Error::new(\n                                io::ErrorKind::Other,\n                                \"none user file\",\n                            )));\n                        }\n                    }\n                } else {\n                    let bundle_name = bundle_cache.get_value()?;\n                    open_file_readwrite(uid, &bundle_name, &fs.path)\n                        .map_err(ServiceError::IoError)?\n                };\n                files.push(Arc::new(Mutex::new(file)));\n                sizes.push(-1)\n            }\n            _ => unreachable!(\"Action::Any in open_task_files should never reach\"),\n        }", "description": "Both handle action-based logic (upload/download) with error handling and file operations.", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Names refer to different concepts (CheckFilePath vs open_task_files)] -> [Filter 2: Neither side is empty/trivial] -> [Filter 3: Not an FFI wrapper] -> [Filter 4: Semantic domains differ - C uses config/action-based logic with sys events, Rust uses file handling and error propagation] -> [Filter 5: Both are non-empty structs with fields] -> [Filter 6: Both are implementations, not definitions vs usages] -> [Full BLOCKERS: Domain mismatch, different names, no full structural match] -> [Partial: Some control flow patterns match (if/else, match)] -> [API Mappings: File operations, error handling, sys event logging, config access] -> [Extract API mappings based on semantic equivalence]"}]
Unixcoder Score: -0.02653866820037365
--------------------------------------------------
C_Code: 
static FT_Error
  fnt_face_get_dll_font( FNT_Face  face,
                         FT_Int    face_instance_index )
  {
    FT_Error         error;
    FT_Stream        stream = FT_FACE( face )->stream;
    FT_Memory        memory = FT_FACE( face )->memory;
    WinMZ_HeaderRec  mz_header;
    FT_Long          face_index;


    face->font = NULL;

    face_index = FT_ABS( face_instance_index ) & 0xFFFF;

    /* does it begin with an MZ header? */
    if ( FT_STREAM_SEEK( 0 )                                      ||
         FT_STREAM_READ_FIELDS( winmz_header_fields, &mz_header ) )
    {
      error = FT_ERR( Unknown_File_Format );
      goto Exit;
    }

    error = FT_ERR( Unknown_File_Format );
    if ( mz_header.magic == WINFNT_MZ_MAGIC )
    {
      /* yes, now look for an NE header in the file */
      WinNE_HeaderRec  ne_header;


      FT_TRACE2(( "MZ signature found\n" ));

      if ( FT_STREAM_SEEK( mz_header.lfanew )                       ||
           FT_STREAM_READ_FIELDS( winne_header_fields, &ne_header ) )
        goto Exit;

      error = FT_ERR( Unknown_File_Format );
      if ( ne_header.magic == WINFNT_NE_MAGIC )
      {
        /* good, now look into the resource table for each FNT resource */
        FT_ULong   res_offset  = mz_header.lfanew +
                                   ne_header.resource_tab_offset;
        FT_UShort  size_shift;
        FT_UShort  font_count  = 0;
        FT_ULong   font_offset = 0;


        FT_TRACE2(( "NE signature found\n" ));

        if ( FT_STREAM_SEEK( res_offset )                    ||
             FT_FRAME_ENTER( ne_header.rname_tab_offset -
                             ne_header.resource_tab_offset ) )
          goto Exit;

        size_shift = FT_GET_USHORT_LE();

        /* Microsoft's specification of the executable-file header format */
        /* for `New Executable' (NE) doesn't give a limit for the         */
        /* alignment shift count; however, in 1985, the year of the       */
        /* specification release, only 32bit values were supported, thus  */
        /* anything larger than 16 doesn't make sense in general, given   */
        /* that file offsets are 16bit values, shifted by the alignment   */
        /* shift count                                                    */
        if ( size_shift > 16 )
        {
          FT_TRACE2(( "invalid alignment shift count for resource data\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Exit1;
        }


        for (;;)
        {
          FT_UShort  type_id, count;


          type_id = FT_GET_USHORT_LE();
          if ( !type_id )
            break;

          count = FT_GET_USHORT_LE();

          FT_TRACE2(( type_id == 0x8007U ? "RT_FONTDIR count %hu\n" :
                      type_id == 0x8008U ? "RT_FONT count %hu\n" : "",
                                           count ));

          if ( type_id == 0x8008U )
          {
            font_count  = count;
            font_offset = FT_STREAM_POS() + 4 -
                          (FT_ULong)( stream->limit - stream->cursor );
            break;
          }

          stream->cursor += 4 + count * 12;
        }

        FT_FRAME_EXIT();

        if ( !font_count || !font_offset )
        {
          FT_TRACE2(( "this file doesn't contain any FNT resources\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Exit;
        }

        /* loading `winfnt_header_fields' needs at least 118 bytes;    */
        /* use this as a rough measure to check the expected font size */
        if ( font_count * 118UL > stream->size )
        {
          FT_TRACE2(( "invalid number of faces\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Exit;
        }

        face->root.num_faces = font_count;

        if ( face_instance_index < 0 )
          goto Exit;

        if ( face_index >= font_count )
        {
          error = FT_THROW( Invalid_Argument );
          goto Exit;
        }

        if ( FT_NEW( face->font ) )
          goto Exit;

        if ( FT_STREAM_SEEK( font_offset + (FT_ULong)face_index * 12 ) ||
             FT_FRAME_ENTER( 12 )                                      )
          goto Fail;

        face->font->offset   = (FT_ULong)FT_GET_USHORT_LE() << size_shift;
        face->font->fnt_size = (FT_ULong)FT_GET_USHORT_LE() << size_shift;

        stream->cursor += 8;

        FT_FRAME_EXIT();

        error = fnt_font_load( face->font, stream );
      }
      else if ( ne_header.magic == WINFNT_PE_MAGIC )
      {
        WinPE32_HeaderRec       pe32_header;
        WinPE32_SectionRec      pe32_section;
        WinPE_RsrcDirRec        root_dir, name_dir, lang_dir;
        WinPE_RsrcDirEntryRec   dir_entry1, dir_entry2, dir_entry3;
        WinPE_RsrcDataEntryRec  data_entry;

        FT_ULong   root_dir_offset, name_dir_offset, lang_dir_offset;
        FT_UShort  i, j, k;


        FT_TRACE2(( "PE signature found\n" ));

        if ( FT_STREAM_SEEK( mz_header.lfanew )                           ||
             FT_STREAM_READ_FIELDS( winpe32_header_fields, &pe32_header ) )
          goto Exit;

        FT_TRACE2(( "magic %04lx, machine %02x, number_of_sections %u, "
                    "size_of_optional_header %02x\n",
                    pe32_header.magic, pe32_header.machine,
                    pe32_header.number_of_sections,
                    pe32_header.size_of_optional_header ));
        FT_TRACE2(( "magic32 %02x, rsrc_virtual_address %04lx, "
                    "rsrc_size %04lx\n",
                    pe32_header.magic32, pe32_header.rsrc_virtual_address,
                    pe32_header.rsrc_size ));

        if ( pe32_header.magic != WINFNT_PE_MAGIC /* check full signature */ ||
             pe32_header.machine != 0x014C /* i386 */                        ||
             pe32_header.size_of_optional_header != 0xE0 /* FIXME */         ||
             pe32_header.magic32 != 0x10B                                    )
        {
          FT_TRACE2(( "this file has an invalid PE header\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Exit;
        }

        face->root.num_faces = 0;

        for ( i = 0; i < pe32_header.number_of_sections; i++ )
        {
          if ( FT_STREAM_READ_FIELDS( winpe32_section_fields,
                                      &pe32_section ) )
            goto Exit;

          FT_TRACE2(( "name %.8s, va %04lx, size %04lx, offset %04lx\n",
                      pe32_section.name, pe32_section.virtual_address,
                      pe32_section.size_of_raw_data,
                      pe32_section.pointer_to_raw_data ));

          if ( pe32_header.rsrc_virtual_address ==
                 pe32_section.virtual_address )
            goto Found_rsrc_section;
        }

        FT_TRACE2(( "this file doesn't contain any resources\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;

      Found_rsrc_section:
        FT_TRACE2(( "found resources section %.8s\n", pe32_section.name ));

        if ( FT_STREAM_SEEK( pe32_section.pointer_to_raw_data )        ||
             FT_STREAM_READ_FIELDS( winpe_rsrc_dir_fields, &root_dir ) )
          goto Exit;

        root_dir_offset = pe32_section.pointer_to_raw_data;

        for ( i = 0; i < root_dir.number_of_named_entries +
                           root_dir.number_of_id_entries; i++ )
        {
          if ( FT_STREAM_SEEK( root_dir_offset + 16 + i * 8 )      ||
               FT_STREAM_READ_FIELDS( winpe_rsrc_dir_entry_fields,
                                      &dir_entry1 )                )
            goto Exit;

          if ( !( dir_entry1.offset & 0x80000000UL ) /* DataIsDirectory */ )
          {
            error = FT_THROW( Invalid_File_Format );
            goto Exit;
          }

          dir_entry1.offset &= ~0x80000000UL;

          name_dir_offset = pe32_section.pointer_to_raw_data +
                            dir_entry1.offset;

          if ( FT_STREAM_SEEK( pe32_section.pointer_to_raw_data +
                               dir_entry1.offset )                       ||
               FT_STREAM_READ_FIELDS( winpe_rsrc_dir_fields, &name_dir ) )
            goto Exit;

          for ( j = 0; j < name_dir.number_of_named_entries +
                             name_dir.number_of_id_entries; j++ )
          {
            if ( FT_STREAM_SEEK( name_dir_offset + 16 + j * 8 )      ||
                 FT_STREAM_READ_FIELDS( winpe_rsrc_dir_entry_fields,
                                        &dir_entry2 )                )
              goto Exit;

            if ( !( dir_entry2.offset & 0x80000000UL ) /* DataIsDirectory */ )
            {
              error = FT_THROW( Invalid_File_Format );
              goto Exit;
            }

            dir_entry2.offset &= ~0x80000000UL;

            lang_dir_offset = pe32_section.pointer_to_raw_data +
                                dir_entry2.offset;

            if ( FT_STREAM_SEEK( pe32_section.pointer_to_raw_data +
                                   dir_entry2.offset )                     ||
                 FT_STREAM_READ_FIELDS( winpe_rsrc_dir_fields, &lang_dir ) )
              goto Exit;

            for ( k = 0; k < lang_dir.number_of_named_entries +
                               lang_dir.number_of_id_entries; k++ )
            {
              if ( FT_STREAM_SEEK( lang_dir_offset + 16 + k * 8 )      ||
                   FT_STREAM_READ_FIELDS( winpe_rsrc_dir_entry_fields,
                                          &dir_entry3 )                )
                goto Exit;

              if ( dir_entry2.offset & 0x80000000UL /* DataIsDirectory */ )
              {
                error = FT_THROW( Invalid_File_Format );
                goto Exit;
              }

              if ( dir_entry1.name == 8 /* RT_FONT */ )
              {
                if ( FT_STREAM_SEEK( root_dir_offset + dir_entry3.offset ) ||
                     FT_STREAM_READ_FIELDS( winpe_rsrc_data_entry_fields,
                                            &data_entry )                  )
                  goto Exit;

                FT_TRACE2(( "found font #%lu, offset %04lx, "
                            "size %04lx, cp %lu\n",
                            dir_entry2.name,
                            pe32_section.pointer_to_raw_data +
                              data_entry.offset_to_data -
                              pe32_section.virtual_address,
                            data_entry.size, data_entry.code_page ));

                if ( face_index == face->root.num_faces )
                {
                  if ( FT_NEW( face->font ) )
                    goto Exit;

                  face->font->offset   = pe32_section.pointer_to_raw_data +
                                           data_entry.offset_to_data -
                                           pe32_section.virtual_address;
                  face->font->fnt_size = data_entry.size;

                  error = fnt_font_load( face->font, stream );
                  if ( error )
                  {
                    FT_TRACE2(( "font #%lu load error 0x%x\n",
                                dir_entry2.name, error ));
                    goto Fail;
                  }
                  else
                    FT_TRACE2(( "font #%lu successfully loaded\n",
                                dir_entry2.name ));
                }

                face->root.num_faces++;
              }
            }
          }
        }
      }

      if ( !face->root.num_faces )
      {
        FT_TRACE2(( "this file doesn't contain any RT_FONT resources\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      if ( face_index >= face->root.num_faces )
      {
        error = FT_THROW( Invalid_Argument );
        goto Exit;
      }
    }

  Fail:
    if ( error )
      fnt_font_done( face );

  Exit:
    return error;

  Exit1:
    FT_FRAME_EXIT();
    goto Exit;
  }
Function: 
fn make_font_ref_internal<'a>(font_data: &'a [u8], index: u32) -> Result<FontRef<'a>, ReadError> {
    match FileRef::new(font_data) {
        Ok(file_ref) => match file_ref {
            FileRef::Font(font_ref) => {
                // Indices with the higher bits set are meaningful here and do not result in an
                // error, as they may refer to a named instance and are taken into account by the
                // Fontations typeface implementation,
                // compare `coordinates_for_shifted_named_instance_index()`.
                if index & 0xFFFF > 0 {
                    Err(ReadError::InvalidCollectionIndex(index))
                } else {
                    Ok(font_ref)
                }
            }
            FileRef::Collection(collection) => collection.get(index),
        },
        Err(e) => Err(e),
    }
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__UnMarshalFileSpec__idx326_rank3.c", "source_rust_file": "Partial__UnMarshalFileSpec__idx326_rank3.rs", "c_api": "data.ReadUint32()", "rust_api": "parcel.write(&(self.file_specs.len() as u32))?", "mapping_type": "function", "description": "Reading uint32 from parcel and writing length of file specs to parcel", "reasoning": "[Task Analysis] C function reads file specs from a parcel and populates a vector; Rust function serializes data to a parcel including file specs in a loop. [Similarity] The core logic of reading/writing file specs in a loop is present in both, but the overall task is different (deserialization vs serialization). [Knowledge Extraction] No full structural match due to different domains (read vs write), but partial matching fragments and API mappings found."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__UnMarshalFileSpec__idx326_rank3.c", "source_rust_file": "Partial__UnMarshalFileSpec__idx326_rank3.rs", "c_api": "info.files.push_back(file)", "rust_api": "parcel.write(&file_spec.path)?", "mapping_type": "function", "description": "Adding file spec to container in C and writing file spec fields to parcel in Rust", "reasoning": "[Task Analysis] C function reads file specs from a parcel and populates a vector; Rust function serializes data to a parcel including file specs in a loop. [Similarity] The core logic of reading/writing file specs in a loop is present in both, but the overall task is different (deserialization vs serialization). [Knowledge Extraction] No full structural match due to different domains (read vs write), but partial matching fragments and API mappings found."}, {"knowledge_type": "Partial", "source_c_file": "Partial__UnMarshalFileSpec__idx326_rank3.c", "source_rust_file": "Partial__UnMarshalFileSpec__idx326_rank3.rs", "c_fragment": "for (uint32_t i = 0; i < size; i++) {\n        FileSpec file;\n        file.name = data.ReadString();\n        file.uri = data.ReadString();\n        file.filename = data.ReadString();\n        file.type = data.ReadString();\n        info.files.push_back(file);\n    }", "rust_fragment": "parcel.write(&(self.file_specs.len() as u32))?;\n        for file_spec in &self.file_specs {\n            parcel.write(&file_spec.name)?;\n            parcel.write(&file_spec.path)?;\n            parcel.write(&file_spec.file_name)?;\n            parcel.write(&file_spec.mime_type)?;\n            parcel.write(&file_spec.is_user_file)?;\n            if file_spec.is_user_file {\n                let file = unsafe { File::from_raw_fd(file_spec.fd.unwrap()) };\n                parcel.write_file(file)?;\n            }\n        }", "description": "Loop over file specs and write each field to parcel in Rust, similar to reading and populating file specs in C.", "reasoning": "[Task Analysis] C function reads file specs from a parcel and populates a vector; Rust function serializes data to a parcel including file specs in a loop. [Similarity] The core logic of reading/writing file specs in a loop is present in both, but the overall task is different (deserialization vs serialization). [Knowledge Extraction] No full structural match due to different domains (read vs write), but partial matching fragments and API mappings found."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__UnMarshalFileSpec__idx326_rank3.c", "source_rust_file": "Partial__UnMarshalFileSpec__idx326_rank3.rs", "c_api": "data.ReadString()", "rust_api": "parcel.write(&file_spec.name)?", "mapping_type": "function", "description": "Reading string from parcel and writing string to parcel", "reasoning": "[Task Analysis] C function reads file specs from a parcel and populates a vector; Rust function serializes data to a parcel including file specs in a loop. [Similarity] The core logic of reading/writing file specs in a loop is present in both, but the overall task is different (deserialization vs serialization). [Knowledge Extraction] No full structural match due to different domains (read vs write), but partial matching fragments and API mappings found."}]
Unixcoder Score: -0.03657024726271629
--------------------------------------------------
C_Code: 
bool JsInitialize::GetFdDownload(const std::string &path, const Config &config, ExceptionError &error)
{
    // File is exist.
    if (JsInitialize::FindDir(path)) {
        if (config.firstInit && !config.overwrite) {
            error.code = config.version == Version::API10 ? E_FILE_IO : E_FILE_PATH;
            error.errInfo = "GetFd File exists and other error";
            SysEventLog::SendSysEventLog(STATISTIC_EVENT, APP_ERROR_00, config.bundleName, "", error.errInfo);
            return false;
        }
    }

    FILE *file = NULL;
    if (config.firstInit) {
        file = fopen(path.c_str(), "w+");
    } else {
        file = fopen(path.c_str(), "a+");
    }

    if (file == NULL) {
        error.code = E_FILE_IO;
        error.errInfo = "GetFd failed to open file errno " + std::to_string(errno);
        SysEventLog::SendSysEventLog(FAULT_EVENT, STANDARD_FAULT_00, config.bundleName, "", error.errInfo);
        return false;
    }

    int32_t ret = chmod(path.c_str(), PathUtils::WRITE_MODE);
    if (ret != 0) {
        REQUEST_HILOGE("download file chmod fail: %{public}d", ret);
        SysEventLog::SendSysEventLog(FAULT_EVENT, STANDARD_FAULT_01, config.bundleName, "", std::to_string(ret));
    };

    int32_t retClose = fclose(file);
    if (retClose != 0) {
        REQUEST_HILOGE("download fclose fail: %{public}d", ret);
        SysEventLog::SendSysEventLog(FAULT_EVENT, STANDARD_FAULT_02, config.bundleName, "", std::to_string(retClose));
    }
    return true;
}
Function: 
fn open_file_readwrite(uid: u64, bundle_name: &str, path: &str) -> io::Result<File> {
    Ok(cvt_res_error!(
        OpenOptions::new()
            .read(true)
            .append(true)
            .open(convert_path(uid, bundle_name, path)),
        "open_file_readwrite failed"
    ))
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__fs__read__idx143913_rank5.c", "source_rust_file": "API_Mapping__fs__read__idx143913_rank5.rs", "c_api": "SET_REQ_ERROR(req, GetLastError())", "rust_api": "assert_eq!(ret, 0)", "mapping_type": "function", "description": "Error handling for file read operation", "reasoning": "[FFI Check] -> The Rust code contains an FFI call to `uvll::fs_read` which is a wrapper around libuv's fs_read function. The C code also makes a direct Windows API call to `ReadFile`. Both are low-level system calls, but the Rust code is a higher-level wrapper. -> [Task Analysis] -> The C function `fs__read` is a low-level file reading implementation using Windows API, while the Rust function `read` is a wrapper that calls into a libuv FFI function. They are both performing the same high-level task (asynchronous file read) but with different underlying mechanisms. -> [Similarity] -> The C code has a direct Windows API call (`ReadFile`) and error handling logic, while the Rust code wraps a libuv FFI call (`uvll::fs_read`) with similar error handling. The control flow is conceptually similar, but the implementation details differ significantly due to platform abstraction and FFI boundaries. -> [Knowledge Extraction] -> Full classification is blocked due to FFI wrapper nature and domain mismatch (Windows API vs libuv FFI). However, there are API mappings between the file reading operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__fs__read__idx143913_rank5.c", "source_rust_file": "API_Mapping__fs__read__idx143913_rank5.rs", "c_api": "ReadFile(handle, buf, length, &bytes, overlapped_ptr)", "rust_api": "uvll::fs_read(loop_.native_handle(), self.native_handle(), fd, buf_ptr, len, offset, complete_cb_ptr)", "mapping_type": "function", "description": "Asynchronous file read operation", "reasoning": "[FFI Check] -> The Rust code contains an FFI call to `uvll::fs_read` which is a wrapper around libuv's fs_read function. The C code also makes a direct Windows API call to `ReadFile`. Both are low-level system calls, but the Rust code is a higher-level wrapper. -> [Task Analysis] -> The C function `fs__read` is a low-level file reading implementation using Windows API, while the Rust function `read` is a wrapper that calls into a libuv FFI function. They are both performing the same high-level task (asynchronous file read) but with different underlying mechanisms. -> [Similarity] -> The C code has a direct Windows API call (`ReadFile`) and error handling logic, while the Rust code wraps a libuv FFI call (`uvll::fs_read`) with similar error handling. The control flow is conceptually similar, but the implementation details differ significantly due to platform abstraction and FFI boundaries. -> [Knowledge Extraction] -> Full classification is blocked due to FFI wrapper nature and domain mismatch (Windows API vs libuv FFI). However, there are API mappings between the file reading operations and error handling patterns."}]
Unixcoder Score: -0.042961977422237396
--------------------------------------------------
C_Code: 
bool CloudServiceImpl::UpdateSchema(int32_t user, CloudSyncScene scene)
{
    auto [status, cloudInfo] = GetCloudInfo(user);
    if (status != SUCCESS) {
        Report(GetDfxFaultType(scene), Fault::CSF_APP_SCHEMA, "", "UpdateSchema ret=" + std::to_string(status));
        return false;
    }
    auto keys = cloudInfo.GetSchemaKey();
    for (const auto &[bundle, key] : keys) {
        HapInfo hapInfo{ .user = user, .instIndex = 0, .bundleName = bundle };
        auto appInfoOpt = cloudInfo.GetAppInfo(bundle);
        if (appInfoOpt.has_value()) {
            const CloudInfo::AppInfo &appInfo = appInfoOpt.value();
            hapInfo.instIndex = appInfo.instanceId;
        }

        SchemaMeta schemaMeta;
        std::tie(status, schemaMeta) = GetSchemaFromHap(hapInfo);
        if (status != SUCCESS) {
            std::tie(status, schemaMeta) = GetAppSchemaFromServer(user, bundle);
        }
        if (status == NOT_SUPPORT) {
            ZLOGW("app not support, del cloudInfo! user:%{public}d, bundleName:%{public}s", user, bundle.c_str());
            MetaDataManager::GetInstance().DelMeta(cloudInfo.GetKey(), true);
            return false;
        }
        if (status != SUCCESS) {
            continue;
        }
        SchemaMeta oldMeta;
        if (MetaDataManager::GetInstance().LoadMeta(key, oldMeta, true)) {
            UpgradeSchemaMeta(user, oldMeta);
            UpdateClearWaterMark(hapInfo, schemaMeta, oldMeta);
        }
        if (oldMeta != schemaMeta) {
            MetaDataManager::GetInstance().SaveMeta(key, schemaMeta, true);
        }
    }
    return true;
}
Function: 
pub(crate) fn get_app_schema(
        &mut self,
        user_id: i32,
        bundle_name: &str,
    ) -> ConnectResult<RwLockReadGuard<Schema>> {
        self.infos.entry(user_id).or_default();
        let infos = self.infos.get_mut(&user_id).unwrap();

        let mut lock = infos.app_schema.write().unwrap();

        let mut msg_parcel = MsgParcel::new();

        msg_parcel
            .write_string16(bundle_name)
            .map_err(|_| Error::WriteMsgParcelFailed)?;

        let function_number = GetAppSchema as u32;
        let remote_obj = self
            .remote_obj
            .clone()
            .ok_or(Error::CreateMsgParcelFailed)?;
        let mut receive = remote_obj
            .send_request(function_number, &mut msg_parcel)
            .map_err(|_| Error::SendRequestFailed)?;

        lock.read(&mut receive)?;

        drop(lock);

        Ok(infos.app_schema.read().unwrap())
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.rs", "c_api": "if (status != SUCCESS) { return { status, schemaMeta }; }", "rust_api": "map_err(|_| Error::WriteMsgParcelFailed)?", "mapping_type": "pattern", "description": "Early return on error condition", "reasoning": "[Task Analysis] C function handles schema metadata retrieval with multiple conditional checks and fallbacks; Rust function performs IPC communication to fetch app schema. [Similarity] Names don't match but both involve retrieving schema data. [Knowledge Extraction] No full structural match due to different domains (metadata management vs IPC communication). However, there are API mappings related to schema retrieval and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.rs", "c_api": "if (status != SUCCESS) { return { status, schemaMeta }; }", "rust_api": "map_err(|_| Error::SendRequestFailed)?", "mapping_type": "pattern", "description": "Error propagation on failed operation", "reasoning": "[Task Analysis] C function handles schema metadata retrieval with multiple conditional checks and fallbacks; Rust function performs IPC communication to fetch app schema. [Similarity] Names don't match but both involve retrieving schema data. [Knowledge Extraction] No full structural match due to different domains (metadata management vs IPC communication). However, there are API mappings related to schema retrieval and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.rs", "c_api": "return { status, schemaMeta };", "rust_api": "Ok(infos.app_schema.read().unwrap())", "mapping_type": "pattern", "description": "Return value pattern for successful operation", "reasoning": "[Task Analysis] C function handles schema metadata retrieval with multiple conditional checks and fallbacks; Rust function performs IPC communication to fetch app schema. [Similarity] Names don't match but both involve retrieving schema data. [Knowledge Extraction] No full structural match due to different domains (metadata management vs IPC communication). However, there are API mappings related to schema retrieval and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.rs", "c_api": "if (status == SUCCESS) { MetaDataManager::GetInstance().SaveMeta(schemaKey, schemaMeta, true); return { status, schemaMeta }; }", "rust_api": "lock.read(&mut receive)?;", "mapping_type": "pattern", "description": "Successful data read and processing", "reasoning": "[Task Analysis] C function handles schema metadata retrieval with multiple conditional checks and fallbacks; Rust function performs IPC communication to fetch app schema. [Similarity] Names don't match but both involve retrieving schema data. [Knowledge Extraction] No full structural match due to different domains (metadata management vs IPC communication). However, there are API mappings related to schema retrieval and error handling patterns."}]
Unixcoder Score: -0.0442124642431736
--------------------------------------------------
C_Code: 
bool JsInitialize::GetFdDownload(const std::string &path, const Config &config, ExceptionError &error)
{
    // File is exist.
    if (JsInitialize::FindDir(path)) {
        if (config.firstInit && !config.overwrite) {
            error.code = config.version == Version::API10 ? E_FILE_IO : E_FILE_PATH;
            error.errInfo = "GetFd File exists and other error";
            SysEventLog::SendSysEventLog(STATISTIC_EVENT, APP_ERROR_00, config.bundleName, "", error.errInfo);
            return false;
        }
    }

    FILE *file = NULL;
    if (config.firstInit) {
        file = fopen(path.c_str(), "w+");
    } else {
        file = fopen(path.c_str(), "a+");
    }

    if (file == NULL) {
        error.code = E_FILE_IO;
        error.errInfo = "GetFd failed to open file errno " + std::to_string(errno);
        SysEventLog::SendSysEventLog(FAULT_EVENT, STANDARD_FAULT_00, config.bundleName, "", error.errInfo);
        return false;
    }

    int32_t ret = chmod(path.c_str(), PathUtils::WRITE_MODE);
    if (ret != 0) {
        REQUEST_HILOGE("download file chmod fail: %{public}d", ret);
        SysEventLog::SendSysEventLog(FAULT_EVENT, STANDARD_FAULT_01, config.bundleName, "", std::to_string(ret));
    };

    int32_t retClose = fclose(file);
    if (retClose != 0) {
        REQUEST_HILOGE("download fclose fail: %{public}d", ret);
        SysEventLog::SendSysEventLog(FAULT_EVENT, STANDARD_FAULT_02, config.bundleName, "", std::to_string(retClose));
    }
    return true;
}
Function: 
fn create_file(path: &str) -> File {
    File::options()
        .read(true)
        .write(true)
        .truncate(true)
        .create(true)
        .open(path)
        .unwrap()
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__LLVMRustDIBuilderCreateFile__idx18158_rank1.c", "source_rust_file": "API_Mapping__LLVMRustDIBuilderCreateFile__idx18158_rank1.rs", "c_api": "LLVMRustDIBuilderCreateFile", "rust_api": "llvm::LLVMRustDIBuilderCreateFile", "mapping_type": "function", "description": "Create DIFile metadata object in LLVM debug info", "reasoning": "[FFI Check] -> The Rust code contains a direct FFI call to `llvm::LLVMRustDIBuilderCreateFile`, which is a wrapper around the LLVM C API. This matches the FFI wrapper filter (Filter 3) -> [Task Analysis] -> The C function is a direct LLVM C API wrapper for creating a DIFile metadata object, while the Rust function is a higher-level wrapper that prepares arguments and calls the FFI function. The core logic is not the same, as the Rust function does extensive path manipulation and hash processing before calling the FFI -> [Similarity] -> The functions are not structurally similar as a whole, and the Rust side is not just a thin wrapper around the C logic. The C function is a direct API binding, while the Rust function is a complex logic wrapper -> [Knowledge Extraction] -> There is a clear API mapping between the FFI call in Rust and the C function, but no structural similarity or partial match due to domain mismatch and implementation differences."}]
Unixcoder Score: -0.04428793489933014
--------------------------------------------------
C_Code: 
int32_t CloudServiceImpl::SetCloudStrategy(Strategy strategy, const std::vector<CommonType::Value> &values)
{
    if (strategy >= Strategy::STRATEGY_BUTT) {
        ZLOGE("invalid strategy:%{public}d, size:%{public}zu", strategy, values.size());
        return INVALID_ARGUMENT;
    }
    auto tokenId = IPCSkeleton::GetCallingTokenID();
    auto hapInfo = GetHapInfo(tokenId);
    if (hapInfo.bundleName.empty() || hapInfo.user == INVALID_USER_ID || hapInfo.user == 0) {
        ZLOGE("invalid, user:%{public}d, bundleName:%{public}s, strategy:%{public}d, values size:%{public}zu",
            hapInfo.user, hapInfo.bundleName.c_str(), strategy, values.size());
        return ERROR;
    }
    return STRATEGY_SAVERS[strategy](values, hapInfo);
}
Function: 
fn from(value: ipc_conn::CloudData) -> Self {
        let mut vec = vec![];
        for v in value.values.0 {
            vec.push(v);
        }
        CloudDbData {
            next_cursor: value.next_cursor,
            has_more: value.has_more,
            values: vec,
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__GetSharingHandle__idx5113_rank5.c", "source_rust_file": "Partial__GetSharingHandle__idx5113_rank5.rs", "c_fragment": "auto handle = instance->ConnectSharingCenter(hapInfo.user, hapInfo.bundleName);\n    return handle;", "rust_fragment": "let subscription = Subscription::default();\n        subscription.subscribe(&self.remote_obj, expiration, bundle_name, databases)", "description": "Both retrieve or create a handle/object and return it, though with different logic and domains.", "reasoning": "[Task Analysis] C function returns a shared_ptr from a method call, Rust function performs subscription logic with similar intent. [Similarity] Names don't match but both involve retrieving/creating a handle/object. [Knowledge Extraction] No full structural match due to different domains (connection vs subscription), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetSharingHandle__idx5113_rank5.c", "source_rust_file": "Partial__GetSharingHandle__idx5113_rank5.rs", "c_api": "std::shared_ptr<SharingCenter>", "rust_api": "SubscriptionResult", "mapping_type": "type", "description": "Both represent a handle to a resource or object", "reasoning": "[Task Analysis] C function returns a shared_ptr from a method call, Rust function performs subscription logic with similar intent. [Similarity] Names don't match but both involve retrieving/creating a handle/object. [Knowledge Extraction] No full structural match due to different domains (connection vs subscription), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetSharingHandle__idx5113_rank5.c", "source_rust_file": "Partial__GetSharingHandle__idx5113_rank5.rs", "c_api": "instance->ConnectSharingCenter", "rust_api": "subscription.subscribe", "mapping_type": "function", "description": "Handle/connection creation and subscription logic", "reasoning": "[Task Analysis] C function returns a shared_ptr from a method call, Rust function performs subscription logic with similar intent. [Similarity] Names don't match but both involve retrieving/creating a handle/object. [Knowledge Extraction] No full structural match due to different domains (connection vs subscription), but partial fragments and API mappings can be extracted."}]
Unixcoder Score: -0.04457999765872955
--------------------------------------------------
C_Code: 
rust::string GetCallingBundle(rust::u64 tokenId)
{
    auto tokenType = AccessTokenKit::GetTokenTypeFlag(static_cast<uint32_t>(tokenId));
    if (tokenType != TOKEN_HAP) {
        REQUEST_HILOGE("invalid token");
        return rust::string("");
    }
    HapTokenInfo info;
    int ret = AccessTokenKit::GetHapTokenInfo(tokenId, info);
    if (ret != 0) {
        REQUEST_HILOGE("failed to get hap info, ret: %{public}d", ret);
        return rust::string("");
    }
    return rust::string(info.bundleName);
}
Function: 
pub(crate) fn query_calling_bundle() -> String {
    let token_id = ipc::Skeleton::calling_full_token_id();
    ffi::GetCallingBundle(token_id)
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetCallingBundle__idx911_rank1.c", "source_rust_file": "API_Mapping__GetCallingBundle__idx911_rank1.rs", "c_api": "AccessTokenKit::GetHapTokenInfo", "rust_api": "ffi::GetCallingBundle", "mapping_type": "function", "description": "Retrieval of HAP token info via FFI call", "reasoning": "[Task Analysis] C function `GetCallingBundle` retrieves bundle name from token ID, with validation and error handling. Rust function `query_calling_bundle` calls an FFI function `GetCallingBundle` after getting token ID. [Similarity] The overall task is the same (retrieving bundle name), but the C function has complex logic (validation, error logging) while Rust just delegates. [Knowledge Extraction] No full structural match due to different scopes and logic. However, there's a clear API mapping between C's `AccessTokenKit::GetTokenTypeFlag` and Rust's `ipc::Skeleton::calling_full_token_id()` as both retrieve token information. Also, C's `AccessTokenKit::GetHapTokenInfo` and Rust's `ffi::GetCallingBundle` both handle token info retrieval, even though they differ in implementation details. No partial match due to domain mismatch (C has validation/logic, Rust just calls FFI)."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetCallingBundle__idx911_rank1.c", "source_rust_file": "API_Mapping__GetCallingBundle__idx911_rank1.rs", "c_api": "AccessTokenKit::GetTokenTypeFlag", "rust_api": "ipc::Skeleton::calling_full_token_id", "mapping_type": "function", "description": "Token type validation and token ID retrieval", "reasoning": "[Task Analysis] C function `GetCallingBundle` retrieves bundle name from token ID, with validation and error handling. Rust function `query_calling_bundle` calls an FFI function `GetCallingBundle` after getting token ID. [Similarity] The overall task is the same (retrieving bundle name), but the C function has complex logic (validation, error logging) while Rust just delegates. [Knowledge Extraction] No full structural match due to different scopes and logic. However, there's a clear API mapping between C's `AccessTokenKit::GetTokenTypeFlag` and Rust's `ipc::Skeleton::calling_full_token_id()` as both retrieve token information. Also, C's `AccessTokenKit::GetHapTokenInfo` and Rust's `ffi::GetCallingBundle` both handle token info retrieval, even though they differ in implementation details. No partial match due to domain mismatch (C has validation/logic, Rust just calls FFI)."}]
Unixcoder Score: -0.04800445958971977
--------------------------------------------------
C_Code: 
std::pair<int32_t, SchemaMeta> CloudServiceImpl::GetSchemaFromHap(const HapInfo &hapInfo)
{
    SchemaMeta schemaMeta;
    AppInfo info{ .bundleName = hapInfo.bundleName, .userId = hapInfo.user, .appIndex = hapInfo.instIndex };
    auto schemas = GetSchemaHelper::GetInstance().GetSchemaFromHap(CLOUD_SCHEMA, info);
    for (auto &schema : schemas) {
        if (schemaMeta.Unmarshall(schema)) {
            return { SUCCESS, schemaMeta };
        }
    }
    ZLOGD("get schema from hap failed, bundleName:%{public}s", hapInfo.bundleName.c_str());
    return { ERROR, schemaMeta };
}
Function: 
pub(crate) fn get_app_schema(
        &mut self,
        user_id: i32,
        bundle_name: &str,
    ) -> ConnectResult<RwLockReadGuard<Schema>> {
        self.infos.entry(user_id).or_default();
        let infos = self.infos.get_mut(&user_id).unwrap();

        let mut lock = infos.app_schema.write().unwrap();

        let mut msg_parcel = MsgParcel::new();

        msg_parcel
            .write_string16(bundle_name)
            .map_err(|_| Error::WriteMsgParcelFailed)?;

        let function_number = GetAppSchema as u32;
        let remote_obj = self
            .remote_obj
            .clone()
            .ok_or(Error::CreateMsgParcelFailed)?;
        let mut receive = remote_obj
            .send_request(function_number, &mut msg_parcel)
            .map_err(|_| Error::SendRequestFailed)?;

        lock.read(&mut receive)?;

        drop(lock);

        Ok(infos.app_schema.read().unwrap())
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__GetSchemaFromHap__idx5112_rank4.c", "source_rust_file": "Partial__GetSchemaFromHap__idx5112_rank4.rs", "c_fragment": "for (auto &schema : schemas) {\n        if (schemaMeta.Unmarshall(schema)) {\n            return { SUCCESS, schemaMeta };\n        }\n    }", "rust_fragment": "lock.read(&mut receive)?;", "description": "Both perform iteration over data and conditional return on success.", "reasoning": "[Task Analysis] C function returns a pair of error code and schema meta; Rust function performs IPC to fetch schema. [Similarity] Names don't match but both perform schema retrieval logic. [Knowledge Extraction] No full structural match due to different domains (C: local schema lookup vs Rust: remote IPC). Partial match in loop logic and error handling patterns. API mappings found for schema retrieval and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetSchemaFromHap__idx5112_rank4.c", "source_rust_file": "Partial__GetSchemaFromHap__idx5112_rank4.rs", "c_api": "schemaMeta.Unmarshall(schema)", "rust_api": "lock.read(&mut receive)?;", "mapping_type": "function", "description": "Data unmarshalling from serialized format", "reasoning": "[Task Analysis] C function returns a pair of error code and schema meta; Rust function performs IPC to fetch schema. [Similarity] Names don't match but both perform schema retrieval logic. [Knowledge Extraction] No full structural match due to different domains (C: local schema lookup vs Rust: remote IPC). Partial match in loop logic and error handling patterns. API mappings found for schema retrieval and error handling."}, {"knowledge_type": "Partial", "source_c_file": "Partial__GetSchemaFromHap__idx5112_rank4.c", "source_rust_file": "Partial__GetSchemaFromHap__idx5112_rank4.rs", "c_fragment": "ZLOGD(\"get schema from hap failed, bundleName:%{public}s\", hapInfo.bundleName.c_str());\n    return { ERROR, schemaMeta };", "rust_fragment": "map_err(|_| Error::WriteMsgParcelFailed)?;\n        let function_number = GetAppSchema as u32;\n        let remote_obj = self\n            .remote_obj\n            .clone()\n            .ok_or(Error::CreateMsgParcelFailed)?;\n        let mut receive = remote_obj\n            .send_request(function_number, &mut msg_parcel)\n            .map_err(|_| Error::SendRequestFailed)?;", "description": "Both handle error conditions and return early on failure.", "reasoning": "[Task Analysis] C function returns a pair of error code and schema meta; Rust function performs IPC to fetch schema. [Similarity] Names don't match but both perform schema retrieval logic. [Knowledge Extraction] No full structural match due to different domains (C: local schema lookup vs Rust: remote IPC). Partial match in loop logic and error handling patterns. API mappings found for schema retrieval and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetSchemaFromHap__idx5112_rank4.c", "source_rust_file": "Partial__GetSchemaFromHap__idx5112_rank4.rs", "c_api": "GetSchemaHelper::GetInstance().GetSchemaFromHap(CLOUD_SCHEMA, info)", "rust_api": "remote_obj.send_request(function_number, &mut msg_parcel)", "mapping_type": "function", "description": "Retrieving schema data from source", "reasoning": "[Task Analysis] C function returns a pair of error code and schema meta; Rust function performs IPC to fetch schema. [Similarity] Names don't match but both perform schema retrieval logic. [Knowledge Extraction] No full structural match due to different domains (C: local schema lookup vs Rust: remote IPC). Partial match in loop logic and error handling patterns. API mappings found for schema retrieval and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetSchemaFromHap__idx5112_rank4.c", "source_rust_file": "Partial__GetSchemaFromHap__idx5112_rank4.rs", "c_api": "return { ERROR, schemaMeta };", "rust_api": "map_err(|_| Error::WriteMsgParcelFailed)?", "mapping_type": "pattern", "description": "Error propagation and return", "reasoning": "[Task Analysis] C function returns a pair of error code and schema meta; Rust function performs IPC to fetch schema. [Similarity] Names don't match but both perform schema retrieval logic. [Knowledge Extraction] No full structural match due to different domains (C: local schema lookup vs Rust: remote IPC). Partial match in loop logic and error handling patterns. API mappings found for schema retrieval and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetSchemaFromHap__idx5112_rank4.c", "source_rust_file": "Partial__GetSchemaFromHap__idx5112_rank4.rs", "c_api": "return { SUCCESS, schemaMeta };", "rust_api": "Ok(infos.app_schema.read().unwrap())", "mapping_type": "pattern", "description": "Successful return of result", "reasoning": "[Task Analysis] C function returns a pair of error code and schema meta; Rust function performs IPC to fetch schema. [Similarity] Names don't match but both perform schema retrieval logic. [Knowledge Extraction] No full structural match due to different domains (C: local schema lookup vs Rust: remote IPC). Partial match in loop logic and error handling patterns. API mappings found for schema retrieval and error handling."}]
Unixcoder Score: -0.05091085284948349
--------------------------------------------------
