C_Code: 
int32_t CloudServiceImpl::SetCloudStrategy(Strategy strategy, const std::vector<CommonType::Value> &values)
{
    if (strategy >= Strategy::STRATEGY_BUTT) {
        ZLOGE("invalid strategy:%{public}d, size:%{public}zu", strategy, values.size());
        return INVALID_ARGUMENT;
    }
    auto tokenId = IPCSkeleton::GetCallingTokenID();
    auto hapInfo = GetHapInfo(tokenId);
    if (hapInfo.bundleName.empty() || hapInfo.user == INVALID_USER_ID || hapInfo.user == 0) {
        ZLOGE("invalid, user:%{public}d, bundleName:%{public}s, strategy:%{public}d, values size:%{public}zu",
            hapInfo.user, hapInfo.bundleName.c_str(), strategy, values.size());
        return ERROR;
    }
    return STRATEGY_SAVERS[strategy](values, hapInfo);
}
Function: 
fn from(value: ipc_conn::CloudData) -> Self {
        let mut vec = vec![];
        for v in value.values.0 {
            vec.push(v);
        }
        CloudDbData {
            next_cursor: value.next_cursor,
            has_more: value.has_more,
            values: vec,
        }
    }
Unixcoder Score: 0.059672530740499496
--------------------------------------------------
C_Code: 
struct MapInfo {
    uint64_t startAddr; // 起始地址
    uint64_t endAddr;   // 结束地址
    char read;
    char write;
    char execute;
    char shared;
    uint64_t offset;    // 文件偏移量
    string dev;       // 设备号
    string inode;     // inode 号
    std::string pathname;  // 文件路径
}
Function: 
struct VmStruct {
    name:   String,
    start:  u64,
    end:    u64,
    off:    u64,
    perm:   String,
    dev:    String,
    inode:  u64,
    counts: usize,
    value:  HashMap<String, u64>
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "insertValues.PutInt(\"reason\", taskInfo->commonData.reason)", "rust_api": "TaskInfo::from_c_struct(c_task_info)", "mapping_type": "function", "description": "Data field assignment and retrieval", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "insertValues.PutLong(\"tries\", taskInfo->commonData.tries)", "rust_api": "TaskInfo::from_c_struct(c_task_info)", "mapping_type": "function", "description": "Data field assignment and retrieval", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "insertValues.PutLong(\"mtime\", taskInfo->commonData.mtime)", "rust_api": "TaskInfo::from_c_struct(c_task_info)", "mapping_type": "function", "description": "Data field assignment and retrieval", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "unsafe { DeleteCTaskInfo(c_task_info) }", "rust_api": "unsafe { DeleteCTaskInfo(c_task_info) }", "mapping_type": "function", "description": "Memory deallocation via FFI", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__WriteMutableData__idx476_rank4.c", "source_rust_file": "API_Mapping__WriteMutableData__idx476_rank4.rs", "c_api": "unsafe { GetTaskInfo(task_id) }", "rust_api": "unsafe { &*c_task_info }", "mapping_type": "function", "description": "FFI function call and pointer dereference", "reasoning": "[Task Analysis] C function writes data to a database-like structure using Put* methods, while Rust function reads data from a database using FFI calls and conversion. [Similarity] Names refer to different concepts (WriteMutableData vs get_task_info), and domains are different (write vs read). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to data access patterns and FFI usage."}]
Unixcoder Score: 0.04869864135980606
--------------------------------------------------
C_Code: 
napi_value NAPI_MessageParcel::JS_ReadFileDescriptor(napi_env env, napi_callback_info info)
{
    size_t argc = 0;
    napi_value thisVar = nullptr;
    napi_get_cb_info(env, info, &argc, nullptr, &thisVar, nullptr);
    NAPI_MessageParcel *napiParcel = nullptr;
    napi_unwrap(env, thisVar, reinterpret_cast<void **>(&napiParcel));
    NAPI_ASSERT_BASE(env, napiParcel != nullptr, "napiParcel is null", nullptr);
    int32_t result = napiParcel->nativeParcel_->ReadFileDescriptor();
    napi_value napiValue;
    napi_create_int32(env, result, &napiValue);
    return napiValue;
}
Function: 
pub fn read_file(&mut self) -> IpcResult<File> {
        let fd = self.as_msg_parcel_mut().ReadFileDescriptor();
        unsafe { Ok(File::from_raw_fd(fd)) }
    }
Unixcoder Score: 0.024125495925545692
--------------------------------------------------
C_Code: 
napi_value NAPI_MessageParcel::JS_ReadFileDescriptor(napi_env env, napi_callback_info info)
{
    size_t argc = 0;
    napi_value thisVar = nullptr;
    napi_get_cb_info(env, info, &argc, nullptr, &thisVar, nullptr);
    NAPI_MessageParcel *napiParcel = nullptr;
    napi_unwrap(env, thisVar, reinterpret_cast<void **>(&napiParcel));
    NAPI_ASSERT_BASE(env, napiParcel != nullptr, "napiParcel is null", nullptr);
    int32_t result = napiParcel->nativeParcel_->ReadFileDescriptor();
    napi_value napiValue;
    napi_create_int32(env, result, &napiValue);
    return napiValue;
}
Function: 
pub unsafe fn read_raw_fd(&mut self) -> RawFd {
        self.as_msg_parcel_mut().ReadFileDescriptor()
    }
Unixcoder Score: 0.0204458124935627
--------------------------------------------------
C_Code: 
bool MessageParcel::WriteRawData(const void *data, size_t size)
{
    if (data == nullptr || size > MAX_RAWDATA_SIZE || size == 0) {
        uint64_t curTime = static_cast<uint64_t>(std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count());
        ZLOGE(LOG_LABEL, "data is null or size:%{public}zu not ok, time:%{public}" PRIu64, size, curTime);
        return false;
    }
    if (kernelMappedWrite_ != nullptr) {
        return false;
    }
    if (!WriteInt32(size)) {
        return false;
    }
    if (size <= MIN_RAWDATA_SIZE) {
        rawDataSize_ = size;
        return WriteUnpadBuffer(data, size);
    }
    int fd = AshmemCreate("Parcel RawData", size);
    if (fd < 0) {
        return false;
    }
    fdsan_exchange_owner_tag(fd, 0, IPC_FD_TAG);
    writeRawDataFd_ = fd;

    int result = AshmemSetProt(fd, PROT_READ | PROT_WRITE);
    if (result < 0) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        return false;
    }
    void *ptr = ::mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (ptr == MAP_FAILED) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        return false;
    }
    if (!WriteFileDescriptor(fd)) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        ::munmap(ptr, size);
        return false;
    }
    if (memcpy_s(ptr, size, data, size) != EOK) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        ::munmap(ptr, size);
        return false;
    }
    kernelMappedWrite_ = ptr;
    rawDataSize_ = size;
    return true;
}
Function: 
pub fn write<T: Serialize + ?Sized>(&mut self, value: &T) -> IpcResult<()> {
        value.serialize(self)
    }
Unixcoder Score: 0.006969253532588482
--------------------------------------------------
C_Code: 
MemoryMapInfo( VkMemoryMapInfo const & rhs ) VULKAN_HPP_NOEXCEPT : MemoryMapInfo( *reinterpret_cast<MemoryMapInfo const *>( &rhs ) ) {}
Function: 
fn from(src: &vello_encoding::BufferSizes) -> Self {
        Self {
            path_reduced: src.path_reduced.size_in_bytes(),
            path_reduced2: src.path_reduced2.size_in_bytes(),
            path_reduced_scan: src.path_reduced_scan.size_in_bytes(),
            path_monoids: src.path_monoids.size_in_bytes(),
            path_bboxes: src.path_bboxes.size_in_bytes(),
            draw_reduced: src.draw_reduced.size_in_bytes(),
            draw_monoids: src.draw_monoids.size_in_bytes(),
            info: src.info.size_in_bytes(),
            clip_inps: src.clip_inps.size_in_bytes(),
            clip_els: src.clip_els.size_in_bytes(),
            clip_bics: src.clip_bics.size_in_bytes(),
            clip_bboxes: src.clip_bboxes.size_in_bytes(),
            draw_bboxes: src.draw_bboxes.size_in_bytes(),
            bump_alloc: src.bump_alloc.size_in_bytes(),
            indirect_count: src.indirect_count.size_in_bytes(),
            bin_headers: src.bin_headers.size_in_bytes(),
            paths: src.paths.size_in_bytes(),
            lines: src.lines.size_in_bytes(),
            bin_data: src.bin_data.size_in_bytes(),
            tiles: src.tiles.size_in_bytes(),
            seg_counts: src.seg_counts.size_in_bytes(),
            segments: src.segments.size_in_bytes(),
            ptcl: src.ptcl.size_in_bytes(),
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx355_rank3.c", "source_rust_file": "Partial__WriteMutableData__idx355_rank3.rs", "c_api": "insertValues.PutBlob(\"form_items\", CFormItemToBlob(...))", "rust_api": "multi_part = multi_part.part(part);", "mapping_type": "function", "description": "Adding form item data to a multipart request", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function builds an HTTP multipart request. [Similarity] Names refer to different concepts (WriteMutableData vs build_multipart_request), and domains are different (database operations vs HTTP request building). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and loop structures, and some API mappings related to data insertion and iteration."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__WriteMutableData__idx355_rank3.c", "source_rust_file": "Partial__WriteMutableData__idx355_rank3.rs", "c_api": "insertValues.PutLong(\"mtime\", taskInfo->commonData.mtime)", "rust_api": "let part = Part::new().name(task.conf.file_specs[index].name.as_str()).file_name(task.conf.file_specs[index].file_name.as_str()).mime(task.conf.file_specs[index].mime_type.as_str()).length(Some(upload_length)).stream(task_reader);", "mapping_type": "function", "description": "Setting metadata for a part in a multipart request", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function builds an HTTP multipart request. [Similarity] Names refer to different concepts (WriteMutableData vs build_multipart_request), and domains are different (database operations vs HTTP request building). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and loop structures, and some API mappings related to data insertion and iteration."}, {"knowledge_type": "Partial", "source_c_file": "Partial__WriteMutableData__idx355_rank3.c", "source_rust_file": "Partial__WriteMutableData__idx355_rank3.rs", "c_fragment": "for (int i = 0; i < taskConfig->formItemsLen; i++) {\n        insertValues.PutBlob(\"form_items\", CFormItemToBlob(taskConfig->formItemsPtr + i, 1));\n    }", "rust_fragment": "for item in task.conf.form_items.iter() {\n        let part = Part::new()\n            .name(item.name.as_str())\n            .body(item.value.as_str());\n        multi_part = multi_part.part(part);\n    }", "description": "Both iterate over form items and add them to a collection.", "reasoning": "[Task Analysis] C function writes data to a database-like structure, while Rust function builds an HTTP multipart request. [Similarity] Names refer to different concepts (WriteMutableData vs build_multipart_request), and domains are different (database operations vs HTTP request building). [Knowledge Extraction] No full structural match, but there are partial matching patterns in data handling and loop structures, and some API mappings related to data insertion and iteration."}]
Unixcoder Score: -0.01158745028078556
--------------------------------------------------
C_Code: 
bool MessageParcel::WriteRawData(const void *data, size_t size)
{
    if (data == nullptr || size > MAX_RAWDATA_SIZE || size == 0) {
        uint64_t curTime = static_cast<uint64_t>(std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count());
        ZLOGE(LOG_LABEL, "data is null or size:%{public}zu not ok, time:%{public}" PRIu64, size, curTime);
        return false;
    }
    if (kernelMappedWrite_ != nullptr) {
        return false;
    }
    if (!WriteInt32(size)) {
        return false;
    }
    if (size <= MIN_RAWDATA_SIZE) {
        rawDataSize_ = size;
        return WriteUnpadBuffer(data, size);
    }
    int fd = AshmemCreate("Parcel RawData", size);
    if (fd < 0) {
        return false;
    }
    fdsan_exchange_owner_tag(fd, 0, IPC_FD_TAG);
    writeRawDataFd_ = fd;

    int result = AshmemSetProt(fd, PROT_READ | PROT_WRITE);
    if (result < 0) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        return false;
    }
    void *ptr = ::mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (ptr == MAP_FAILED) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        return false;
    }
    if (!WriteFileDescriptor(fd)) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        ::munmap(ptr, size);
        return false;
    }
    if (memcpy_s(ptr, size, data, size) != EOK) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        ::munmap(ptr, size);
        return false;
    }
    kernelMappedWrite_ = ptr;
    rawDataSize_ = size;
    return true;
}
Function: 
fn parcel_size() {
        let mut msg = MsgParcel::new();
        let mut size = 0;

        msg.write(&1i8).unwrap();
        size += mem::size_of::<i32>();
        assert_eq!(size, msg.size());

        msg.write(&1i16).unwrap();
        size += mem::size_of::<i32>();
        assert_eq!(size, msg.size());

        msg.write(&1i32).unwrap();
        size += mem::size_of::<i32>();
        assert_eq!(size, msg.size());

        msg.write(&1i64).unwrap();
        size += mem::size_of::<i64>();
        assert_eq!(size, msg.size());

        msg.write(&1u8).unwrap();
        size += mem::size_of::<u32>();
        assert_eq!(size, msg.size());

        msg.write(&1u16).unwrap();
        size += mem::size_of::<u32>();
        assert_eq!(size, msg.size());

        msg.write(&1u32).unwrap();
        size += mem::size_of::<u32>();
        assert_eq!(size, msg.size());

        msg.write(&1u64).unwrap();
        size += mem::size_of::<u64>();
        assert_eq!(size, msg.size());

        msg.write(&true).unwrap();
        size += mem::size_of::<i32>();
        assert_eq!(size, msg.size());
    }
Unixcoder Score: -0.012289020232856274
--------------------------------------------------
C_Code: 
bool ParcelHelper::UnMarshalMapExtras(MessageParcel &data, TaskInfo &info)
{
    uint32_t size = data.ReadUint32();
    if (size > data.GetReadableBytes()) {
        REQUEST_HILOGE("Size exceeds the upper limit, size = %{public}u", size);
        return false;
    }
    for (uint32_t i = 0; i < size; i++) {
        std::string key = data.ReadString();
        info.extras[key] = data.ReadString();
    }
    return true;
}
Function: 
pub(crate) fn build_config_set(&self) -> ConfigSet {
        ConfigSet {
            headers: hashmap_to_string(&self.headers),
            extras: hashmap_to_string(&self.extras),
            form_items: self.form_items.iter().map(|x| x.to_c_struct()).collect(),
            file_specs: self.file_specs.iter().map(|x| x.to_c_struct()).collect(),
            body_file_names: self
                .body_file_paths
                .iter()
                .map(CStringWrapper::from)
                .collect(),
            certs_path: self.certs_path.iter().map(CStringWrapper::from).collect(),
        }
    }
Unixcoder Score: -0.013752475380897522
--------------------------------------------------
C_Code: 
int
backtrace_get_view (struct backtrace_state *state ATTRIBUTE_UNUSED,
		    int descriptor, off_t offset, size_t size,
		    backtrace_error_callback error_callback,
		    void *data, struct backtrace_view *view)
{
  size_t pagesize;
  unsigned int inpage;
  off_t pageoff;
  void *map;

  pagesize = getpagesize ();
  inpage = offset % pagesize;
  pageoff = offset - inpage;

  size += inpage;
  size = (size + (pagesize - 1)) & ~ (pagesize - 1);

  map = mmap (NULL, size, PROT_READ, MAP_PRIVATE, descriptor, pageoff);
  if (map == MAP_FAILED)
    {
      error_callback (data, "mmap", errno);
      return 0;
    }

  view->data = (char *) map + inpage;
  view->base = map;
  view->len = size;

  return 1;
}
Function: 
fn main() {
    unsafe {
        let ptr = libc::mmap(
            std::ptr::null_mut(),
            4096,
            libc::PROT_READ | libc::PROT_WRITE,
            libc::MAP_PRIVATE | libc::MAP_ANONYMOUS,
            -1,
            0,
        );
        libc::munmap(ptr, 4096);
        let _x = *(ptr as *mut u8); //~ ERROR: was dereferenced after this allocation got freed
    }
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__backtrace_get_view__idx30702_rank1.c", "source_rust_file": "API_Mapping__backtrace_get_view__idx30702_rank1.rs", "c_api": "mmap (NULL, size, PROT_READ, MAP_PRIVATE, descriptor, pageoff)", "rust_api": "memmap2::Mmap::map(&file)", "mapping_type": "function", "description": "Map file into memory", "reasoning": "[Task Analysis] C function `backtrace_get_view` maps a file descriptor into memory using `mmap`, while Rust function `map` creates a memory mapping using `memmap2::Mmap::map`. [Similarity] Both perform memory mapping of a file, but differ in scope and error handling. [Knowledge Extraction] No full structural match due to different domains (C low-level system call vs Rust high-level abstraction), but API mapping exists for file memory mapping."}]
Unixcoder Score: -0.023630408570170403
--------------------------------------------------
C_Code: 
bool MessageParcel::WriteRawData(const void *data, size_t size)
{
    if (data == nullptr || size > MAX_RAWDATA_SIZE || size == 0) {
        uint64_t curTime = static_cast<uint64_t>(std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count());
        ZLOGE(LOG_LABEL, "data is null or size:%{public}zu not ok, time:%{public}" PRIu64, size, curTime);
        return false;
    }
    if (kernelMappedWrite_ != nullptr) {
        return false;
    }
    if (!WriteInt32(size)) {
        return false;
    }
    if (size <= MIN_RAWDATA_SIZE) {
        rawDataSize_ = size;
        return WriteUnpadBuffer(data, size);
    }
    int fd = AshmemCreate("Parcel RawData", size);
    if (fd < 0) {
        return false;
    }
    fdsan_exchange_owner_tag(fd, 0, IPC_FD_TAG);
    writeRawDataFd_ = fd;

    int result = AshmemSetProt(fd, PROT_READ | PROT_WRITE);
    if (result < 0) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        return false;
    }
    void *ptr = ::mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (ptr == MAP_FAILED) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        return false;
    }
    if (!WriteFileDescriptor(fd)) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        ::munmap(ptr, size);
        return false;
    }
    if (memcpy_s(ptr, size, data, size) != EOK) {
        // Do not close fd here, which will be closed in MessageParcel's destructor.
        ::munmap(ptr, size);
        return false;
    }
    kernelMappedWrite_ = ptr;
    rawDataSize_ = size;
    return true;
}
Function: 
pub fn write_buffer(&mut self, buffer: &[u8]) -> IpcResult<()> {
        match WriteBuffer(self.as_msg_parcel_mut(), buffer) {
            true => Ok(()),
            false => Err(IpcStatusCode::Failed),
        }
    }
Unixcoder Score: -0.025738943368196487
--------------------------------------------------
