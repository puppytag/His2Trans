C_Code: 
bool VerifyFromPointer(const uint8_t *const p, const size_t len) {
    return Verify(static_cast<size_t>(p - buf_), len);
  }
Function: 
pub fn size_prefixed_root<'buf, T>(data: &'buf [u8]) -> Result<T::Inner, InvalidFlatbuffer>
where
    T: 'buf + Follow<'buf> + Verifiable,
{
    let opts = VerifierOptions::default();
    size_prefixed_root_with_opts::<T>(&opts, data)
}
Unixcoder Score: 0.07118457555770874
--------------------------------------------------
C_Code: 
bool VerifyFromPointer(const uint8_t *const p, const size_t len) {
    return Verify(static_cast<size_t>(p - buf_), len);
  }
Function: 
pub fn root_with_opts<'opts, 'buf, T>(
    opts: &'opts VerifierOptions,
    data: &'buf [u8],
) -> Result<T::Inner, InvalidFlatbuffer>
where
    T: 'buf + Follow<'buf> + Verifiable,
{
    let mut v = Verifier::new(opts, data);
    <ForwardsUOffset<T>>::run_verifier(&mut v, 0)?;
    // Safety:
    // Run verifier above
    Ok(unsafe { root_unchecked::<T>(data) })
}
Unixcoder Score: 0.06347262859344482
--------------------------------------------------
C_Code: 
bool valid() const { return fType != Type::kInvalid; }
Function: 
fn font_ref_is_valid(bridge_font_ref: &BridgeFontRef) -> bool {
    bridge_font_ref.font.is_some()
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__read_byte__idx122863_rank3.c", "source_rust_file": "API_Mapping__read_byte__idx122863_rank3.rs", "c_api": "read_byte", "rust_api": "reader.read::<u8>()", "mapping_type": "function", "description": "Read a single byte from buffer", "reasoning": "[Task Analysis] C function reads a single byte from a buffer with error handling; Rust function reads encoded data using a DwarfReader with various read methods. [Similarity] Names do not match but both perform byte-level data reading. [Knowledge Extraction] No full structural match due to different domains (buffer management vs structured reader), but API mappings found for byte reading operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__read_byte__idx122863_rank3.c", "source_rust_file": "API_Mapping__read_byte__idx122863_rank3.rs", "c_api": "read_byte", "rust_api": "reader.read::<u32>()", "mapping_type": "function", "description": "Read a 32-bit value from buffer", "reasoning": "[Task Analysis] C function reads a single byte from a buffer with error handling; Rust function reads encoded data using a DwarfReader with various read methods. [Similarity] Names do not match but both perform byte-level data reading. [Knowledge Extraction] No full structural match due to different domains (buffer management vs structured reader), but API mappings found for byte reading operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__read_byte__idx122863_rank3.c", "source_rust_file": "API_Mapping__read_byte__idx122863_rank3.rs", "c_api": "read_byte", "rust_api": "reader.read::<i8>()", "mapping_type": "function", "description": "Read a signed 8-bit value from buffer", "reasoning": "[Task Analysis] C function reads a single byte from a buffer with error handling; Rust function reads encoded data using a DwarfReader with various read methods. [Similarity] Names do not match but both perform byte-level data reading. [Knowledge Extraction] No full structural match due to different domains (buffer management vs structured reader), but API mappings found for byte reading operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__read_byte__idx122863_rank3.c", "source_rust_file": "API_Mapping__read_byte__idx122863_rank3.rs", "c_api": "read_byte", "rust_api": "reader.read_uleb128()", "mapping_type": "function", "description": "Read a ULEB128 encoded integer", "reasoning": "[Task Analysis] C function reads a single byte from a buffer with error handling; Rust function reads encoded data using a DwarfReader with various read methods. [Similarity] Names do not match but both perform byte-level data reading. [Knowledge Extraction] No full structural match due to different domains (buffer management vs structured reader), but API mappings found for byte reading operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__read_byte__idx122863_rank3.c", "source_rust_file": "API_Mapping__read_byte__idx122863_rank3.rs", "c_api": "read_byte", "rust_api": "reader.read::<u16>()", "mapping_type": "function", "description": "Read a 16-bit value from buffer", "reasoning": "[Task Analysis] C function reads a single byte from a buffer with error handling; Rust function reads encoded data using a DwarfReader with various read methods. [Similarity] Names do not match but both perform byte-level data reading. [Knowledge Extraction] No full structural match due to different domains (buffer management vs structured reader), but API mappings found for byte reading operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__read_byte__idx122863_rank3.c", "source_rust_file": "API_Mapping__read_byte__idx122863_rank3.rs", "c_api": "read_byte", "rust_api": "reader.read_sleb128()", "mapping_type": "function", "description": "Read a SLEB128 encoded integer", "reasoning": "[Task Analysis] C function reads a single byte from a buffer with error handling; Rust function reads encoded data using a DwarfReader with various read methods. [Similarity] Names do not match but both perform byte-level data reading. [Knowledge Extraction] No full structural match due to different domains (buffer management vs structured reader), but API mappings found for byte reading operations."}]
Unixcoder Score: 0.02569538541138172
--------------------------------------------------
C_Code: 
static bool getBit(int x, int i) {
	return ((x >> i) & 1) != 0;
}
Function: 
fn get_bit(x: u32, i: i32) -> bool {
	(x >> i) & 1 != 0
}
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__addEccAndInterleave__idx144387_rank5.c", "source_rust_file": "Partial__addEccAndInterleave__idx144387_rank5.rs", "c_fragment": "if (currentruncolor) {  // Terminate dark run\n\tself.add_history(currentrunlength);\n\tcurrentrunlength = 0;\n}\ncurrentrunlength += self.qr_size;  // Add light border to final run\nself.add_history(currentrunlength);\nreturn self.count_patterns();", "rust_fragment": "if currentruncolor {  // Terminate dark run\n\tself.add_history(currentrunlength);\n\tcurrentrunlength = 0;\n}\ncurrentrunlength += self.qr_size;  // Add light border to final run\nself.add_history(currentrunlength);\nself.count_patterns()", "description": "Both functions handle the termination and counting of a run of same-colored modules in QR code penalty calculation, including adding history and computing patterns.", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction]"}]
Unixcoder Score: 0.013631803914904594
--------------------------------------------------
C_Code: 
bool VerifyAlignment(const uint8_t *p, size_t size) const {
    auto o = static_cast<size_t>(p - buf_);
    return Check((o & (size - 1)) == 0 || !check_alignment_);
  }
Function: 
pub fn is_aligned(&self) -> bool {
        (self.buffer.as_ptr() as usize).rem(8) == 0
    }
Unixcoder Score: -0.0032929740846157074
--------------------------------------------------
C_Code: 
static bool getBit(int x, int i) {
	return ((x >> i) & 1) != 0;
}
Function: 
fn get_bit(x: u32, i: u8) -> bool {
	(x >> i) & 1 != 0
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Full__addEccAndInterleave__idx144430_rank5.c", "source_rust_file": "Full__addEccAndInterleave__idx144430_rank5.rs", "c_api": "blocks.push_back(std::move(dat))", "rust_api": "result[k] = dat[j]", "mapping_type": "pattern", "description": "Data interleaving pattern", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code implements QR code ECC and interleaving logic, while the Rust code implements a similar function with the same purpose. Both involve Reed-Solomon error correction, block splitting, and interleaving data. The core algorithmic structure is preserved across languages. [Similarity] -> [Full] The function signatures and core logic match closely, with only minor differences in syntax and error handling patterns. [Knowledge Extraction] -> [API Mappings] Extracted API mappings for Reed-Solomon operations, data splitting, and interleaving logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__addEccAndInterleave__idx144430_rank5.c", "source_rust_file": "Full__addEccAndInterleave__idx144430_rank5.rs", "c_api": "reedSolomonComputeRemainder", "rust_api": "ReedSolomonGenerator::compute_remainder", "mapping_type": "function", "description": "Reed-Solomon remainder computation for error correction", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code implements QR code ECC and interleaving logic, while the Rust code implements a similar function with the same purpose. Both involve Reed-Solomon error correction, block splitting, and interleaving data. The core algorithmic structure is preserved across languages. [Similarity] -> [Full] The function signatures and core logic match closely, with only minor differences in syntax and error handling patterns. [Knowledge Extraction] -> [API Mappings] Extracted API mappings for Reed-Solomon operations, data splitting, and interleaving logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__addEccAndInterleave__idx144430_rank5.c", "source_rust_file": "Full__addEccAndInterleave__idx144430_rank5.rs", "c_api": "vector<uint8_t> result", "rust_api": "resultbuf", "mapping_type": "type", "description": "Output buffer for result data", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code implements QR code ECC and interleaving logic, while the Rust code implements a similar function with the same purpose. Both involve Reed-Solomon error correction, block splitting, and interleaving data. The core algorithmic structure is preserved across languages. [Similarity] -> [Full] The function signatures and core logic match closely, with only minor differences in syntax and error handling patterns. [Knowledge Extraction] -> [API Mappings] Extracted API mappings for Reed-Solomon operations, data splitting, and interleaving logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__addEccAndInterleave__idx144430_rank5.c", "source_rust_file": "Full__addEccAndInterleave__idx144430_rank5.rs", "c_api": "data.cbegin() + k", "rust_api": "&dat[ .. datlen]", "mapping_type": "pattern", "description": "Data slicing for block processing", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code implements QR code ECC and interleaving logic, while the Rust code implements a similar function with the same purpose. Both involve Reed-Solomon error correction, block splitting, and interleaving data. The core algorithmic structure is preserved across languages. [Similarity] -> [Full] The function signatures and core logic match closely, with only minor differences in syntax and error handling patterns. [Knowledge Extraction] -> [API Mappings] Extracted API mappings for Reed-Solomon operations, data splitting, and interleaving logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__addEccAndInterleave__idx144430_rank5.c", "source_rust_file": "Full__addEccAndInterleave__idx144430_rank5.rs", "c_api": "reedSolomonComputeDivisor", "rust_api": "ReedSolomonGenerator::new", "mapping_type": "function", "description": "Reed-Solomon divisor computation for error correction", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code implements QR code ECC and interleaving logic, while the Rust code implements a similar function with the same purpose. Both involve Reed-Solomon error correction, block splitting, and interleaving data. The core algorithmic structure is preserved across languages. [Similarity] -> [Full] The function signatures and core logic match closely, with only minor differences in syntax and error handling patterns. [Knowledge Extraction] -> [API Mappings] Extracted API mappings for Reed-Solomon operations, data splitting, and interleaving logic."}, {"knowledge_type": "Full", "source_c_file": "Full__addEccAndInterleave__idx144430_rank5.c", "source_rust_file": "Full__addEccAndInterleave__idx144430_rank5.rs", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code implements QR code ECC and interleaving logic, while the Rust code implements a similar function with the same purpose. Both involve Reed-Solomon error correction, block splitting, and interleaving data. The core algorithmic structure is preserved across languages. [Similarity] -> [Full] The function signatures and core logic match closely, with only minor differences in syntax and error handling patterns. [Knowledge Extraction] -> [API Mappings] Extracted API mappings for Reed-Solomon operations, data splitting, and interleaving logic.", "description": "Full structural translation"}, {"knowledge_type": "Partial", "source_c_file": "Full__addEccAndInterleave__idx144430_rank5.c", "source_rust_file": "Full__addEccAndInterleave__idx144430_rank5.rs", "c_fragment": "vector<uint8_t> QrCode::addEccAndInterleave(const vector<uint8_t> &data)  {\n\tvector<uint8_t> result;\n\tif (data.size() != static_cast<unsigned int>(getNumDataCodewords(version, errorCorrectionLevel))) {\n\t\tflag = false;\n\t\treturn result;\n\t}\n#else\nvector<uint8_t> QrCode::addEccAndInterleave(const vector<uint8_t> &data) const {\n\tif (data.size() != static_cast<unsigned int>(getNumDataCodewords(version, errorCorrectionLevel)))\n\t\tthrow std::invalid_argument(\"Invalid argument\");\n#endif\n\t\n\t// Calculate parameter numbers\n\tint numBlocks = NUM_ERROR_CORRECTION_BLOCKS[static_cast<int>(errorCorrectionLevel)][version];\n\tint blockEccLen = ECC_CODEWORDS_PER_BLOCK  [static_cast<int>(errorCorrectionLevel)][version];\n\tint rawCodewords = getNumRawDataModules(version) / 8;\n\tint numShortBlocks = numBlocks - rawCodewords % numBlocks;\n\tint shortBlockLen = rawCodewords / numBlocks;\n\t\n\t// Split data into blocks and append ECC to each block\n\tvector<vector<uint8_t> > blocks;\n\tconst vector<uint8_t> rsDiv = reedSolomonComputeDivisor(blockEccLen);\n#if defined(ACE_ENGINE_QRCODE_ABLE)\n\tif (!flag) {\n\t\treturn result;\n\t}\n#endif\n\tfor (int i = 0, k = 0; i < numBlocks; i++) {\n\t\tvector<uint8_t> dat(data.cbegin() + k, data.cbegin() + (k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1)));\n\t\tk += static_cast<int>(dat.size());\n\t\tconst vector<uint8_t> ecc = reedSolomonComputeRemainder(dat, rsDiv);\n#if defined(ACE_ENGINE_QRCODE_ABLE)\n\t\tif (!flag) {\n\t\t\treturn result;\n\t\t}\n#endif\n\t\tif (i < numShortBlocks)\n\t\t\tdat.push_back(0);\n\t\tdat.insert(dat.end(), ecc.cbegin(), ecc.cend());\n\t\tblocks.push_back(std::move(dat));\n\t}\n\t\n\t// Interleave (not concatenate) the bytes from every block into a single sequence\n#if !defined(ACE_ENGINE_QRCODE_ABLE)\n\tvector<uint8_t> result;\n#endif\n\tfor (size_t i = 0; i < blocks.at(0).size(); i++) {\n\t\tfor (size_t j = 0; j < blocks.size(); j++) {\n\t\t\t// Skip the padding byte in short blocks\n\t\t\tif (i != static_cast<unsigned int>(shortBlockLen - blockEccLen) || j >= static_cast<unsigned int>(numShortBlocks))\n\t\t\t\tresult.push_back(blocks.at(j).at(i));\n\t\t}\n\t}\n#if defined(ACE_ENGINE_QRCODE_ABLE)\n\tif (result.size() != static_cast<unsigned int>(rawCodewords))\n\t\tflag = false;\n#else\n\tassert(result.size() == static_cast<unsigned int>(rawCodewords));\n#endif\n\treturn result;\n}", "rust_fragment": "fn add_ecc_and_interleave<'b>(data: &[u8], ver: Version, ecl: QrCodeEcc, temp: &mut [u8], resultbuf: &'b mut [u8]) -> &'b [u8] {\n\t\tassert_eq!(data.len(), QrCode::get_num_data_codewords(ver, ecl));\n\t\t\n\t\t// Calculate parameter numbers\n\t\tlet numblocks: usize = QrCode::table_get(&NUM_ERROR_CORRECTION_BLOCKS, ver, ecl);\n\t\tlet blockecclen: usize = QrCode::table_get(&ECC_CODEWORDS_PER_BLOCK  , ver, ecl);\n\t\tlet rawcodewords: usize = QrCode::get_num_raw_data_modules(ver) / 8;\n\t\tlet numshortblocks: usize = numblocks - rawcodewords % numblocks;\n\t\tlet shortblockdatalen: usize = rawcodewords / numblocks - blockecclen;\n\t\tlet result = &mut resultbuf[ .. rawcodewords];\n\t\t\n\t\t// Split data into blocks, calculate ECC, and interleave\n\t\t// (not concatenate) the bytes into a single sequence\n\t\tlet rs = ReedSolomonGenerator::new(blockecclen);\n\t\tlet mut dat: &[u8] = data;\n\t\tlet ecc: &mut [u8] = &mut temp[ .. blockecclen];  // Temporary storage\n\t\tfor i in 0 .. numblocks {\n\t\t\tlet datlen: usize = shortblockdatalen + usize::from(i >= numshortblocks);\n\t\t\trs.compute_remainder(&dat[ .. datlen], ecc);\n\t\t\tlet mut k: usize = i;\n\t\t\tfor j in 0 .. datlen {  // Copy data\n\t\t\t\tif j == shortblockdatalen {\n\t\t\t\t\tk -= numshortblocks;\n\t\t\t\t}\n\t\t\t\tresult[k] = dat[j];\n\t\t\t\tk += numblocks;\n\t\t\t}\n\t\t\tlet mut k: usize = data.len() + i;\n\t\t\tfor j in 0 .. blockecclen {  // Copy ECC\n\t\t\t\tresult[k] = ecc[j];\n\t\t\t\tk += numblocks;\n\t\t\t}\n\t\t\tdat = &dat[datlen .. ];\n\t\t}\n\t\tdebug_assert_eq!(dat.len(), 0);\n\t\tresult\n\t}", "description": "Both functions implement the same core algorithm for adding ECC and interleaving data in QR codes, including parameter calculation, block splitting, Reed-Solomon error correction, and interleaving.", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code implements QR code ECC and interleaving logic, while the Rust code implements a similar function with the same purpose. Both involve Reed-Solomon error correction, block splitting, and interleaving data. The core algorithmic structure is preserved across languages. [Similarity] -> [Full] The function signatures and core logic match closely, with only minor differences in syntax and error handling patterns. [Knowledge Extraction] -> [API Mappings] Extracted API mappings for Reed-Solomon operations, data splitting, and interleaving logic."}]
Unixcoder Score: -0.005552161950618029
--------------------------------------------------
C_Code: 
bool TLSCertificate::CertificateFromData(const std::string &data, CertType certType)
{
    if (data.empty()) {
        NETSTACK_LOGE("The parameter data is empty");
        return false;
    }
    BIO *bio = BIO_new_mem_buf(data.c_str(), -1);
    if (!bio) {
        NETSTACK_LOGE("create BIO mem buf failed!");
        return false;
    }
    X509 *x509 = PEM_read_bio_X509(bio, nullptr, nullptr, nullptr);
    BIO_free(bio);

    if (!x509) {
        NETSTACK_LOGE("x509 is null");
        return false;
    }

    x509_ = X509_dup(x509);
    if (!AnalysisCertificate(certType, x509)) {
        NETSTACK_LOGE("Analysis certificate is false");
        X509_free(x509);
        return false;
    }
    X509_free(x509);
    return true;
}
Function: 
pub fn from_pem(pem: &[u8]) -> Result<Certificate, HttpClientError> {
        const CERT_BEGIN: &str = "-----BEGIN CERTIFICATE-----";
        const CERT_END: &str = "-----END CERTIFICATE-----";

        let mut inner = Vec::new();
        let str = std::str::from_utf8(pem).map_err(|_| {
            HttpClientError::new_with_cause(ErrorKind::Build, Some(InvalidCertificate))
        })?;
        let mut pos = 0;
        while pos < str.len() {
            let st = match str[pos..].find(CERT_BEGIN) {
                Some(size) => size,
                None => break,
            };

            let ed = match str[pos + st..].find(CERT_END) {
                Some(size) => size,
                None => break,
            };

            let slice = str[pos + st..pos + st + ed + CERT_END.len()].as_bytes();
            let cert = reqwest::Certificate::from_pem(slice)
                .map_err(|e| HttpClientError::new_with_cause(ErrorKind::Build, Some(e)))?;
            inner.push(cert);
            pos += st + ed + CERT_END.len();
        }

        if inner.is_empty() {
            return Err(HttpClientError::new_with_cause(
                ErrorKind::Build,
                Some(InvalidCertificate),
            ));
        }

        Ok(Self { inner })
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Full__getBit__idx144410_rank1.c", "source_rust_file": "Full__getBit__idx144410_rank1.rs", "c_api": "(x >> i) & 1", "rust_api": "(x >> i) & 1", "mapping_type": "pattern", "description": "Bitwise right shift and AND operation to extract a specific bit.", "reasoning": "[Task Analysis] C and Rust functions both implement bit extraction logic. [Similarity] Names differ (getBit vs get_bit), but concept and logic are identical. [Knowledge Extraction] Full structural match with minor syntax differences (type names, return statement format). API mapping found for bit manipulation operation."}, {"knowledge_type": "Partial", "source_c_file": "Full__getBit__idx144410_rank1.c", "source_rust_file": "Full__getBit__idx144410_rank1.rs", "c_fragment": "static bool getBit(int x, int i) {\n\treturn ((x >> i) & 1) != 0;\n}", "rust_fragment": "fn get_bit(x: u32, i: i32) -> bool {\n\t(x >> i) & 1 != 0\n}", "description": "Bit extraction function that checks if a specific bit is set in an integer.", "reasoning": "[Task Analysis] C and Rust functions both implement bit extraction logic. [Similarity] Names differ (getBit vs get_bit), but concept and logic are identical. [Knowledge Extraction] Full structural match with minor syntax differences (type names, return statement format). API mapping found for bit manipulation operation."}, {"knowledge_type": "Full", "source_c_file": "Full__getBit__idx144410_rank1.c", "source_rust_file": "Full__getBit__idx144410_rank1.rs", "reasoning": "[Task Analysis] C and Rust functions both implement bit extraction logic. [Similarity] Names differ (getBit vs get_bit), but concept and logic are identical. [Knowledge Extraction] Full structural match with minor syntax differences (type names, return statement format). API mapping found for bit manipulation operation.", "description": "Full structural translation"}]
Unixcoder Score: -0.006675603799521923
--------------------------------------------------
C_Code: 
static bool is_ascii(const char* s) {
    while (char v = *s++) {
        if ((v & 0x80) != 0) {
            return false;
        }
    }
    return true;
}
Function: 
fn latin1_bytes_into_string(bytes: &[u8]) -> String {
            bytes.iter().map(|&b| b as char).collect()
        }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetKey__idx5175_rank2.h", "source_rust_file": "API_Mapping__GetKey__idx5175_rank2.rs", "c_api": "ipc_conn::FieldRaw::Asset(ref a)", "rust_api": "Value::Asset(a.clone())", "mapping_type": "pattern", "description": "Mapping from asset field raw value to asset value", "reasoning": "[Task Analysis] C code defines a C++ class `SchemaMeta` with methods and constants; Rust code defines a `From` trait implementation for converting `ipc_conn::FieldRaw` to `Value`. [Similarity] No direct structural similarity in logic or control flow. [Knowledge Extraction] No full or partial match due to domain mismatch (C++ class vs Rust type conversion). However, there are API mappings related to field conversion patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetKey__idx5175_rank2.h", "source_rust_file": "API_Mapping__GetKey__idx5175_rank2.rs", "c_api": "ipc_conn::FieldRaw::Assets(ref a)", "rust_api": "Value::Assets(a.0.clone())", "mapping_type": "pattern", "description": "Mapping from assets field raw value to assets value", "reasoning": "[Task Analysis] C code defines a C++ class `SchemaMeta` with methods and constants; Rust code defines a `From` trait implementation for converting `ipc_conn::FieldRaw` to `Value`. [Similarity] No direct structural similarity in logic or control flow. [Knowledge Extraction] No full or partial match due to domain mismatch (C++ class vs Rust type conversion). However, there are API mappings related to field conversion patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetKey__idx5175_rank2.h", "source_rust_file": "API_Mapping__GetKey__idx5175_rank2.rs", "c_api": "ipc_conn::FieldRaw::Number(i)", "rust_api": "Value::Int(i)", "mapping_type": "pattern", "description": "Mapping from numeric field raw value to integer value", "reasoning": "[Task Analysis] C code defines a C++ class `SchemaMeta` with methods and constants; Rust code defines a `From` trait implementation for converting `ipc_conn::FieldRaw` to `Value`. [Similarity] No direct structural similarity in logic or control flow. [Knowledge Extraction] No full or partial match due to domain mismatch (C++ class vs Rust type conversion). However, there are API mappings related to field conversion patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetKey__idx5175_rank2.h", "source_rust_file": "API_Mapping__GetKey__idx5175_rank2.rs", "c_api": "ipc_conn::FieldRaw::Null", "rust_api": "Value::Empty", "mapping_type": "pattern", "description": "Mapping from null field raw value to empty value", "reasoning": "[Task Analysis] C code defines a C++ class `SchemaMeta` with methods and constants; Rust code defines a `From` trait implementation for converting `ipc_conn::FieldRaw` to `Value`. [Similarity] No direct structural similarity in logic or control flow. [Knowledge Extraction] No full or partial match due to domain mismatch (C++ class vs Rust type conversion). However, there are API mappings related to field conversion patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetKey__idx5175_rank2.h", "source_rust_file": "API_Mapping__GetKey__idx5175_rank2.rs", "c_api": "ipc_conn::FieldRaw::Blob(ref b)", "rust_api": "Value::Bytes(b.to_vec())", "mapping_type": "pattern", "description": "Mapping from blob field raw value to bytes value", "reasoning": "[Task Analysis] C code defines a C++ class `SchemaMeta` with methods and constants; Rust code defines a `From` trait implementation for converting `ipc_conn::FieldRaw` to `Value`. [Similarity] No direct structural similarity in logic or control flow. [Knowledge Extraction] No full or partial match due to domain mismatch (C++ class vs Rust type conversion). However, there are API mappings related to field conversion patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetKey__idx5175_rank2.h", "source_rust_file": "API_Mapping__GetKey__idx5175_rank2.rs", "c_api": "ipc_conn::FieldRaw::Real(f)", "rust_api": "Value::Float(f)", "mapping_type": "pattern", "description": "Mapping from real field raw value to float value", "reasoning": "[Task Analysis] C code defines a C++ class `SchemaMeta` with methods and constants; Rust code defines a `From` trait implementation for converting `ipc_conn::FieldRaw` to `Value`. [Similarity] No direct structural similarity in logic or control flow. [Knowledge Extraction] No full or partial match due to domain mismatch (C++ class vs Rust type conversion). However, there are API mappings related to field conversion patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetKey__idx5175_rank2.h", "source_rust_file": "API_Mapping__GetKey__idx5175_rank2.rs", "c_api": "ipc_conn::FieldRaw::Bool(b)", "rust_api": "Value::Bool(b)", "mapping_type": "pattern", "description": "Mapping from boolean field raw value to boolean value", "reasoning": "[Task Analysis] C code defines a C++ class `SchemaMeta` with methods and constants; Rust code defines a `From` trait implementation for converting `ipc_conn::FieldRaw` to `Value`. [Similarity] No direct structural similarity in logic or control flow. [Knowledge Extraction] No full or partial match due to domain mismatch (C++ class vs Rust type conversion). However, there are API mappings related to field conversion patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetKey__idx5175_rank2.h", "source_rust_file": "API_Mapping__GetKey__idx5175_rank2.rs", "c_api": "ipc_conn::FieldRaw::Text(ref s)", "rust_api": "Value::String(s.to_string())", "mapping_type": "pattern", "description": "Mapping from text field raw value to string value", "reasoning": "[Task Analysis] C code defines a C++ class `SchemaMeta` with methods and constants; Rust code defines a `From` trait implementation for converting `ipc_conn::FieldRaw` to `Value`. [Similarity] No direct structural similarity in logic or control flow. [Knowledge Extraction] No full or partial match due to domain mismatch (C++ class vs Rust type conversion). However, there are API mappings related to field conversion patterns."}]
Unixcoder Score: -0.01773110218346119
--------------------------------------------------
C_Code: 
vector<uint8_t> QrCode::addEccAndInterleave(const vector<uint8_t> &data)  {
	vector<uint8_t> result;
	if (data.size() != static_cast<unsigned int>(getNumDataCodewords(version, errorCorrectionLevel))) {
		flag = false;
		return result;
	}
#else
vector<uint8_t> QrCode::addEccAndInterleave(const vector<uint8_t> &data) const {
	if (data.size() != static_cast<unsigned int>(getNumDataCodewords(version, errorCorrectionLevel)))
		throw std::invalid_argument("Invalid argument");
#endif
	
	// Calculate parameter numbers
	int numBlocks = NUM_ERROR_CORRECTION_BLOCKS[static_cast<int>(errorCorrectionLevel)][version];
	int blockEccLen = ECC_CODEWORDS_PER_BLOCK  [static_cast<int>(errorCorrectionLevel)][version];
	int rawCodewords = getNumRawDataModules(version) / 8;
	int numShortBlocks = numBlocks - rawCodewords % numBlocks;
	int shortBlockLen = rawCodewords / numBlocks;
	
	// Split data into blocks and append ECC to each block
	vector<vector<uint8_t> > blocks;
	const vector<uint8_t> rsDiv = reedSolomonComputeDivisor(blockEccLen);
#if defined(ACE_ENGINE_QRCODE_ABLE)
	if (!flag) {
		return result;
	}
#endif
	for (int i = 0, k = 0; i < numBlocks; i++) {
		vector<uint8_t> dat(data.cbegin() + k, data.cbegin() + (k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1)));
		k += static_cast<int>(dat.size());
		const vector<uint8_t> ecc = reedSolomonComputeRemainder(dat, rsDiv);
#if defined(ACE_ENGINE_QRCODE_ABLE)
		if (!flag) {
			return result;
		}
#endif
		if (i < numShortBlocks)
			dat.push_back(0);
		dat.insert(dat.end(), ecc.cbegin(), ecc.cend());
		blocks.push_back(std::move(dat));
	}
	
	// Interleave (not concatenate) the bytes from every block into a single sequence
#if !defined(ACE_ENGINE_QRCODE_ABLE)
	vector<uint8_t> result;
#endif
	for (size_t i = 0; i < blocks.at(0).size(); i++) {
		for (size_t j = 0; j < blocks.size(); j++) {
			// Skip the padding byte in short blocks
			if (i != static_cast<unsigned int>(shortBlockLen - blockEccLen) || j >= static_cast<unsigned int>(numShortBlocks))
				result.push_back(blocks.at(j).at(i));
		}
	}
#if defined(ACE_ENGINE_QRCODE_ABLE)
	if (result.size() != static_cast<unsigned int>(rawCodewords))
		flag = false;
#else
	assert(result.size() == static_cast<unsigned int>(rawCodewords));
#endif
	return result;
}


void QrCode::drawCodewords(const vector<uint8_t> &data) {
#if defined(ACE_ENGINE_QRCODE_ABLE)
	if (data.size() != static_cast<unsigned int>(getNumRawDataModules(version) / 8)) {
		flag = false;
		return;
	}
#else
	if (data.size() != static_cast<unsigned int>(getNumRawDataModules(version) / 8))
		throw std::invalid_argument("Invalid argument");
#endif
	
	size_t i = 0;  // Bit index into the data
	// Do the funny zigzag scan
	for (int right = size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair
		if (right == 6)
			right = 5;
		for (int vert = 0; vert < size; vert++) {  // Vertical counter
			for (int j = 0; j < 2; j++) {
				size_t x = static_cast<size_t>(right - j);  // Actual x coordinate
				bool upward = ((right + 1) & 2) == 0;
				size_t y = static_cast<size_t>(upward ? size - 1 - vert : vert);  // Actual y coordinate
				if (!isFunction.at(y).at(x) && i < data.size() * 8) {
					modules.at(y).at(x) = getBit(data.at(i >> 3), 7 - static_cast<int>(i & 7));
					i++;
				}
				// If this QR Code has any remainder bits (0 to 7), they were assigned as
				// 0/false/light by the constructor and are left unchanged by this method
			}
		}
	}
#if defined(ACE_ENGINE_QRCODE_ABLE)
	if (i != data.size() * 8){
		flag = false;
		return;
	}
#else
	assert(i == data.size() * 8);
#endif
}


void QrCode::applyMask(int msk) {
#if !defined(ACE_ENGINE_QRCODE_ABLE)
	if (msk < 0 || msk > 7)
		throw std::domain_error("Mask value out of range");
#endif
	size_t sz = static_cast<size_t>(size);
	for (size_t y = 0; y < sz; y++) {
		for (size_t x = 0; x < sz; x++) {
			bool invert;
			switch (msk) {
				case 0:  invert = (x + y) % 2 == 0;                    break;
				case 1:  invert = y % 2 == 0;                          break;
				case 2:  invert = x % 3 == 0;                          break;
				case 3:  invert = (x + y) % 3 == 0;                    break;
				case 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;
				case 5:  invert = x * y % 2 + x * y % 3 == 0;          break;
				case 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;
				case 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;
#if defined(ACE_ENGINE_QRCODE_ABLE)
				default:  return;
#else
				default:  throw std::logic_error("Unreachable");
#endif
			}
			modules.at(y).at(x) = modules.at(y).at(x) ^ (invert & !isFunction.at(y).at(x));
		}
	}
}


#if !defined(ACE_ENGINE_QRCODE_ABLE)
long QrCode::getPenaltyScore() const {
	long result = 0;
	
	// Adjacent modules in row having same color, and finder-like patterns
	for (int y = 0; y < size; y++) {
		bool runColor = false;
		int runX = 0;
		std::array<int,7> runHistory = {};
		for (int x = 0; x < size; x++) {
			if (module(x, y) == runColor) {
				runX++;
				if (runX == 5)
					result += PENALTY_N1;
				else if (runX > 5)
					result++;
			} else {
				finderPenaltyAddHistory(runX, runHistory);
				if (!runColor)
					result += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
				runColor = module(x, y);
				runX = 1;
			}
		}
		result += finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;
	}
	// Adjacent modules in column having same color, and finder-like patterns
	for (int x = 0; x < size; x++) {
		bool runColor = false;
		int runY = 0;
		std::array<int,7> runHistory = {};
		for (int y = 0; y < size; y++) {
			if (module(x, y) == runColor) {
				runY++;
				if (runY == 5)
					result += PENALTY_N1;
				else if (runY > 5)
					result++;
			} else {
				finderPenaltyAddHistory(runY, runHistory);
				if (!runColor)
					result += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
				runColor = module(x, y);
				runY = 1;
			}
		}
		result += finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;
	}
	
	// 2*2 blocks of modules having same color
	for (int y = 0; y < size - 1; y++) {
		for (int x = 0; x < size - 1; x++) {
			bool  color = module(x, y);
			if (  color == module(x + 1, y) &&
			      color == module(x, y + 1) &&
			      color == module(x + 1, y + 1))
				result += PENALTY_N2;
		}
	}
	
	// Balance of dark and light modules
	int dark = 0;
	for (const vector<bool> &row : modules) {
		for (bool color : row) {
			if (color)
				dark++;
		}
	}
	int total = size * size;  // Note that size is odd, so dark/total != 1/2
	// Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%
	int k = static_cast<int>((std::abs(dark * 20L - total * 10L) + total - 1) / total) - 1;
	assert(0 <= k && k <= 9);
	result += k * PENALTY_N4;
	assert(0 <= result && result <= 2568888L);  // Non-tight upper bound based on default values of PENALTY_N1, ..., N4
	return result;
}

#endif

vector<int> QrCode::getAlignmentPatternPositions() const {
	if (version == 1)
		return vector<int>();
	else {
		int numAlign = version / 7 + 2;
		int step = (version == 32) ? 26 :
			(version * 4 + numAlign * 2 + 1) / (numAlign * 2 - 2) * 2;
		vector<int> result;
		for (int i = 0, pos = size - 7; i < numAlign - 1; i++, pos -= step)
			result.insert(result.begin(), pos);
		result.insert(result.begin(), 6);
		return result;
	}
}


int QrCode::getNumRawDataModules(int ver) {
#if !defined(ACE_ENGINE_QRCODE_ABLE)
	if (ver < MIN_VERSION || ver > MAX_VERSION)
		throw std::domain_error("Version number out of range");
#endif
	int result = (16 * ver + 128) * ver + 64;
	if (ver >= 2) {
		int numAlign = ver / 7 + 2;
		result -= (25 * numAlign - 10) * numAlign - 55;
		if (ver >= 7)
			result -= 36;
	}
#if !defined(ACE_ENGINE_QRCODE_ABLE)
	assert(208 <= result && result <= 29648);
#endif
	return result;
}


int QrCode::getNumDataCodewords(int ver, Ecc ecl) {
	return getNumRawDataModules(ver) / 8
		- ECC_CODEWORDS_PER_BLOCK    [static_cast<int>(ecl)][ver]
		* NUM_ERROR_CORRECTION_BLOCKS[static_cast<int>(ecl)][ver];
}


vector<uint8_t> QrCode::reedSolomonComputeDivisor(int degree) {
#if !defined(ACE_ENGINE_QRCODE_ABLE)
	if (degree < 1 || degree > 255)
		throw std::domain_error("Degree out of range");
#endif
	// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.
	// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array {255, 8, 93}.
	vector<uint8_t> result(static_cast<size_t>(degree));
	result.at(result.size() - 1) = 1;  // Start off with the monomial x^0
	
	// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
	// and drop the highest monomial term which is always 1x^degree.
	// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
	uint8_t root = 1;
	for (int i = 0; i < degree; i++) {
		// Multiply the current product by (x - r^i)
		for (size_t j = 0; j < result.size(); j++) {
			result.at(j) = reedSolomonMultiply(result.at(j), root);
#if defined(ACE_ENGINE_QRCODE_ABLE)
			if (!flag) {
				return result;
			}
#endif
			if (j + 1 < result.size())
				result.at(j) ^= result.at(j + 1);
		}
		root = reedSolomonMultiply(root, 0x02);
#if defined(ACE_ENGINE_QRCODE_ABLE)
		if (!flag) {
			return result;
		}
#endif
	}
	return result;
}


vector<uint8_t> QrCode::reedSolomonComputeRemainder(const vector<uint8_t> &data, const vector<uint8_t> &divisor) {
	vector<uint8_t> result(divisor.size());
	for (uint8_t b : data) {  // Polynomial division
		uint8_t factor = b ^ result.at(0);
		result.erase(result.begin());
		result.push_back(0);
#if defined(ACE_ENGINE_QRCODE_ABLE)
		for (size_t i = 0; i < result.size(); i++) {
			result.at(i) ^= reedSolomonMultiply(divisor.at(i), factor);
			if (!flag) {
				return result;
			}
		}
#else
		for (size_t i = 0; i < result.size(); i++)
			result.at(i) ^= reedSolomonMultiply(divisor.at(i), factor);
#endif
	}
	return result;
}


uint8_t QrCode::reedSolomonMultiply(uint8_t x, uint8_t y) {
	// Russian peasant multiplication
	int z = 0;
	for (int i = 7; i >= 0; i--) {
		z = (z << 1) ^ ((z >> 7) * 0x11D);
		z ^= ((y >> i) & 1) * x;
	}
#if defined(ACE_ENGINE_QRCODE_ABLE)
 	if (z >> 8 != 0)
		flag = false;
	return static_cast<uint8_t>(z);
#else
	assert(z >> 8 == 0);
	return static_cast<uint8_t>(z);
#endif
}

#if !defined(ACE_ENGINE_QRCODE_ABLE)
int QrCode::finderPenaltyCountPatterns(const std::array<int,7> &runHistory) const {
	int n = runHistory.at(1);
	assert(n <= size * 3);
	bool core = n > 0 && runHistory.at(2) == n && runHistory.at(3) == n * 3 && runHistory.at(4) == n && runHistory.at(5) == n;
	return (core && runHistory.at(0) >= n * 4 && runHistory.at(6) >= n ? 1 : 0)
	     + (core && runHistory.at(6) >= n * 4 && runHistory.at(0) >= n ? 1 : 0);
}


int QrCode::finderPenaltyTerminateAndCount(bool currentRunColor, int currentRunLength, std::array<int,7> &runHistory) const {
	if (currentRunColor) {  // Terminate dark run
		finderPenaltyAddHistory(currentRunLength, runHistory);
		currentRunLength = 0;
	}
	currentRunLength += size;  // Add light border to final run
	finderPenaltyAddHistory(currentRunLength, runHistory);
	return finderPenaltyCountPatterns(runHistory);
}


void QrCode::finderPenaltyAddHistory(int currentRunLength, std::array<int,7> &runHistory) const {
	if (runHistory.at(0) == 0)
		currentRunLength += size;  // Add light border to initial run
	std::copy_backward(runHistory.cbegin(), runHistory.cend() - 1, runHistory.end());
	runHistory.at(0) = currentRunLength;
}
#endif

#if defined(ACE_ENGINE_QRCODE_ABLE)
void QrCode::clearFunctionPatterns()
{
	isFunction.clear();
	isFunction.shrink_to_fit();
}
#endif


bool QrCode::getBit(long x, int i) {
	return ((x >> i) & 1) != 0;
}


/*---- Tables of constants ----*/

#if !defined(ACE_ENGINE_QRCODE_ABLE)
const int QrCode::PENALTY_N1 =  3;
const int QrCode::PENALTY_N2 =  3;
const int QrCode::PENALTY_N3 = 40;
const int QrCode::PENALTY_N4 = 10;
#endif


const int8_t QrCode::ECC_CODEWORDS_PER_BLOCK[4][41] = {
	// Version: (note that index 0 is for padding, and is set to an illegal value)
	//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
	{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low
	{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium
	{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile
	{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High
};

const int8_t QrCode::NUM_ERROR_CORRECTION_BLOCKS[4][41] = {
	// Version: (note that index 0 is for padding, and is set to an illegal value)
	//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
	{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low
	{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium
	{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile
	{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High
};


#if !defined(ACE_ENGINE_QRCODE_ABLE)
data_too_long::data_too_long(const std::string &msg) :
	std::length_error(msg) {}
#endif



/*---- Class BitBuffer ----*/

BitBuffer::BitBuffer()
	: std::vector<bool>() {}


void BitBuffer::appendBits(std::uint32_t val, int len) {
#if defined(ACE_ENGINE_QRCODE_ABLE)
 	if (len < 0 || len > 31 || val >> len != 0)
		return;
#else
	if (len < 0 || len > 31 || val >> len != 0)
		throw std::domain_error("Value out of range");
#endif
	for (int i = len - 1; i >= 0; i--)  // Append bit by bit
		this->push_back(((val >> i) & 1) != 0);
}

}
Function: 
fn add_ecc_and_interleave<'b>(data: &[u8], ver: Version, ecl: QrCodeEcc, temp: &mut [u8], resultbuf: &'b mut [u8]) -> &'b [u8] {
		assert_eq!(data.len(), QrCode::get_num_data_codewords(ver, ecl));
		
		// Calculate parameter numbers
		let numblocks: usize = QrCode::table_get(&NUM_ERROR_CORRECTION_BLOCKS, ver, ecl);
		let blockecclen: usize = QrCode::table_get(&ECC_CODEWORDS_PER_BLOCK  , ver, ecl);
		let rawcodewords: usize = QrCode::get_num_raw_data_modules(ver) / 8;
		let numshortblocks: usize = numblocks - rawcodewords % numblocks;
		let shortblockdatalen: usize = rawcodewords / numblocks - blockecclen;
		let result = &mut resultbuf[ .. rawcodewords];
		
		// Split data into blocks, calculate ECC, and interleave
		// (not concatenate) the bytes into a single sequence
		let rs = ReedSolomonGenerator::new(blockecclen);
		let mut dat: &[u8] = data;
		let ecc: &mut [u8] = &mut temp[ .. blockecclen];  // Temporary storage
		for i in 0 .. numblocks {
			let datlen: usize = shortblockdatalen + usize::from(i >= numshortblocks);
			rs.compute_remainder(&dat[ .. datlen], ecc);
			let mut k: usize = i;
			for j in 0 .. datlen {  // Copy data
				if j == shortblockdatalen {
					k -= numshortblocks;
				}
				result[k] = dat[j];
				k += numblocks;
			}
			let mut k: usize = data.len() + i;
			for j in 0 .. blockecclen {  // Copy ECC
				result[k] = ecc[j];
				k += numblocks;
			}
			dat = &dat[datlen .. ];
		}
		debug_assert_eq!(dat.len(), 0);
		result
	}
Unixcoder Score: -0.018528174608945847
--------------------------------------------------
C_Code: 
bool AllowInvalidUTF8(const FieldDescriptor* field) { return false; }
Function: 
pub fn chars(&self) -> impl Iterator<Item = char> + '_ + fmt::Debug {
        Utf8Chunks::new(self.as_bytes()).flat_map(|chunk| {
            let mut yield_replacement_char = !chunk.invalid().is_empty();
            chunk.valid().chars().chain(iter::from_fn(move || {
                // Yield a single replacement character for every
                // non-empty invalid sequence.
                yield_replacement_char.then(|| {
                    yield_replacement_char = false;
                    char::REPLACEMENT_CHARACTER
                })
            }))
        })
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__addEccAndInterleave__idx144374_rank3.c", "source_rust_file": "Partial__addEccAndInterleave__idx144374_rank3.rs", "c_api": "getBit(data.at(i >> 3), 7 - static_cast<int>(i & 7))", "rust_api": "get_bit(u32::from(data[i >> 3]), 7 - ((i as i32) & 7))", "mapping_type": "function", "description": "Extract a specific bit from a byte at a given index", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Entity Name Check] -> [Filter 2: Empty/Trivial Code] -> [Filter 3: FFI Wrapper] -> [Filter 4: Semantic Domain Mismatch] -> [Filter 5: Empty Structs] -> [Filter 6: Definition vs Usage Asymmetry] -> [Full/Partial/API Analysis] -> [Structural Fragments] -> [API Mappings]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__addEccAndInterleave__idx144374_rank3.c", "source_rust_file": "Partial__addEccAndInterleave__idx144374_rank3.rs", "c_api": "modules.at(y).at(x)", "rust_api": "*self.module_mut(x, y)", "mapping_type": "field_access", "description": "Access and modify a QR code module at coordinates (x, y)", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Entity Name Check] -> [Filter 2: Empty/Trivial Code] -> [Filter 3: FFI Wrapper] -> [Filter 4: Semantic Domain Mismatch] -> [Filter 5: Empty Structs] -> [Filter 6: Definition vs Usage Asymmetry] -> [Full/Partial/API Analysis] -> [Structural Fragments] -> [API Mappings]"}, {"knowledge_type": "Partial", "source_c_file": "Partial__addEccAndInterleave__idx144374_rank3.c", "source_rust_file": "Partial__addEccAndInterleave__idx144374_rank3.rs", "c_fragment": "size_t i = 0;  // Bit index into the data\n\t// Do the funny zigzag scan\n\tfor (int right = size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair\n\t\tif (right == 6)\n\t\t\tright = 5;\n\t\tfor (int vert = 0; vert < size; vert++) {  // Vertical counter\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tsize_t x = static_cast<size_t>(right - j);  // Actual x coordinate\n\t\t\t\tbool upward = ((right + 1) & 2) == 0;\n\t\t\t\tsize_t y = static_cast<size_t>(upward ? size - 1 - vert : vert);  // Actual y coordinate\n\t\t\t\tif (!isFunction.at(y).at(x) && i < data.size() * 8) {\n\t\t\t\t\tmodules.at(y).at(x) = getBit(data.at(i >> 3), 7 - static_cast<int>(i & 7));\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t// If this QR Code has any remainder bits (0 to 7), they were assigned as\n\t\t\t\t// 0/false/light by the constructor and are left unchanged by this method\n\t\t\t}\n\t\t}\n\t}", "rust_fragment": "let mut i: usize = 0;  // Bit index into the data\n\t\t// Do the funny zigzag scan\n\t\tlet mut right: i32 = self.size - 1;\n\t\twhile right >= 1 {  // Index of right column in each column pair\n\t\t\tif right == 6 {\n\t\t\t\tright = 5;\n\t\t\t}\n\t\t\tfor vert in 0 .. self.size {  // Vertical counter\n\t\t\t\tfor j in 0 .. 2 {\n\t\t\t\t\tlet x: i32 = right - j;  // Actual x coordinate\n\t\t\t\t\tlet upward: bool = (right + 1) & 2 == 0;\n\t\t\t\t\tlet y: i32 = if upward { self.size - 1 - vert } else { vert };  // Actual y coordinate\n\t\t\t\t\tif !self.isfunction[(y * self.size + x) as usize] && i < data.len() * 8 {\n\t\t\t\t\t\t*self.module_mut(x, y) = get_bit(u32::from(data[i >> 3]), 7 - ((i as i32) & 7));\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t}\n\t\t\t\t\t// If this QR Code has any remainder bits (0 to 7), they were assigned as\n\t\t\t\t\t// 0/false/light by the constructor and are left unchanged by this method\n\t\t\t\t}\n\t\t\t}\n\t\t\tright -= 2;\n\t\t}", "description": "Zigzag scanning algorithm for drawing QR code modules from bit data", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Entity Name Check] -> [Filter 2: Empty/Trivial Code] -> [Filter 3: FFI Wrapper] -> [Filter 4: Semantic Domain Mismatch] -> [Filter 5: Empty Structs] -> [Filter 6: Definition vs Usage Asymmetry] -> [Full/Partial/API Analysis] -> [Structural Fragments] -> [API Mappings]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__addEccAndInterleave__idx144374_rank3.c", "source_rust_file": "Partial__addEccAndInterleave__idx144374_rank3.rs", "c_api": "isFunction.at(y).at(x)", "rust_api": "self.isfunction[(y * self.size + x) as usize]", "mapping_type": "field_access", "description": "Check if a QR code module is a function pattern", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Entity Name Check] -> [Filter 2: Empty/Trivial Code] -> [Filter 3: FFI Wrapper] -> [Filter 4: Semantic Domain Mismatch] -> [Filter 5: Empty Structs] -> [Filter 6: Definition vs Usage Asymmetry] -> [Full/Partial/API Analysis] -> [Structural Fragments] -> [API Mappings]"}]
Unixcoder Score: -0.02708425559103489
--------------------------------------------------
