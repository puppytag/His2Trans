C_Code: 
bool IsBool() const { return type_ == FBT_BOOL; }
Function: 
pub fn get_bool(&self) -> Result<bool, Error> {
        self.expect_type(FlexBufferType::Bool)?;
        Ok(
            self.buffer[self.address..self.address + self.width.n_bytes()]
                .iter()
                .any(|&b| b != 0),
        )
    }
Unixcoder Score: 0.07429280877113342
--------------------------------------------------
C_Code: 
bool IsBool() const { return type_ == FBT_BOOL; }
Function: 
pub fn as_bool(&self) -> bool {
        use FlexBufferType::*;
        match self.fxb_type {
            Bool => self.get_bool().unwrap_or_default(),
            UInt => self.as_u64() != 0,
            Int => self.as_i64() != 0,
            Float => self.as_f64().abs() > std::f64::EPSILON,
            String | Key => !self.as_str().is_empty(),
            Null => false,
            Blob => self.length() != 0,
            ty if ty.is_vector() => self.length() != 0,
            _ => unreachable!(),
        }
    }
Unixcoder Score: 0.06932065635919571
--------------------------------------------------
C_Code: 
bool IsBool() const { return type_ == FBT_BOOL; }
Function: 
pub fn as_bool(&self) -> bool {
        use FlexBufferType::*;
        match self.fxb_type {
            Bool => self.get_bool().unwrap_or_default(),
            UInt => self.as_u64() != 0,
            Int => self.as_i64() != 0,
            Float => self.as_f64().abs() > std::f64::EPSILON,
            String | Key => !self.as_str().is_empty(),
            Null => false,
            Blob => self.length() != 0,
            ty if ty.is_vector() => self.length() != 0,
            _ => unreachable!(),
        }
    }
Unixcoder Score: 0.0635637491941452
--------------------------------------------------
C_Code: 
bool IsBool() const { return type_ == FBT_BOOL; }
Function: 
pub fn get_bool(&self) -> Result<bool, Error> {
        self.expect_type(FlexBufferType::Bool)?;
        Ok(
            self.buffer[self.address..self.address + self.width.n_bytes()]
                .iter()
                .any(|&b| b != 0),
        )
    }
Unixcoder Score: 0.061586812138557434
--------------------------------------------------
C_Code: 
bool IsFloat() const {
    return type_ == FBT_FLOAT || type_ == FBT_INDIRECT_FLOAT;
  }
Function: 
pub fn get_f64(&self) -> Result<f64, Error> {
        self.expect_type(FlexBufferType::Float)?;
        let cursor = self
            .buffer
            .get(self.address..self.address + self.width.n_bytes());
        match self.width {
            BitWidth::W8 | BitWidth::W16 => return Err(Error::InvalidPackedType),
            BitWidth::W32 => cursor
                .and_then(|s| s.try_into().ok())
                .map(f32_from_le_bytes)
                .map(Into::into),
            BitWidth::W64 => cursor
                .and_then(|s| s.try_into().ok())
                .map(f64_from_le_bytes),
        }
        .ok_or(Error::FlexbufferOutOfBounds)
    }
Unixcoder Score: -0.005042156204581261
--------------------------------------------------
C_Code: 
bool IsInt() const { return type_ == FBT_INT || type_ == FBT_INDIRECT_INT; }
Function: 
fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ser::Serializer,
    {
        #[allow(deprecated)]
        match (self.flexbuffer_type(), self.bitwidth()) {
            (Null, _) => serializer.serialize_unit(),
            (Int, W8) | (IndirectInt, W8) => serializer.serialize_i8(self.as_i8()),
            (Int, W16) | (IndirectInt, W16) => serializer.serialize_i16(self.as_i16()),
            (Int, W32) | (IndirectInt, W32) => serializer.serialize_i32(self.as_i32()),
            (Int, W64) | (IndirectInt, W64) => serializer.serialize_i64(self.as_i64()),
            (UInt, W8) | (IndirectUInt, W8) => serializer.serialize_u8(self.as_u8()),
            (UInt, W16) | (IndirectUInt, W16) => serializer.serialize_u16(self.as_u16()),
            (UInt, W32) | (IndirectUInt, W32) => serializer.serialize_u32(self.as_u32()),
            (UInt, W64) | (IndirectUInt, W64) => serializer.serialize_u64(self.as_u64()),
            (Float, W32) | (IndirectFloat, W32) => serializer.serialize_f32(self.as_f32()),
            (Float, _) | (IndirectFloat, _) => serializer.serialize_f64(self.as_f64()),
            (Bool, _) => serializer.serialize_bool(self.as_bool()),
            (Key, _) | (String, _) => serializer.serialize_str(&self.as_str()),
            (Map, _) => {
                let m = self.as_map();
                let mut map_serializer = serializer.serialize_map(Some(m.len()))?;
                for (k, v) in m.iter_keys().zip(m.iter_values()) {
                    map_serializer.serialize_key(&&k)?;
                    map_serializer.serialize_value(&&v)?;
                }
                map_serializer.end()
            }
            (Vector, _)
            | (VectorInt, _)
            | (VectorUInt, _)
            | (VectorFloat, _)
            | (VectorKey, _)
            | (VectorString, _)
            | (VectorBool, _)
            | (VectorInt2, _)
            | (VectorUInt2, _)
            | (VectorFloat2, _)
            | (VectorInt3, _)
            | (VectorUInt3, _)
            | (VectorFloat3, _)
            | (VectorInt4, _)
            | (VectorUInt4, _)
            | (VectorFloat4, _) => {
                let v = self.as_vector();
                let mut seq_serializer = serializer.serialize_seq(Some(v.len()))?;
                for x in v.iter() {
                    seq_serializer.serialize_element(&&x)?;
                }
                seq_serializer.end()
            }
            (Blob, _) => serializer.serialize_bytes(&self.as_blob().0),
        }
    }
Unixcoder Score: -0.011429985985159874
--------------------------------------------------
C_Code: 
bool IsInt() const { return type_ == FBT_INT || type_ == FBT_INDIRECT_INT; }
Function: 
pub fn to_direct(self) -> Option<Self> {
        match self {
            IndirectInt => Some(Int),
            IndirectUInt => Some(UInt),
            IndirectFloat => Some(Float),
            _ => None,
        }
    }
Unixcoder Score: -0.019526632502675056
--------------------------------------------------
C_Code: 
bool IsFloat() const {
    return type_ == FBT_FLOAT || type_ == FBT_INDIRECT_FLOAT;
  }
Function: 
pub fn get_f64(&self) -> Result<f64, Error> {
        self.expect_type(FlexBufferType::Float)?;
        let cursor = self
            .buffer
            .get(self.address..self.address + self.width.n_bytes());
        match self.width {
            BitWidth::W8 | BitWidth::W16 => return Err(Error::InvalidPackedType),
            BitWidth::W32 => cursor
                .and_then(|s| s.try_into().ok())
                .map(f32_from_le_bytes)
                .map(Into::into),
            BitWidth::W64 => cursor
                .and_then(|s| s.try_into().ok())
                .map(f64_from_le_bytes),
        }
        .ok_or(Error::FlexbufferOutOfBounds)
    }
Unixcoder Score: -0.027905691415071487
--------------------------------------------------
C_Code: 
bool IsTheEmptyVector() const { return data_ == EmptyVector().data_; }
Function: 
pub fn is_empty(&self) -> bool {
        self.length == 0
    }
Unixcoder Score: -0.033709049224853516
--------------------------------------------------
C_Code: 
bool IsTheEmptyVector() const { return data_ == EmptyVector().data_; }
Function: 
pub fn is_empty(&self) -> bool {
        self.length == 0
    }
Unixcoder Score: -0.03382064029574394
--------------------------------------------------
