C_Code: 
static size_t find_first_larger(const std::vector<T>& list, T value) {
    return (size_t)(std::upper_bound(list.begin(), list.end(), value) - list.begin());
}
Function: 
fn best_strike_size<T>(strikes: impl Iterator<Item = T>, font_size: f32) -> Option<T>
    where
        T: StrikeSizeRetrievable,
    {
        // After a bigger strike size is found, the order of strike sizes smaller
        // than the requested font size does not matter anymore. A new strike size
        // is only an improvement if it gets closer to the requested font size (and
        // is smaller than the current best, but bigger than font size). And vice
        // versa: As long as we have found only smaller ones so far, only any strike
        // size matters that is bigger than the current best.
        strikes.reduce(|best, entry| {
            let entry_size = entry.strike_size();
            if (entry_size >= font_size && entry_size < best.strike_size())
                || (best.strike_size() < font_size && entry_size > best.strike_size())
            {
                entry
            } else {
                best
            }
        })
    }
Unixcoder Score: 0.03533106669783592
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
pub(crate) struct CertManager {
    info: Arc<RwLock<CertInfo>>,
}
Unixcoder Score: 0.0313076376914978
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
pub(crate) struct CertManager {
    info: Arc<RwLock<CertInfo>>,
}
Unixcoder Score: 0.029258806258440018
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
pub(crate) struct CertManager {
    info: Arc<RwLock<CertInfo>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_api": "want.GetStringParam(DEVELOPER_ID)", "rust_api": "developer_id: ConstAssetBlob", "mapping_type": "function", "description": "Retrieval of developer ID parameter from input", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "Partial", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_fragment": "std::string groupIds = want.GetStringParam(GROUP_IDS);\n    std::vector<ConstAssetBlob> groupIdBlobs;\n    std::vector<std::string> groupIdStrs;\n    ConstAssetBlobArray groupIdBlobArray;\n    ParseGroupIds(groupIds, groupIdStrs, groupIdBlobs, groupIdBlobArray);", "rust_fragment": "let group_ids_slice = unsafe { slice::from_raw_parts(group_ids.blobs, group_ids.size as usize) };", "description": "Both process group IDs from input parameters. C parses group IDs into arrays, Rust slices the group IDs array for processing.", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_api": "ParseGroupIds(groupIds, groupIdStrs, groupIdBlobs, groupIdBlobArray)", "rust_api": "let group_ids_slice = unsafe { slice::from_raw_parts(group_ids.blobs, group_ids.size as usize) };", "mapping_type": "function", "description": "Parsing of group IDs into structured data", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_api": "LOGI(...)", "rust_api": "LOGI(...)", "mapping_type": "function", "description": "Logging of informational messages", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_api": "want.GetStringParam(GROUP_IDS)", "rust_api": "group_ids: ConstAssetBlobArray", "mapping_type": "function", "description": "Retrieval of group IDs parameter from input", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_api": "want.GetBundle()", "rust_api": "bundleNameBlob", "mapping_type": "function", "description": "Retrieval of bundle name parameter from input", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_api": "want.GetIntParam(USER_ID, INVALID_USERID)", "rust_api": "user_id: i32", "mapping_type": "function", "description": "Retrieval of user ID parameter from input", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "Partial", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_fragment": "if (appId.empty() || userId == INVALID_USERID || appIndex == -1) {\n        LOGE(\"[FATAL]Get removed owner info failed, userId=%{public}d, appId=%{public}s, appIndex=%{public}d\",\n            userId, appId.c_str(), appIndex);\n        return;\n    }", "rust_fragment": "if !group_ids.blobs.is_null() && group_ids.size != 0 && !developer_id.data.is_null() && developer_id.size != 0 {", "description": "Both perform validation checks before proceeding with logic. C checks for empty or invalid parameters, Rust checks for null pointers and zero size.", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_api": "LOGE(...)", "rust_api": "loge!([FATAL]Get GetUninstallGroups failed, res is {}.)", "mapping_type": "function", "description": "Logging of error messages", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_api": "want.GetStringParam(APP_ID)", "rust_api": "owner: Vec<u8>", "mapping_type": "function", "description": "Retrieval of application ID parameter from input", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}, {"knowledge_type": "Partial", "source_c_file": "Partial__HandlePackageRemoved__idx4483_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4483_rank2.rs", "c_fragment": "std::string owner = appId + OWNER_INFO_SEPARATOR + std::to_string(appIndex);\n    ConstAssetBlob ownerBlob = { .size = owner.size(), .data = reinterpret_cast<const uint8_t *>(owner.c_str()) };", "rust_fragment": "let mut calling_infos = vec![CallingInfo::new(user_id, OwnerType::Hap, owner.clone(), None)];", "description": "Both construct an owner identifier from app ID and index. C builds a string and wraps it in a blob, Rust creates a CallingInfo with owner data.", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Full/Partial/API Mapping] -> [Final Classification]"}]
Unixcoder Score: 0.029194556176662445
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
struct CertInfo {
    cert: Option<Vec<Certificate>>,
}
Unixcoder Score: 0.028597844764590263
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
struct CertInfo {
    cert: Option<Vec<Certificate>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetSchemaKey__idx5200_rank2.c", "source_rust_file": "Partial__GetSchemaKey__idx5200_rank2.rs", "c_api": "keys.insert_or_assign(app.bundleName, key)", "rust_api": "cloud_info.apps.insert(cloud_app_info.bundle_name.clone(), cloud_app_info)", "mapping_type": "function", "description": "Inserting key-value pairs into a map-like data structure", "reasoning": "[Task Analysis] C function returns a map of schema keys, Rust function builds cloud info with app data. [Similarity] Names don't match but both involve mapping/iterating over data and building a result structure. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for data insertion/assignment."}, {"knowledge_type": "Partial", "source_c_file": "Partial__GetSchemaKey__idx5200_rank2.c", "source_rust_file": "Partial__GetSchemaKey__idx5200_rank2.rs", "c_fragment": "for (const auto &[bundle, app] : apps) {\n        const auto key = GetKey(SCHEMA_PREFIX, { std::to_string(user), bundle, std::to_string(app.instanceId) });\n        keys.insert_or_assign(app.bundleName, key);\n    }", "rust_fragment": "for app in &app_infos.0 {\n            let cloud_app_info = AppInfo::from(app.1);\n            cloud_info\n                .apps\n                .insert(cloud_app_info.bundle_name.clone(), cloud_app_info);\n        }", "description": "Both iterate over collections and insert data into a map-like structure.", "reasoning": "[Task Analysis] C function returns a map of schema keys, Rust function builds cloud info with app data. [Similarity] Names don't match but both involve mapping/iterating over data and building a result structure. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for data insertion/assignment."}]
Unixcoder Score: 0.02759048528969288
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
struct CertInfo {
    cert: Option<Vec<Certificate>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5215_rank2.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5215_rank2.rs", "c_api": "appInfos.begin()", "rust_api": "appInfos.iter()", "mapping_type": "method", "description": "Iterate over hashmap", "reasoning": "[Task Analysis] C function checks equality of two maps; Rust function retrieves a reference to a map. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there is a data access pattern mapping."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5215_rank2.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5215_rank2.rs", "c_api": "apps.size()", "rust_api": "self.apps.len()", "mapping_type": "method", "description": "Get size of hashmap", "reasoning": "[Task Analysis] C function checks equality of two maps; Rust function retrieves a reference to a map. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there is a data access pattern mapping."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5215_rank2.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5215_rank2.rs", "c_api": "apps.begin()", "rust_api": "self.apps.iter()", "mapping_type": "method", "description": "Iterate over hashmap", "reasoning": "[Task Analysis] C function checks equality of two maps; Rust function retrieves a reference to a map. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there is a data access pattern mapping."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5215_rank2.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5215_rank2.rs", "c_api": "appInfos.size()", "rust_api": "appInfos.len()", "mapping_type": "method", "description": "Get size of hashmap", "reasoning": "[Task Analysis] C function checks equality of two maps; Rust function retrieves a reference to a map. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there is a data access pattern mapping."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5215_rank2.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5215_rank2.rs", "c_api": "it->second", "rust_api": "it.1", "mapping_type": "field_access", "description": "Access value in hashmap entry", "reasoning": "[Task Analysis] C function checks equality of two maps; Rust function retrieves a reference to a map. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there is a data access pattern mapping."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5215_rank2.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5215_rank2.rs", "c_api": "rIt->second", "rust_api": "rIt.1", "mapping_type": "field_access", "description": "Access value in hashmap entry", "reasoning": "[Task Analysis] C function checks equality of two maps; Rust function retrieves a reference to a map. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there is a data access pattern mapping."}]
Unixcoder Score: 0.026604674756526947
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
pub(crate) struct CertManager {
    info: Arc<RwLock<CertInfo>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5209_rank4.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5209_rank4.rs", "c_api": "apps.size()", "rust_api": "value.account_id.clone()", "mapping_type": "field_access", "description": "Accessing account ID field from ServiceInfo", "reasoning": "[Task Analysis] C function checks equality of maps; Rust function converts from ServiceInfo to CloudInfo. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to map/struct initialization and field access."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5209_rank4.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5209_rank4.rs", "c_api": "apps.begin()", "rust_api": "Default::default()", "mapping_type": "pattern", "description": "Initializing empty apps map in Rust", "reasoning": "[Task Analysis] C function checks equality of maps; Rust function converts from ServiceInfo to CloudInfo. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to map/struct initialization and field access."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5209_rank4.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5209_rank4.rs", "c_api": "it->second", "rust_api": "value.remain_space", "mapping_type": "field_access", "description": "Accessing remain space field from ServiceInfo", "reasoning": "[Task Analysis] C function checks equality of maps; Rust function converts from ServiceInfo to CloudInfo. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to map/struct initialization and field access."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5209_rank4.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5209_rank4.rs", "c_api": "appInfos.size()", "rust_api": "value.total_space", "mapping_type": "field_access", "description": "Accessing total space field from ServiceInfo", "reasoning": "[Task Analysis] C function checks equality of maps; Rust function converts from ServiceInfo to CloudInfo. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to map/struct initialization and field access."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__IsAppsEqual__idx5209_rank4.c", "source_rust_file": "API_Mapping__IsAppsEqual__idx5209_rank4.rs", "c_api": "rIt->second", "rust_api": "value.enable_cloud", "mapping_type": "field_access", "description": "Accessing enable cloud field from ServiceInfo", "reasoning": "[Task Analysis] C function checks equality of maps; Rust function converts from ServiceInfo to CloudInfo. [Similarity] No structural similarity in logic or control flow. [Knowledge Extraction] No full match, no partial match, but there are API mappings related to map/struct initialization and field access."}]
Unixcoder Score: 0.025335397571325302
--------------------------------------------------
C_Code: 
struct CertList
Function: 
pub(crate) struct SystemConfig {
    pub(crate) proxy_host: String,
    pub(crate) proxy_port: String,
    pub(crate) proxy_exlist: String,
    pub(crate) certs: Option<Vec<Certificate>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__FreeCertData__idx555_rank5.c", "source_rust_file": "Partial__FreeCertData__idx555_rank5.rs", "c_fragment": "if (cert == nullptr) {\n        return;\n    }\n\n    if (cert->data != nullptr) {\n        free(cert->data);\n        cert->data = nullptr;\n    }\n    cert->size = 0;\n    free(cert);", "rust_fragment": "unsafe { FreeCertDataList(c_certs_ptr) };", "description": "Memory deallocation pattern: freeing allocated memory for certificate data and list.", "reasoning": "[Task Analysis] C function frees memory allocated for a cert struct and its data; Rust function retrieves cert data via FFI, processes it, and updates cert info. [Similarity] No full structural match due to different domains (memory cleanup vs data processing), but partial matching fragments exist in memory handling patterns. [Knowledge Extraction] Extract API mappings for memory deallocation and data processing patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__FreeCertData__idx555_rank5.c", "source_rust_file": "Partial__FreeCertData__idx555_rank5.rs", "c_api": "free(cert)", "rust_api": "unsafe { FreeCertDataList(c_certs_ptr) }", "mapping_type": "function", "description": "Memory deallocation for certificate struct", "reasoning": "[Task Analysis] C function frees memory allocated for a cert struct and its data; Rust function retrieves cert data via FFI, processes it, and updates cert info. [Similarity] No full structural match due to different domains (memory cleanup vs data processing), but partial matching fragments exist in memory handling patterns. [Knowledge Extraction] Extract API mappings for memory deallocation and data processing patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__FreeCertData__idx555_rank5.c", "source_rust_file": "Partial__FreeCertData__idx555_rank5.rs", "c_api": "free(cert->data)", "rust_api": "unsafe { FreeCertDataList(c_certs_ptr) }", "mapping_type": "function", "description": "Memory deallocation for certificate data", "reasoning": "[Task Analysis] C function frees memory allocated for a cert struct and its data; Rust function retrieves cert data via FFI, processes it, and updates cert info. [Similarity] No full structural match due to different domains (memory cleanup vs data processing), but partial matching fragments exist in memory handling patterns. [Knowledge Extraction] Extract API mappings for memory deallocation and data processing patterns."}]
Unixcoder Score: 0.02195262350142002
--------------------------------------------------
C_Code: 
struct CertInfo
Function: 
struct CertInfo {
    cert: Option<Vec<Certificate>>,
}
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_fragment": "std::string appId = want.GetStringParam(APP_ID);\n    int appIndex = isSandBoxApp ? want.GetIntParam(SANDBOX_APP_INDEX, -1) : want.GetIntParam(APP_INDEX, -1);\n    if (appId.empty() || userId == INVALID_USERID || appIndex == -1) {\n        LOGE(\"[FATAL]Get removed owner info failed, userId=%{public}d, appId=%{public}s, appIndex=%{public}d\",\n            userId, appId.c_str(), appIndex);\n        return;\n    }\n    std::string owner = appId + OWNER_INFO_SEPARATOR + std::to_string(appIndex);\n    ConstAssetBlob ownerBlob = { .size = owner.size(), .data = reinterpret_cast<const uint8_t *>(owner.c_str()) };", "rust_fragment": "let owner: Vec<u8> = unsafe { slice::from_raw_parts(owner.data, owner.size as usize).to_vec() };", "description": "Both extract and process owner information from input parameters into a blob structure.", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_api": "want.GetIntParam(...)", "rust_api": "user_id: i32", "mapping_type": "function", "description": "Extracting integer parameter from input structure", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_api": "want.GetStringParam(APP_ID)", "rust_api": "owner: Vec<u8> = unsafe { slice::from_raw_parts(owner.data, owner.size as usize).to_vec() }", "mapping_type": "function", "description": "Extracting string parameter from input structure", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_api": "onPackageRemoved(...)", "rust_api": "delete_on_package_removed(&calling_info)", "mapping_type": "function", "description": "Invoking callback or operation with structured data", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_fragment": "if (onPackageRemoved != nullptr) {\n        onPackageRemoved({ userId, appIndex, ownerBlob, developerIdBlob, groupIdBlobArray, bundleNameBlob });\n    }", "rust_fragment": "for calling_info in construct_calling_infos(user_id, owner.clone(), developer_id, group_ids) {\n        clear_cryptos(&calling_info);\n        let res = match delete_on_package_removed(&calling_info) {", "description": "Both involve invoking a callback or operation with structured data after validation.", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_api": "ConstAssetBlob ownerBlob = { .size = owner.size(), .data = reinterpret_cast<const uint8_t *>(owner.c_str()) };", "rust_api": "let owner: Vec<u8> = unsafe { slice::from_raw_parts(owner.data, owner.size as usize).to_vec() };", "mapping_type": "type", "description": "Converting string to byte blob for data transfer", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}]
Unixcoder Score: 0.017141828313469887
--------------------------------------------------
