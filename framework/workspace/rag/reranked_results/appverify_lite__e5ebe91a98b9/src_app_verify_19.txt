C_Code: 
static uv_buf_t alloc_cb(uv_handle_t* handle, size_t size) {
  uv_buf_t buf;
  buf.base = (char*)malloc(size);
  buf.len = size;
  return buf;
}
Function: 
pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {
    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as libc::size_t };
    let out_buf_ptr = ptr::addr_of(&out_buf);
    log(debug, fmt!("buf_init - input %u len %u out_buf: %u",
                     input as uint,
                     len as uint,
                     out_buf_ptr as uint));
    // yuck :/
    rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);
    //let result = rustrt::rust_uv_buf_init_2(input, len as size_t);
    log(debug, ~"after rust_uv_buf_init");
    let res_base = get_base_from_buf(out_buf);
    let res_len = get_len_from_buf(out_buf);
    //let res_base = get_base_from_buf(result);
    log(debug, fmt!("buf_init - result %u len %u",
                     res_base as uint,
                     res_len as uint));
    return out_buf;
    //return result;
}
Unixcoder Score: 0.04315998777747154
--------------------------------------------------
C_Code: 
static uv_buf_t alloc_cb(uv_handle_t* handle, size_t size) {
  uv_buf_t buf;
  buf.base = (char*)malloc(size);
  buf.len = size;
  return buf;
}
Function: 
extern fn alloc_cb(stream: *uvll::uv_stream_t, _hint: size_t) -> Buf {
    let rcx: &mut ReadContext = unsafe {
        cast::transmute(uvll::get_data_for_uv_handle(stream))
    };
    rcx.buf.take().expect("alloc_cb called more than once")
}
Unixcoder Score: 0.033768028020858765
--------------------------------------------------
C_Code: 
static uint64_t
read_uleb128 (struct dwarf_buf *buf)
{
  uint64_t ret;
  unsigned int shift;
  int overflow;
  unsigned char b;

  ret = 0;
  shift = 0;
  overflow = 0;
  do
    {
      const unsigned char *p;

      p = buf->buf;
      if (!advance (buf, 1))
	return 0;
      b = *p;
      if (shift < 64)
	ret |= ((uint64_t) (b & 0x7f)) << shift;
      else if (!overflow)
	{
	  dwarf_buf_error (buf, "LEB128 overflows uint64_t");
	  overflow = 1;
	}
      shift += 7;
    }
  while ((b & 0x80) != 0);

  return ret;
}
Function: 
pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>) -> Result<EHAction, ()> {
    if lsda.is_null() {
        return Ok(EHAction::None);
    }

    let func_start = context.func_start;
    let mut reader = DwarfReader::new(lsda);

    let start_encoding = reader.read::<u8>();
    // base address for landing pad offsets
    let lpad_base = if start_encoding != DW_EH_PE_omit {
        read_encoded_pointer(&mut reader, context, start_encoding)?
    } else {
        func_start
    };

    let ttype_encoding = reader.read::<u8>();
    if ttype_encoding != DW_EH_PE_omit {
        // Rust doesn't analyze exception types, so we don't care about the type table
        reader.read_uleb128();
    }

    let call_site_encoding = reader.read::<u8>();
    let call_site_table_length = reader.read_uleb128();
    let action_table = reader.ptr.add(call_site_table_length as usize);
    let ip = context.ip;

    if !USING_SJLJ_EXCEPTIONS {
        while reader.ptr < action_table {
            let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding)?;
            let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding)?;
            let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding)?;
            let cs_action_entry = reader.read_uleb128();
            // Callsite table is sorted by cs_start, so if we've passed the ip, we
            // may stop searching.
            if ip < func_start + cs_start {
                break;
            }
            if ip < func_start + cs_start + cs_len {
                if cs_lpad == 0 {
                    return Ok(EHAction::None);
                } else {
                    let lpad = lpad_base + cs_lpad;
                    return Ok(interpret_cs_action(action_table as *mut u8, cs_action_entry, lpad));
                }
            }
        }
        // Ip is not present in the table. This indicates a nounwind call.
        Ok(EHAction::Terminate)
    } else {
        // SjLj version:
        // The "IP" is an index into the call-site table, with two exceptions:
        // -1 means 'no-action', and 0 means 'terminate'.
        match ip as isize {
            -1 => return Ok(EHAction::None),
            0 => return Ok(EHAction::Terminate),
            _ => (),
        }
        let mut idx = ip;
        loop {
            let cs_lpad = reader.read_uleb128();
            let cs_action_entry = reader.read_uleb128();
            idx -= 1;
            if idx == 0 {
                // Can never have null landing pad for sjlj -- that would have
                // been indicated by a -1 call site index.
                let lpad = (cs_lpad + 1) as usize;
                return Ok(interpret_cs_action(action_table as *mut u8, cs_action_entry, lpad));
            }
        }
    }
}
Extracted_Knowledge: 
[{"knowledge_type": "Full", "source_c_file": "Full__uv_queue_read__idx143302_rank1.c", "source_rust_file": "Full__uv_queue_read__idx143302_rank1.rs", "reasoning": "[FFI Check] -> The C code makes a direct FFI call to WSARecv and WSAGetLastError, and the Rust code calls c::WSARecv and c::WSAGetLastError, indicating FFI usage. [Task Analysis] -> Both functions handle asynchronous socket read operations using overlapped I/O on Windows. [Similarity] -> The core logic is semantically equivalent: both perform a WSARecv call with similar parameters and handle the result, including error cases. [Knowledge Extraction] -> Full structural similarity exists in the core I/O handling pattern, with API mappings for FFI functions and error handling patterns.", "description": "Full structural translation"}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__uv_queue_read__idx143302_rank1.c", "source_rust_file": "Full__uv_queue_read__idx143302_rank1.rs", "c_api": "uv_new_sys_error", "rust_api": "io::Error::from_raw_os_error", "mapping_type": "function", "description": "Convert system error code to Rust error type", "reasoning": "[FFI Check] -> The C code makes a direct FFI call to WSARecv and WSAGetLastError, and the Rust code calls c::WSARecv and c::WSAGetLastError, indicating FFI usage. [Task Analysis] -> Both functions handle asynchronous socket read operations using overlapped I/O on Windows. [Similarity] -> The core logic is semantically equivalent: both perform a WSARecv call with similar parameters and handle the result, including error cases. [Knowledge Extraction] -> Full structural similarity exists in the core I/O handling pattern, with API mappings for FFI functions and error handling patterns."}, {"knowledge_type": "Partial", "source_c_file": "Full__uv_queue_read__idx143302_rank1.c", "source_rust_file": "Full__uv_queue_read__idx143302_rank1.rs", "c_fragment": "if (result != 0 && WSAGetLastError() != ERROR_IO_PENDING) {\n    /* Make this req pending reporting an error. */\n    req->error = uv_new_sys_error(WSAGetLastError());\n    uv_insert_pending_req(req);\n    return;\n  }\n\n  req->flags |= UV_REQ_PENDING;\n  handle->reqs_pending++;", "rust_fragment": "match result {\n            0 => Ok(nread as usize),\n            _ => {\n                let error = unsafe { c::WSAGetLastError() };\n\n                if error == c::WSAESHUTDOWN {\n                    Ok(0)\n                } else {\n                    Err(io::Error::from_raw_os_error(error))\n                }\n            }\n        }", "description": "Both handle the result of WSARecv, with error cases and appropriate return values or error reporting.", "reasoning": "[FFI Check] -> The C code makes a direct FFI call to WSARecv and WSAGetLastError, and the Rust code calls c::WSARecv and c::WSAGetLastError, indicating FFI usage. [Task Analysis] -> Both functions handle asynchronous socket read operations using overlapped I/O on Windows. [Similarity] -> The core logic is semantically equivalent: both perform a WSARecv call with similar parameters and handle the result, including error cases. [Knowledge Extraction] -> Full structural similarity exists in the core I/O handling pattern, with API mappings for FFI functions and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__uv_queue_read__idx143302_rank1.c", "source_rust_file": "Full__uv_queue_read__idx143302_rank1.rs", "c_api": "uv_insert_pending_req", "rust_api": "return Ok(0) or Err(...)", "mapping_type": "function", "description": "Mark request as pending with error or success", "reasoning": "[FFI Check] -> The C code makes a direct FFI call to WSARecv and WSAGetLastError, and the Rust code calls c::WSARecv and c::WSAGetLastError, indicating FFI usage. [Task Analysis] -> Both functions handle asynchronous socket read operations using overlapped I/O on Windows. [Similarity] -> The core logic is semantically equivalent: both perform a WSARecv call with similar parameters and handle the result, including error cases. [Knowledge Extraction] -> Full structural similarity exists in the core I/O handling pattern, with API mappings for FFI functions and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__uv_queue_read__idx143302_rank1.c", "source_rust_file": "Full__uv_queue_read__idx143302_rank1.rs", "c_api": "WSARecv", "rust_api": "c::WSARecv", "mapping_type": "function", "description": "Asynchronous socket receive operation", "reasoning": "[FFI Check] -> The C code makes a direct FFI call to WSARecv and WSAGetLastError, and the Rust code calls c::WSARecv and c::WSAGetLastError, indicating FFI usage. [Task Analysis] -> Both functions handle asynchronous socket read operations using overlapped I/O on Windows. [Similarity] -> The core logic is semantically equivalent: both perform a WSARecv call with similar parameters and handle the result, including error cases. [Knowledge Extraction] -> Full structural similarity exists in the core I/O handling pattern, with API mappings for FFI functions and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__uv_queue_read__idx143302_rank1.c", "source_rust_file": "Full__uv_queue_read__idx143302_rank1.rs", "c_api": "ERROR_IO_PENDING", "rust_api": "c::WSA_IO_PENDING", "mapping_type": "constant", "description": "Windows error code indicating I/O is pending", "reasoning": "[FFI Check] -> The C code makes a direct FFI call to WSARecv and WSAGetLastError, and the Rust code calls c::WSARecv and c::WSAGetLastError, indicating FFI usage. [Task Analysis] -> Both functions handle asynchronous socket read operations using overlapped I/O on Windows. [Similarity] -> The core logic is semantically equivalent: both perform a WSARecv call with similar parameters and handle the result, including error cases. [Knowledge Extraction] -> Full structural similarity exists in the core I/O handling pattern, with API mappings for FFI functions and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__uv_queue_read__idx143302_rank1.c", "source_rust_file": "Full__uv_queue_read__idx143302_rank1.rs", "c_api": "WSAGetLastError", "rust_api": "c::WSAGetLastError", "mapping_type": "function", "description": "Get last Windows error code", "reasoning": "[FFI Check] -> The C code makes a direct FFI call to WSARecv and WSAGetLastError, and the Rust code calls c::WSARecv and c::WSAGetLastError, indicating FFI usage. [Task Analysis] -> Both functions handle asynchronous socket read operations using overlapped I/O on Windows. [Similarity] -> The core logic is semantically equivalent: both perform a WSARecv call with similar parameters and handle the result, including error cases. [Knowledge Extraction] -> Full structural similarity exists in the core I/O handling pattern, with API mappings for FFI functions and error handling patterns."}, {"knowledge_type": "Partial", "source_c_file": "Full__uv_queue_read__idx143302_rank1.c", "source_rust_file": "Full__uv_queue_read__idx143302_rank1.rs", "c_fragment": "req = &handle->read_req;\n  assert(!(req->flags & UV_REQ_PENDING));\n  memset(&req->overlapped, 0, sizeof(req->overlapped));\n  req->type = UV_READ;\n\n  buf.base = (char*) &uv_zero_;\n  buf.len = 0;\n\n  flags = 0;\n  result = WSARecv(handle->socket,\n                   (WSABUF*)&buf,\n                   1,\n                   &bytes,\n                   &flags,\n                   &req->overlapped,\n                   NULL);", "rust_fragment": "let length = cmp::min(bufs.len(), u32::MAX as usize) as u32;\n        let mut nread = 0;\n        let mut flags = 0;\n        let result = unsafe {\n            c::WSARecv(\n                self.as_raw(),\n                bufs.as_mut_ptr() as *mut c::WSABUF,\n                length,\n                &mut nread,\n                &mut flags,\n                ptr::null_mut(),\n                None,\n            )\n        };", "description": "Both set up and call WSARecv for asynchronous socket read with similar parameters and buffer setup.", "reasoning": "[FFI Check] -> The C code makes a direct FFI call to WSARecv and WSAGetLastError, and the Rust code calls c::WSARecv and c::WSAGetLastError, indicating FFI usage. [Task Analysis] -> Both functions handle asynchronous socket read operations using overlapped I/O on Windows. [Similarity] -> The core logic is semantically equivalent: both perform a WSARecv call with similar parameters and handle the result, including error cases. [Knowledge Extraction] -> Full structural similarity exists in the core I/O handling pattern, with API mappings for FFI functions and error handling patterns."}]
Unixcoder Score: 0.008703000843524933
--------------------------------------------------
C_Code: 
static uv_buf_t buf_alloc(uv_handle_t* handle, size_t size) {
  buf_list_t* buf;

  buf = buf_freelist;
  if (buf != NULL) {
    buf_freelist = buf->next;
    return buf->uv_buf_t;
  }

  buf = (buf_list_t*) malloc(size + sizeof *buf);
  buf->uv_buf_t.len = (unsigned int)size;
  buf->uv_buf_t.base = ((char*) buf) + sizeof *buf;

  return buf->uv_buf_t;
}
Function: 
pub unsafe fn malloc_buf_base_of(suggested_size: size_t) -> *u8 {
    return rust_uv_malloc_buf_base_of(suggested_size);
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx85710_rank4.c", "source_rust_file": "API_Mapping__remove_char__idx85710_rank4.rs", "c_api": "current->pos--", "rust_api": "s[1..].to_string()", "mapping_type": "function", "description": "Position adjustment via string slicing", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 string buffer at a given position, adjusting length and position tracking. Rust code demonstrates various string slicing and substring operations, but does not perform equivalent character removal or buffer manipulation. [Similarity] No structural similarity in core logic; C manipulates a buffer and tracks positions, while Rust performs string slicing and substring operations without modifying the original string. [Knowledge Extraction] No full or partial match. However, there are API mappings related to string slicing and substring operations between C and Rust string handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx85710_rank4.c", "source_rust_file": "API_Mapping__remove_char__idx85710_rank4.rs", "c_api": "current->chars--", "rust_api": "s[1..].to_string()", "mapping_type": "function", "description": "Character count decrement via string slicing", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 string buffer at a given position, adjusting length and position tracking. Rust code demonstrates various string slicing and substring operations, but does not perform equivalent character removal or buffer manipulation. [Similarity] No structural similarity in core logic; C manipulates a buffer and tracks positions, while Rust performs string slicing and substring operations without modifying the original string. [Knowledge Extraction] No full or partial match. However, there are API mappings related to string slicing and substring operations between C and Rust string handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx85710_rank4.c", "source_rust_file": "API_Mapping__remove_char__idx85710_rank4.rs", "c_api": "current->buf + p1", "rust_api": "s[2..]", "mapping_type": "pattern", "description": "String slice access at a specific index", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 string buffer at a given position, adjusting length and position tracking. Rust code demonstrates various string slicing and substring operations, but does not perform equivalent character removal or buffer manipulation. [Similarity] No structural similarity in core logic; C manipulates a buffer and tracks positions, while Rust performs string slicing and substring operations without modifying the original string. [Knowledge Extraction] No full or partial match. However, there are API mappings related to string slicing and substring operations between C and Rust string handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx85710_rank4.c", "source_rust_file": "API_Mapping__remove_char__idx85710_rank4.rs", "c_api": "current->len -= (p2 - p1)", "rust_api": "s[..s.len() - 2].to_string()", "mapping_type": "function", "description": "String length adjustment via slicing", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 string buffer at a given position, adjusting length and position tracking. Rust code demonstrates various string slicing and substring operations, but does not perform equivalent character removal or buffer manipulation. [Similarity] No structural similarity in core logic; C manipulates a buffer and tracks positions, while Rust performs string slicing and substring operations without modifying the original string. [Knowledge Extraction] No full or partial match. However, there are API mappings related to string slicing and substring operations between C and Rust string handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx85710_rank4.c", "source_rust_file": "API_Mapping__remove_char__idx85710_rank4.rs", "c_api": "memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1)", "rust_api": "s[2..].to_string()", "mapping_type": "function", "description": "String substring extraction and copying", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 string buffer at a given position, adjusting length and position tracking. Rust code demonstrates various string slicing and substring operations, but does not perform equivalent character removal or buffer manipulation. [Similarity] No structural similarity in core logic; C manipulates a buffer and tracks positions, while Rust performs string slicing and substring operations without modifying the original string. [Knowledge Extraction] No full or partial match. However, there are API mappings related to string slicing and substring operations between C and Rust string handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx85710_rank4.c", "source_rust_file": "API_Mapping__remove_char__idx85710_rank4.rs", "c_api": "current->buf + p2", "rust_api": "s[2..]", "mapping_type": "pattern", "description": "String slice access at a specific index", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 string buffer at a given position, adjusting length and position tracking. Rust code demonstrates various string slicing and substring operations, but does not perform equivalent character removal or buffer manipulation. [Similarity] No structural similarity in core logic; C manipulates a buffer and tracks positions, while Rust performs string slicing and substring operations without modifying the original string. [Knowledge Extraction] No full or partial match. However, there are API mappings related to string slicing and substring operations between C and Rust string handling patterns."}]
Unixcoder Score: 0.003222161205485463
--------------------------------------------------
C_Code: 
void
bufslurp(struct buf *buf, size_t len)
{
	assert(buf && buf->unit);

	if (len >= buf->size) {
		buf->size = 0;
		return;
	}

	buf->size -= len;
	memmove(buf->data, buf->data + len, buf->size);
}
Function: 
pub fn resize(&mut self, new_len: usize, value: T) {
        if new_len > self.len() {
            let extra = new_len - self.len();
            self.extend(repeat_n(value, extra))
        } else {
            self.truncate(new_len);
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx78488_rank5.c", "source_rust_file": "API_Mapping__remove_char__idx78488_rank5.rs", "c_api": "for iter(h) {|e|", "rust_api": "for iter(h) {|e|", "mapping_type": "pattern", "description": "Loop iteration over a collection", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 buffer at a given position, handling terminal output optimization and string manipulation. Rust function finds the index of an element in a slice. [Similarity] No structural similarity at the function level due to different domains (string manipulation vs search). [Knowledge Extraction] No full match, no partial match, but there is a pattern in loop usage and array/slice iteration that can be mapped. The Rust code uses a loop to iterate over a slice, similar to how C might iterate over a buffer. The C code uses memmove for string manipulation, which has no direct Rust equivalent in this context. However, the loop pattern and data access pattern can be mapped. [API Mappings] Loop iteration pattern, slice access pattern."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx78488_rank5.c", "source_rust_file": "API_Mapping__remove_char__idx78488_rank5.rs", "c_api": "memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1)", "rust_api": "slice access and manipulation", "mapping_type": "pattern", "description": "Memory movement in buffer/slice", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 buffer at a given position, handling terminal output optimization and string manipulation. Rust function finds the index of an element in a slice. [Similarity] No structural similarity at the function level due to different domains (string manipulation vs search). [Knowledge Extraction] No full match, no partial match, but there is a pattern in loop usage and array/slice iteration that can be mapped. The Rust code uses a loop to iterate over a slice, similar to how C might iterate over a buffer. The C code uses memmove for string manipulation, which has no direct Rust equivalent in this context. However, the loop pattern and data access pattern can be mapped. [API Mappings] Loop iteration pattern, slice access pattern."}]
Unixcoder Score: -0.005428285337984562
--------------------------------------------------
C_Code: 
void
bufslurp(struct buf *buf, size_t len)
{
	assert(buf && buf->unit);

	if (len >= buf->size) {
		buf->size = 0;
		return;
	}

	buf->size -= len;
	memmove(buf->data, buf->data + len, buf->size);
}
Function: 
pub fn from_box(boxed: Box<Slice>) -> Buf {
        let inner: Box<[u8]> = unsafe { mem::transmute(boxed) };
        Buf { inner: inner.into_vec() }
    }
Unixcoder Score: -0.007402495481073856
--------------------------------------------------
C_Code: 
void
bufslurp(struct buf *buf, size_t len)
{
	assert(buf && buf->unit);

	if (len >= buf->size) {
		buf->size = 0;
		return;
	}

	buf->size -= len;
	memmove(buf->data, buf->data + len, buf->size);
}
Function: 
fn test_swap() {
    let mut tester = VecDeque::new();
    tester.push_back(1);
    tester.push_back(2);
    tester.push_back(3);

    assert_eq!(tester, [1, 2, 3]);

    tester.swap(0, 0);
    assert_eq!(tester, [1, 2, 3]);
    tester.swap(0, 1);
    assert_eq!(tester, [2, 1, 3]);
    tester.swap(2, 1);
    assert_eq!(tester, [2, 3, 1]);
    tester.swap(1, 2);
    assert_eq!(tester, [2, 1, 3]);
    tester.swap(0, 2);
    assert_eq!(tester, [3, 1, 2]);
    tester.swap(2, 2);
    assert_eq!(tester, [3, 1, 2]);
}
Unixcoder Score: -0.010085470043122768
--------------------------------------------------
C_Code: 
static uint64_t
read_uleb128 (struct dwarf_buf *buf)
{
  uint64_t ret;
  unsigned int shift;
  int overflow;
  unsigned char b;

  ret = 0;
  shift = 0;
  overflow = 0;
  do
    {
      const unsigned char *p;

      p = buf->buf;
      if (!advance (buf, 1))
	return 0;
      b = *p;
      if (shift < 64)
	ret |= ((uint64_t) (b & 0x7f)) << shift;
      else if (!overflow)
	{
	  dwarf_buf_error (buf, "LEB128 overflows uint64_t");
	  overflow = 1;
	}
      shift += 7;
    }
  while ((b & 0x80) != 0);

  return ret;
}
Function: 
pub unsafe fn read_sleb128(&mut self) -> i64 {
        let mut shift: u32 = 0;
        let mut result: u64 = 0;
        let mut byte: u8;
        loop {
            byte = self.read::<u8>();
            result |= ((byte & 0x7F) as u64) << shift;
            shift += 7;
            if byte & 0x80 == 0 {
                break;
            }
        }
        // sign-extend
        if shift < u64::BITS && (byte & 0x40) != 0 {
            result |= (!0 as u64) << shift;
        }
        result as i64
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__uv_queue_read__idx127173_rank1.c", "source_rust_file": "API_Mapping__uv_queue_read__idx127173_rank1.rs", "c_api": "buf.len = 0;", "rust_api": "buf.len() as c::ULONG", "mapping_type": "pattern", "description": "Buffer length assignment for Windows socket operations", "reasoning": "[Task Analysis] C function handles async TCP read via Windows API (WSARecv), Rust function creates a Winsock IoSlice for buffer management. [Similarity] No structural similarity at the function level; C has complex I/O logic with error handling and state updates, while Rust just constructs a data structure. [Knowledge Extraction] No full match, no partial match, but there's a pattern in how buffers are handled: C uses WSARecv with a buffer struct, Rust creates an IoSlice from a byte slice. This represents a mapping between buffer setup patterns in Windows networking APIs."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__uv_queue_read__idx127173_rank1.c", "source_rust_file": "API_Mapping__uv_queue_read__idx127173_rank1.rs", "c_api": "buf.base = (char*) &uv_zero_;", "rust_api": "buf.as_ptr() as *mut u8", "mapping_type": "pattern", "description": "Buffer pointer setup for Windows socket operations", "reasoning": "[Task Analysis] C function handles async TCP read via Windows API (WSARecv), Rust function creates a Winsock IoSlice for buffer management. [Similarity] No structural similarity at the function level; C has complex I/O logic with error handling and state updates, while Rust just constructs a data structure. [Knowledge Extraction] No full match, no partial match, but there's a pattern in how buffers are handled: C uses WSARecv with a buffer struct, Rust creates an IoSlice from a byte slice. This represents a mapping between buffer setup patterns in Windows networking APIs."}]
Unixcoder Score: -0.0108343455940485
--------------------------------------------------
C_Code: 
static void jsondec_resize(jsondec* d, char** buf, char** end, char** buf_end) {
  size_t oldsize = *buf_end - *buf;
  size_t len = *end - *buf;
  size_t size = UPB_MAX(8, 2 * oldsize);

  *buf = upb_Arena_Realloc(d->arena, *buf, len, size);
  if (!*buf) jsondec_err(d, "Out of memory");

  *end = *buf + len;
  *buf_end = *buf + size;
}
Function: 
pub unsafe fn alloc(&self, layout: Layout) -> &mut [MaybeUninit<u8>] {
        debug_assert!(layout.align() <= UPB_MALLOC_ALIGN);
        // SAFETY: `self.raw` is a valid UPB arena
        let ptr = unsafe { upb_Arena_Malloc(self.raw, layout.size()) };
        if ptr.is_null() {
            alloc::handle_alloc_error(layout);
        }

        // SAFETY:
        // - `upb_Arena_Malloc` promises that if the return pointer is non-null, it is
        //   dereferencable for `size` bytes and has an alignment of `UPB_MALLOC_ALIGN`
        //   until the arena is destroyed.
        // - `[MaybeUninit<u8>]` has no alignment requirement, and `ptr` is aligned to a
        //   `UPB_MALLOC_ALIGN` boundary.
        unsafe { slice::from_raw_parts_mut(ptr.cast(), layout.size()) }
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__remove_char__idx112982_rank5.c", "source_rust_file": "Partial__remove_char__idx112982_rank5.rs", "c_fragment": "memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1);\ncurrent->len -= (p2 - p1);\ncurrent->chars--;", "rust_fragment": "self_vec.drain(self.start..self.end);", "description": "Both perform removal of elements from a data structure (buffer or vector) by shifting or draining elements.", "reasoning": "[Filter 1] Names do not refer to the same concept ('remove_char' vs 'drop') but API mappings may still exist. [Filter 2] Neither code is empty/trivial. [Filter 3] No FFI call detected. [Filter 4] Domain mismatch: C manipulates UTF-8 string buffers with position tracking, while Rust operates on a vector slice with drain. [Filter 5] Both are function definitions, not structs. [Filter 6] This is a definition vs definition match, so valid for classification. [Task Analysis] C function removes a character from a buffer at a given position, adjusting lengths and positions accordingly. Rust function drops a range of elements from a vector. [Similarity] While the high-level operations differ (string manipulation vs vector manipulation), both involve removing elements from a data structure based on position. [Knowledge Extraction] Extract partial structural match and API mappings based on similar removal logic and data structure operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__remove_char__idx112982_rank5.c", "source_rust_file": "Partial__remove_char__idx112982_rank5.rs", "c_api": "current->len -= (p2 - p1)", "rust_api": "self_vec.drain(self.start..self.end)", "mapping_type": "function", "description": "Length adjustment in C corresponds to element removal in Rust", "reasoning": "[Filter 1] Names do not refer to the same concept ('remove_char' vs 'drop') but API mappings may still exist. [Filter 2] Neither code is empty/trivial. [Filter 3] No FFI call detected. [Filter 4] Domain mismatch: C manipulates UTF-8 string buffers with position tracking, while Rust operates on a vector slice with drain. [Filter 5] Both are function definitions, not structs. [Filter 6] This is a definition vs definition match, so valid for classification. [Task Analysis] C function removes a character from a buffer at a given position, adjusting lengths and positions accordingly. Rust function drops a range of elements from a vector. [Similarity] While the high-level operations differ (string manipulation vs vector manipulation), both involve removing elements from a data structure based on position. [Knowledge Extraction] Extract partial structural match and API mappings based on similar removal logic and data structure operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__remove_char__idx112982_rank5.c", "source_rust_file": "Partial__remove_char__idx112982_rank5.rs", "c_api": "current->chars--", "rust_api": "self_vec.drain(self.start..self.end)", "mapping_type": "function", "description": "Character count decrement in C corresponds to element removal in Rust", "reasoning": "[Filter 1] Names do not refer to the same concept ('remove_char' vs 'drop') but API mappings may still exist. [Filter 2] Neither code is empty/trivial. [Filter 3] No FFI call detected. [Filter 4] Domain mismatch: C manipulates UTF-8 string buffers with position tracking, while Rust operates on a vector slice with drain. [Filter 5] Both are function definitions, not structs. [Filter 6] This is a definition vs definition match, so valid for classification. [Task Analysis] C function removes a character from a buffer at a given position, adjusting lengths and positions accordingly. Rust function drops a range of elements from a vector. [Similarity] While the high-level operations differ (string manipulation vs vector manipulation), both involve removing elements from a data structure based on position. [Knowledge Extraction] Extract partial structural match and API mappings based on similar removal logic and data structure operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__remove_char__idx112982_rank5.c", "source_rust_file": "Partial__remove_char__idx112982_rank5.rs", "c_api": "memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1)", "rust_api": "self_vec.drain(self.start..self.end)", "mapping_type": "function", "description": "Memory shifting operation in C corresponds to vector draining in Rust", "reasoning": "[Filter 1] Names do not refer to the same concept ('remove_char' vs 'drop') but API mappings may still exist. [Filter 2] Neither code is empty/trivial. [Filter 3] No FFI call detected. [Filter 4] Domain mismatch: C manipulates UTF-8 string buffers with position tracking, while Rust operates on a vector slice with drain. [Filter 5] Both are function definitions, not structs. [Filter 6] This is a definition vs definition match, so valid for classification. [Task Analysis] C function removes a character from a buffer at a given position, adjusting lengths and positions accordingly. Rust function drops a range of elements from a vector. [Similarity] While the high-level operations differ (string manipulation vs vector manipulation), both involve removing elements from a data structure based on position. [Knowledge Extraction] Extract partial structural match and API mappings based on similar removal logic and data structure operations."}]
Unixcoder Score: -0.01564069464802742
--------------------------------------------------
C_Code: 
static void jsondec_resize(jsondec* d, char** buf, char** end, char** buf_end) {
  size_t oldsize = *buf_end - *buf;
  size_t len = *end - *buf;
  size_t size = UPB_MAX(8, 2 * oldsize);

  *buf = upb_Arena_Realloc(d->arena, *buf, len, size);
  if (!*buf) jsondec_err(d, "Out of memory");

  *end = *buf + len;
  *buf_end = *buf + size;
}
Function: 
pub unsafe fn resize(&self, ptr: *mut u8, old: Layout, new: Layout) -> &mut [MaybeUninit<u8>] {
        debug_assert!(new.align() <= UPB_MALLOC_ALIGN);
        // SAFETY:
        // - `self.raw` is a valid UPB arena
        // - `ptr` was allocated by a previous call to `alloc` or `realloc` as promised
        //   by the caller.
        let ptr = unsafe { upb_Arena_Realloc(self.raw, ptr, old.size(), new.size()) };
        if ptr.is_null() {
            alloc::handle_alloc_error(new);
        }

        // SAFETY:
        // - `upb_Arena_Realloc` promises that if the return pointer is non-null, it is
        //   dereferencable for the new `size` in bytes until the arena is destroyed.
        // - `[MaybeUninit<u8>]` has no alignment requirement, and `ptr` is aligned to a
        //   `UPB_MALLOC_ALIGN` boundary.
        unsafe { slice::from_raw_parts_mut(ptr.cast(), new.size()) }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx112894_rank5.c", "source_rust_file": "API_Mapping__remove_char__idx112894_rank5.rs", "c_api": "current->chars--", "rust_api": "chars_iter", "mapping_type": "field_access", "description": "Character count decrement", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 buffer at a given position, handling terminal optimizations and updating string metadata. Rust function provides a method to drain a range of characters from a String, returning a Drain iterator. [Similarity] No full structural similarity due to different domains (low-level buffer manipulation vs high-level string draining). [Knowledge Extraction] No full match, but both involve character-level string manipulation and metadata updates. Extract API mappings for character removal and string metadata handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx112894_rank5.c", "source_rust_file": "API_Mapping__remove_char__idx112894_rank5.rs", "c_api": "current->len -= (p2 - p1)", "rust_api": "start, end", "mapping_type": "field_access", "description": "String length adjustment", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 buffer at a given position, handling terminal optimizations and updating string metadata. Rust function provides a method to drain a range of characters from a String, returning a Drain iterator. [Similarity] No full structural similarity due to different domains (low-level buffer manipulation vs high-level string draining). [Knowledge Extraction] No full match, but both involve character-level string manipulation and metadata updates. Extract API mappings for character removal and string metadata handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__remove_char__idx112894_rank5.c", "source_rust_file": "API_Mapping__remove_char__idx112894_rank5.rs", "c_api": "memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1)", "rust_api": "self.get_unchecked(start..end).chars()", "mapping_type": "pattern", "description": "Character data movement and iteration", "reasoning": "[Task Analysis] C function removes a character from a UTF-8 buffer at a given position, handling terminal optimizations and updating string metadata. Rust function provides a method to drain a range of characters from a String, returning a Drain iterator. [Similarity] No full structural similarity due to different domains (low-level buffer manipulation vs high-level string draining). [Knowledge Extraction] No full match, but both involve character-level string manipulation and metadata updates. Extract API mappings for character removal and string metadata handling."}]
Unixcoder Score: -0.01802370697259903
--------------------------------------------------
