C_Code: 
int32_t InvokerListenThreadStub(uint32_t code, IpcIo *data, IpcIo *reply, MessageOption option, OnRemoteRequest func)
{
    (void)code;
    (void)data;
    (void)reply;
    (void)option;
    (void)func;
    return ERR_NONE;
}
Function: 
fn on_remote_request(&self, code: u32, data: &mut MsgParcel, reply: &mut MsgParcel) -> i32 {
        R::on_remote_request(self, code, data, reply)
    }
Unixcoder Score: 0.21266740560531616
--------------------------------------------------
C_Code: 
int32_t InvokerListenThreadStub(uint32_t code, IpcIo *data, IpcIo *reply, MessageOption option, OnRemoteRequest func)
{
    (void)code;
    (void)data;
    (void)reply;
    (void)option;
    (void)func;
    return ERR_NONE;
}
Function: 
pub fn on_remote_request(
        &mut self,
        code: u32,
        data: Pin<&mut MessageParcel>,
        reply: Pin<&mut MessageParcel>,
    ) -> i32 {
        unsafe {
            let mut data = MsgParcel::from_ptr(data.get_unchecked_mut() as *mut MessageParcel);
            let mut reply = MsgParcel::from_ptr(reply.get_unchecked_mut() as *mut MessageParcel);
            self.inner.on_remote_request(code, &mut data, &mut reply)
        }
    }
Unixcoder Score: 0.2031177282333374
--------------------------------------------------
C_Code: 
int32_t InvokerListenThreadStub(uint32_t code, IpcIo *data, IpcIo *reply, MessageOption option, OnRemoteRequest func)
{
    (void)code;
    (void)data;
    (void)reply;
    (void)option;
    (void)func;
    return ERR_NONE;
}
Function: 
fn on_remote_request(&self, code: u32, data: &mut MsgParcel, reply: &mut MsgParcel) -> i32 {
            0
        }
Unixcoder Score: 0.20299077033996582
--------------------------------------------------
C_Code: 
void native_func() {}
Function: 
pub extern "C" fn wrapped_func() {
    unsafe {
        native_func();
    }
}
Unixcoder Score: 0.04749756306409836
--------------------------------------------------
C_Code: 
void native_func() {}
Function: 
pub extern "C" fn wrapped_func() {
    unsafe {
        native_func();
    }
}
Unixcoder Score: 0.04192173853516579
--------------------------------------------------
C_Code: 
void simplest_func_thunk (int revents, void *arg)
    {
      (*cb)
        ();
    }
Function: 
fn foo(name: String, samples_chan: Sender<Msg>) {
    thread::spawn(move|| {
        let mut samples_chan = samples_chan;

        let callback: SamplesFn = Box::new(move |buffer| {
            for i in 0..buffer.len() {
                println!("{}: {}", i, buffer[i])
            }
        });

        samples_chan.send(Msg::GetSamples(name.clone(), callback));
    }).join();
}
Unixcoder Score: 0.04152638837695122
--------------------------------------------------
C_Code: 
TEST(RepeatedFieldReflectionTest, RegularFields) {
  TestAllTypes message;
  const Reflection* refl = message.GetReflection();
  const Descriptor* desc = message.GetDescriptor();

  for (int i = 0; i < 10; ++i) {
    message.add_repeated_int32(Func(i, 1));
    message.add_repeated_double(Func(i, 2));
    message.add_repeated_string(StrFunc(i, 5));
    message.add_repeated_foreign_message()->set_c(Func(i, 6));
  }

  // Get FieldDescriptors for all the fields of interest.
  const FieldDescriptor* fd_repeated_int32 =
      desc->FindFieldByName("repeated_int32");
  const FieldDescriptor* fd_repeated_double =
      desc->FindFieldByName("repeated_double");
  const FieldDescriptor* fd_repeated_string =
      desc->FindFieldByName("repeated_string");
  const FieldDescriptor* fd_repeated_foreign_message =
      desc->FindFieldByName("repeated_foreign_message");

  // Get RepeatedField objects for all fields of interest.
  const RepeatedField<int32>& rf_int32 =
      refl->GetRepeatedField<int32>(message, fd_repeated_int32);
  const RepeatedField<double>& rf_double =
      refl->GetRepeatedField<double>(message, fd_repeated_double);

  // Get mutable RepeatedField objects for all fields of interest.
  RepeatedField<int32>* mrf_int32 =
      refl->MutableRepeatedField<int32>(&message, fd_repeated_int32);
  RepeatedField<double>* mrf_double =
      refl->MutableRepeatedField<double>(&message, fd_repeated_double);

  // Get RepeatedPtrField objects for all fields of interest.
  const RepeatedPtrField<std::string>& rpf_string =
      refl->GetRepeatedPtrField<std::string>(message, fd_repeated_string);
  const RepeatedPtrField<ForeignMessage>& rpf_foreign_message =
      refl->GetRepeatedPtrField<ForeignMessage>(message,
                                                fd_repeated_foreign_message);
  const RepeatedPtrField<Message>& rpf_message =
      refl->GetRepeatedPtrField<Message>(message, fd_repeated_foreign_message);

  // Get mutable RepeatedPtrField objects for all fields of interest.
  RepeatedPtrField<std::string>* mrpf_string =
      refl->MutableRepeatedPtrField<std::string>(&message, fd_repeated_string);
  RepeatedPtrField<ForeignMessage>* mrpf_foreign_message =
      refl->MutableRepeatedPtrField<ForeignMessage>(
          &message, fd_repeated_foreign_message);
  RepeatedPtrField<Message>* mrpf_message =
      refl->MutableRepeatedPtrField<Message>(&message,
                                             fd_repeated_foreign_message);

  // Make sure we can do gets and sets through the Repeated[Ptr]Field objects.
  for (int i = 0; i < 10; ++i) {
    // Check gets through const objects.
    EXPECT_EQ(rf_int32.Get(i), Func(i, 1));
    EXPECT_EQ(rf_double.Get(i), Func(i, 2));
    EXPECT_EQ(rpf_string.Get(i), StrFunc(i, 5));
    EXPECT_EQ(rpf_foreign_message.Get(i).c(), Func(i, 6));
    EXPECT_EQ(down_cast<const ForeignMessage*>(&rpf_message.Get(i))->c(),
              Func(i, 6));

    // Check gets through mutable objects.
    EXPECT_EQ(mrf_int32->Get(i), Func(i, 1));
    EXPECT_EQ(mrf_double->Get(i), Func(i, 2));
    EXPECT_EQ(mrpf_string->Get(i), StrFunc(i, 5));
    EXPECT_EQ(mrpf_foreign_message->Get(i).c(), Func(i, 6));
    EXPECT_EQ(down_cast<const ForeignMessage*>(&mrpf_message->Get(i))->c(),
              Func(i, 6));

    // Check sets through mutable objects.
    mrf_int32->Set(i, Func(i, -1));
    mrf_double->Set(i, Func(i, -2));
    mrpf_string->Mutable(i)->assign(StrFunc(i, -5));
    mrpf_foreign_message->Mutable(i)->set_c(Func(i, -6));
    EXPECT_EQ(message.repeated_int32(i), Func(i, -1));
    EXPECT_EQ(message.repeated_double(i), Func(i, -2));
    EXPECT_EQ(message.repeated_string(i), StrFunc(i, -5));
    EXPECT_EQ(message.repeated_foreign_message(i).c(), Func(i, -6));
    down_cast<ForeignMessage*>(mrpf_message->Mutable(i))->set_c(Func(i, 7));
    EXPECT_EQ(message.repeated_foreign_message(i).c(), Func(i, 7));
  }

#ifdef PROTOBUF_HAS_DEATH_TEST
  // Make sure types are checked correctly at runtime.
  const FieldDescriptor* fd_optional_int32 =
      desc->FindFieldByName("optional_int32");
  EXPECT_DEATH(refl->GetRepeatedField<int32>(message, fd_optional_int32),
               "requires a repeated field");
  EXPECT_DEATH(refl->GetRepeatedField<double>(message, fd_repeated_int32),
               "not the right type");
  EXPECT_DEATH(refl->GetRepeatedPtrField<TestAllTypes>(
                   message, fd_repeated_foreign_message),
               "wrong submessage type");
#endif  // PROTOBUF_HAS_DEATH_TEST
}
Function: 
fn test_primitive_repeated() {
        macro_rules! primitive_repeated_tests {
            ($($t:ty => [$($vals:expr),* $(,)?]),* $(,)?) => {
                $({
                // Constructs a new, owned, `Repeated`, only used for tests.
                let mut r = Repeated::<$t>::new();
                let mut r = r.as_mut();
                assert_that!(r.len(), eq(0));
                assert!(r.iter().next().is_none(), "starts with empty iter");
                assert!(r.iter().next().is_none(), "starts with empty mut iter");
                assert!(r.is_empty(), "starts is_empty");

                let mut expected_len = 0usize;
                $(
                    let val: View<$t> = $vals;
                    r.push(val);
                    assert_that!(r.get(expected_len), eq(Some(val)));
                    expected_len += 1;
                    assert_that!(r.len(), eq(expected_len));

                )*
                assert_that!(r, elements_are![$(eq($vals)),*]);
                r.set(0, <$t as Default>::default());
                assert_that!(r.get(0).expect("elem 0"), eq(<$t as Default>::default()));

                r.clear();
                assert!(r.is_empty(), "is_empty after clear");
                assert!(r.iter().next().is_none(), "iter empty after clear");
                assert!(r.into_iter().next().is_none(), "mut iter empty after clear");
                })*
            }
        }
        primitive_repeated_tests!(
            u32 => [1,2,3],
            i32 => [1,2],
            f64 => [10.0, 0.1234f64],
            bool => [false, true, true, false],
        );
    }
Unixcoder Score: 0.036133408546447754
--------------------------------------------------
C_Code: 
void InnerWriter::AppendParam(EventBase& eventBase, const HiSysEventParam& param)
{
    using AppendParamFunc = void (*)(EventBase&, const HiSysEventParam&);
    constexpr int totalAppendFuncSize = 25;
    const AppendParamFunc appendFuncs[totalAppendFuncSize] = {
        &AppendInvalidParam, &AppendBoolParam, &AppendInt8Param, &AppendUint8Param,
        &AppendInt16Param, &AppendUint16Param, &AppendInt32Param, &AppendUint32Param,
        &AppendInt64Param, &AppendUint64Param, &AppendFloatParam, &AppendDoubleParam,
        &AppendStringParam, &AppendBoolArrayParam, &AppendInt8ArrayParam, &AppendUint8ArrayParam,
        &AppendInt16ArrayParam, &AppendUint16ArrayParam, &AppendInt32ArrayParam, &AppendUint32ArrayParam,
        &AppendInt64ArrayParam, &AppendUint64ArrayParam, &AppendFloatArrayParam, &AppendDoubleArrayParam,
        &AppendStringArrayParam,
    };
    if (size_t paramType = param.t; paramType < totalAppendFuncSize) {
        appendFuncs[paramType](eventBase, param);
    } else {
        eventBase.SetRetCode(ERR_VALUE_INVALID);
    }
}
Function: 
pub fn write<const N: usize>(event_domain: &str, event_name: &str, event_type: EventType,
    event_params: &[HiSysEventParam; N]) -> i32 {
    sys_event::write(event_domain, event_name, event_type as std::ffi::c_int, event_params)
}
Unixcoder Score: 0.03435518592596054
--------------------------------------------------
C_Code: 
void native_func() {}
Function: 
pub extern "C" fn wrapped_func() {
    unsafe {
        native_func();
    }
}
Unixcoder Score: 0.033719733357429504
--------------------------------------------------
C_Code: 
void FuncB()
{
    cout << "funcB" << endl;
    usleep(USLEEP_HALF_SECOND);
}
Function: 
fn func_b() {
    println!("funcB!!!");
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__Watcher__idx5521_rank5.c", "source_rust_file": "API_Mapping__Watcher__idx5521_rank5.rs", "c_api": "std::function<bool(std::shared_ptr<HiSysEventRecord>)>", "rust_api": "hisysevent::write(...)", "mapping_type": "function", "description": "Callback function for validation/assertion in event logging", "reasoning": "[Task Analysis] C code defines a constructor for a Watcher class that takes a std::function and assigns it to a member variable. Rust code is a test function that calls a hisysevent::write function with various parameters and asserts the result. [Similarity] The task is not about structural similarity since one is a constructor and the other is a test function with a call. [Knowledge Extraction] No full or partial structural match. However, there is an API mapping between the C std::function and the Rust function call pattern, both representing a way to pass a callback/assertion function. Also, the Rust test function uses a macro-based parameter building pattern that could be mapped to C-style parameter construction, but the core logic is different. [API Mappings] The C std::function<bool(std::shared_ptr<HiSysEventRecord>)> and Rust function call pattern both represent a way to pass a callback function for assertion/validation. [None of the filters block this, but no full/partial match due to domain mismatch and different roles.]"}]
Unixcoder Score: 0.033582113683223724
--------------------------------------------------
