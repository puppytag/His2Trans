C_Code: 
napi_value NAPI_IPCSkeleton_setCallingIdentity(napi_env env, napi_callback_info info)
{
    napi_value global = nullptr;
    napi_get_global(env, &global);
    napi_value napiActiveStatus = nullptr;
    napi_get_named_property(env, global, "activeStatus_", &napiActiveStatus);
    int32_t activeStatus = IRemoteInvoker::IDLE_INVOKER;
    napi_get_value_int32(env, napiActiveStatus, &activeStatus);
    if (activeStatus != IRemoteInvoker::ACTIVE_INVOKER) {
        napi_value result = nullptr;
        napi_get_boolean(env, true, &result);
        return result;
    }

    napi_value retValue = nullptr;
    napi_get_boolean(env, false, &retValue);

    size_t argc = 1;
    size_t expectedArgc = 1;
    napi_value argv[ARGV_LENGTH_1] = { 0 };
    napi_value thisVar = nullptr;
    napi_get_cb_info(env, info, &argc, argv, &thisVar, nullptr);
    NAPI_ASSERT_BASE(env, argc == expectedArgc, "requires 1 parameters", retValue);
    napi_valuetype valueType = napi_null;
    napi_typeof(env, argv[ARGV_INDEX_0], &valueType);
    NAPI_ASSERT_BASE(env, valueType == napi_string, "type mismatch for parameter 1", retValue);
    size_t bufferSize = 0;
    size_t maxLen = 40960;
    napi_get_value_string_utf8(env, argv[ARGV_INDEX_0], nullptr, 0, &bufferSize);
    NAPI_ASSERT_BASE(env, bufferSize < maxLen, "string length too large", retValue);
    char stringValue[bufferSize + 1];
    size_t jsStringLength = 0;
    napi_get_value_string_utf8(env, argv[ARGV_INDEX_0], stringValue, bufferSize + 1, &jsStringLength);
    NAPI_ASSERT_BASE(env, jsStringLength == bufferSize, "string length wrong", retValue);

    std::string identity = stringValue;
    napi_value napiIsLocalCalling = nullptr;
    napi_get_named_property(env, global, "isLocalCalling_", &napiIsLocalCalling);
    bool isLocalCalling = true;
    napi_get_value_bool(env, napiIsLocalCalling, &isLocalCalling);
    napi_value result;
    if (isLocalCalling) {
        uint64_t token = 0;
        auto ret = std::from_chars(identity.c_str(), identity.c_str() + identity.size(), token);
        if (ret.ec != std::errc()) {
            ZLOGE(LOG_LABEL, "identity is invalid");
            napi_get_boolean(env, false, &result);
            return result;
        }
        int32_t callerUid = static_cast<int32_t>(token >> PID_LEN);
        int32_t callerPid = static_cast<int32_t>(token);
        napi_value napiCallingPid;
        napi_create_int32(env, callerPid, &napiCallingPid);
        napi_set_named_property(env, global, "callingPid_", napiCallingPid);
        napi_value napiCallingUid;
        napi_create_int32(env, callerUid, &napiCallingUid);
        napi_set_named_property(env, global, "callingUid_", napiCallingUid);
        napi_get_boolean(env, true, &result);
        return result;
    } else {
        if (identity.empty() || identity.length() <= DEVICEID_LENGTH) {
            napi_get_boolean(env, false, &result);
            return result;
        }

        std::string deviceId = identity.substr(0, DEVICEID_LENGTH);
        const std::string readIdentity = identity.substr(DEVICEID_LENGTH, identity.length() - DEVICEID_LENGTH);
        uint64_t token = 0;
        auto ret = std::from_chars(readIdentity.c_str(), readIdentity.c_str() + readIdentity.size(), token);
        if (ret.ec != std::errc()) {
            ZLOGE(LOG_LABEL, "identity is invalid");
            napi_get_boolean(env, false, &result);
            return result;
        }
        int32_t callerUid = static_cast<int32_t>(token >> PID_LEN);
        int32_t callerPid = static_cast<int32_t>(token);
        napi_value napiCallingPid;
        napi_create_int32(env, callerPid, &napiCallingPid);
        napi_set_named_property(env, global, "callingPid_", napiCallingPid);
        napi_value napiCallingUid;
        napi_create_int32(env, callerUid, &napiCallingUid);
        napi_set_named_property(env, global, "callingUid_", napiCallingUid);
        napi_value napiCallingDeviceID = nullptr;
        napi_create_string_utf8(env, deviceId.c_str(), NAPI_AUTO_LENGTH, &napiCallingDeviceID);
        napi_set_named_property(env, global, "callingDeviceID_", napiCallingDeviceID);
        napi_get_boolean(env, true, &result);
        return result;
    }
}
Function: 
pub fn set_calling_identity(identity: &str) -> bool {
        SetCallingIdentity(identity)
    }
Unixcoder Score: 0.019065305590629578
--------------------------------------------------
C_Code: 
struct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[]) {
	struct qrcodegen_Segment result;
	result.mode = qrcodegen_Mode_BYTE;
	result.bitLength = calcSegmentBitLength(result.mode, len);
	result.numChars = (int)len;
	if (len > 0)
		memcpy(buf, data, len * sizeof(buf[0]));
	result.data = buf;
	return result;
}
Function: 
pub fn make_bytes(data: &[u8]) -> Self {
		let mut bb = BitBuffer(Vec::with_capacity(data.len() * 8));
		for &b in data {
			bb.append_bits(u32::from(b), 8);
		}
		QrSegment::new(QrSegmentMode::Byte, data.len(), bb.0)
	}
Unixcoder Score: 0.015236645936965942
--------------------------------------------------
C_Code: 
int32_t GetUsersSize(uint32_t *userIdsSize)
{
    std::vector<OHOS::AccountSA::OsAccountInfo> accountInfos = {};
    int32_t ret = OHOS::AccountSA::OsAccountManager::QueryAllCreatedOsAccounts(accountInfos);
    if (ret != OHOS::ERR_OK) {
        LOGE("[FATAL]Query all account id failed! res is %{public}d", ret);
        return ASSET_ACCOUNT_ERROR;
    }
    if (accountInfos.empty()) {
        LOGE("[FATAL]accountInfos is empty");
        return ASSET_ACCOUNT_ERROR;
    }
    std::vector<int32_t> userIdsVec = { 0 };
    std::transform(accountInfos.begin(), accountInfos.end(), std::back_inserter(userIdsVec),
        [](auto &iter) { return iter.GetLocalId(); });
    *userIdsSize = static_cast<uint32_t>(userIdsVec.size());

    return ASSET_SUCCESS;
}
Function: 
pub fn get_user_id(uid: u64) -> Result<u32> {
    unsafe {
        let mut user_id = 0;
        if GetUserIdByUid(uid, &mut user_id) {
            Ok(user_id)
        } else {
            log_throw_error!(ErrCode::AccountError, "[FATAL]Get user id failed.")
        }
    }
}
Unixcoder Score: 0.01172447856515646
--------------------------------------------------
C_Code: 
int32_t ResponseMessageReceiver::MsgHeaderParcel(
    int32_t &msgId, int16_t &msgType, int16_t &bodySize, char *&parcel, int32_t &size)
{
    int32_t magicNum = 0;
    if (Int32FromParcel(magicNum, parcel, size) != 0) {
        return -1;
    }
    if (magicNum != ResponseMessageReceiver::RESPONSE_MAGIC_NUM) {
        REQUEST_HILOGE("Bad magic num, %{public}d", magicNum);
        return -1;
    }

    if (Int32FromParcel(msgId, parcel, size) != 0) {
        return -1;
    }
    if (Int16FromParcel(msgType, parcel, size) != 0) {
        return -1;
    }
    if (Int16FromParcel(bodySize, parcel, size) != 0) {
        return -1;
    }
    return 0;
}
Function: 
async fn handle_send_response(
        &mut self,
        tid: u32,
        version: String,
        status_code: u32,
        reason: String,
        headers: Headers,
    ) {
        let mut response = Vec::<u8>::new();

        response.extend_from_slice(&REQUEST_MAGIC_NUM.to_le_bytes());

        response.extend_from_slice(&self.message_id.to_le_bytes());
        self.message_id += 1;

        let message_type = MessageType::HttpResponse as u16;
        response.extend_from_slice(&message_type.to_le_bytes());

        let message_body_size: u16 = 0;
        response.extend_from_slice(&message_body_size.to_le_bytes());

        response.extend_from_slice(&tid.to_le_bytes());

        response.extend_from_slice(&version.into_bytes());
        response.push(b'\0');

        response.extend_from_slice(&status_code.to_le_bytes());

        response.extend_from_slice(&reason.into_bytes());
        response.push(b'\0');

        // The maximum length of the headers in uds should not exceed 8192
        let mut buf_size = 0;
        for (k, v) in headers {
            buf_size += k.as_bytes().len() + v.iter().map(|f| f.len()).sum::<usize>();
            if buf_size > HEADERS_MAX_SIZE as usize {
                break;
            }

            response.extend_from_slice(k.as_bytes());
            response.push(b':');
            for (i, sub_value) in v.iter().enumerate() {
                if i != 0 {
                    response.push(b',');
                }
                response.extend_from_slice(sub_value);
            }
            response.push(b'\n');
        }

        let mut size = response.len() as u16;
        if size > HEADERS_MAX_SIZE {
            info!("send response too long");
            response.truncate(HEADERS_MAX_SIZE as usize);
            size = HEADERS_MAX_SIZE;
        }
        debug!("send response size, {:?}", size);
        let size = size.to_le_bytes();
        response[POSITION_OF_LENGTH as usize] = size[0];
        response[(POSITION_OF_LENGTH + 1) as usize] = size[1];

        self.send_message(response).await;
    }
Unixcoder Score: 0.010399436578154564
--------------------------------------------------
C_Code: 
struct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[]) {
	struct qrcodegen_Segment result;
	result.mode = qrcodegen_Mode_BYTE;
	result.bitLength = calcSegmentBitLength(result.mode, len);
	result.numChars = (int)len;
	if (len > 0)
		memcpy(buf, data, len * sizeof(buf[0]));
	result.data = buf;
	return result;
}
Function: 
pub fn make_bytes(data: &[u8]) -> Self {
		let mut bb = BitBuffer(Vec::with_capacity(data.len() * 8));
		for &b in data {
			bb.append_bits(u32::from(b), 8);
		}
		QrSegment::new(QrSegmentMode::Byte, data.len(), bb.0)
	}
Unixcoder Score: 0.009450816549360752
--------------------------------------------------
C_Code: 
struct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[]) {
	struct qrcodegen_Segment result;
	result.mode = qrcodegen_Mode_BYTE;
	result.bitLength = calcSegmentBitLength(result.mode, len);
	result.numChars = (int)len;
	if (len > 0)
		memcpy(buf, data, len * sizeof(buf[0]));
	result.data = buf;
	return result;
}
Function: 
pub fn make_bytes(data: &'a [u8]) -> Self {
		QrSegment::new(QrSegmentMode::Byte, data.len(), data, data.len().checked_mul(8).unwrap())
	}
Unixcoder Score: 0.004892812576144934
--------------------------------------------------
C_Code: 
struct debug_section_info
{
  /* Section file offset.  */
  off_t offset;
  /* Section size.  */
  size_t size;
  /* Section contents, after read from file.  */
  const unsigned char *data;
}
Function: 
crate struct BorrowData<'tcx> {
    /// Location where the borrow reservation starts.
    /// In many cases, this will be equal to the activation location but not always.
    crate reserve_location: Location,
    /// Location where the borrow is activated. None if this is not a
    /// 2-phase borrow.
    crate activation_location: Option<Location>,
    /// What kind of borrow this is
    crate kind: mir::BorrowKind,
    /// The region for which this borrow is live
    crate region: Region<'tcx>,
    /// Place from which we are borrowing
    crate borrowed_place: mir::Place<'tcx>,
    /// Place to which the borrow was stored
    crate assigned_place: mir::Place<'tcx>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__qrcodegen_makeAlphanumeric__idx144391_rank5.c", "source_rust_file": "Partial__qrcodegen_makeAlphanumeric__idx144391_rank5.rs", "c_api": "appendBitsToBuffer", "rust_api": "bb.append_bits", "mapping_type": "function", "description": "Appending bits to a buffer", "reasoning": "[Task Analysis] C function builds a QR code segment with alphanumeric data, Rust function does the same for numeric data. [Similarity] Names don't match but logic is semantically similar: both process character data in chunks and append bits to a buffer. [Knowledge Extraction] Found partial structural match in loop processing and bit appending logic, and API mappings for buffer operations and character processing."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__qrcodegen_makeAlphanumeric__idx144391_rank5.c", "source_rust_file": "Partial__qrcodegen_makeAlphanumeric__idx144391_rank5.rs", "c_api": "strchr", "rust_api": "text.bytes", "mapping_type": "function", "description": "Character lookup and iteration", "reasoning": "[Task Analysis] C function builds a QR code segment with alphanumeric data, Rust function does the same for numeric data. [Similarity] Names don't match but logic is semantically similar: both process character data in chunks and append bits to a buffer. [Knowledge Extraction] Found partial structural match in loop processing and bit appending logic, and API mappings for buffer operations and character processing."}, {"knowledge_type": "Partial", "source_c_file": "Partial__qrcodegen_makeAlphanumeric__idx144391_rank5.c", "source_rust_file": "Partial__qrcodegen_makeAlphanumeric__idx144391_rank5.rs", "c_fragment": "for (; *text != '\\0'; text++) {\n\t\tconst char *temp = (char *)strchr(ALPHANUMERIC_CHARSET, *text);\n\t\taccumData = accumData * 45 + (unsigned int)(temp - ALPHANUMERIC_CHARSET);\n\t\taccumCount++;\n\t\tif (accumCount == 2) {\n\t\t\tappendBitsToBuffer(accumData, 11, buf, &result.bitLength);\n\t\t\taccumData = 0;\n\t\t\taccumCount = 0;\n\t\t}\n\t}", "rust_fragment": "for b in text.bytes() {\n\t\tassert!((b'0' ..= b'9').contains(&b), \"String contains non-numeric characters\");\n\t\taccumdata = accumdata * 10 + u32::from(b - b'0');\n\t\taccumcount += 1;\n\t\tif accumcount == 3 {\n\t\t\tbb.append_bits(accumdata, 10);\n\t\t\taccumdata = 0;\n\t\t\taccumcount = 0;\n\t\t}\n\t}", "description": "Both process character data in groups and append bits to a buffer.", "reasoning": "[Task Analysis] C function builds a QR code segment with alphanumeric data, Rust function does the same for numeric data. [Similarity] Names don't match but logic is semantically similar: both process character data in chunks and append bits to a buffer. [Knowledge Extraction] Found partial structural match in loop processing and bit appending logic, and API mappings for buffer operations and character processing."}]
Unixcoder Score: -0.0021762275137007236
--------------------------------------------------
C_Code: 
struct qrcodegen_Segment qrcodegen_makeNumeric(const char *digits, uint8_t buf[]) {
	struct qrcodegen_Segment result;
	size_t len = strlen(digits);
	result.mode = qrcodegen_Mode_NUMERIC;
	int bitLen = calcSegmentBitLength(result.mode, len);
	result.numChars = (int)len;
	if (bitLen > 0)
		memset(buf, 0, ((size_t)bitLen + 7) / 8 * sizeof(buf[0]));
	result.bitLength = 0;

	unsigned int accumData = 0;
	int accumCount = 0;
	for (; *digits != '\0'; digits++) {
		char c = *digits;
		accumData = accumData * 10 + (unsigned int)(c - '0');
		accumCount++;
		if (accumCount == 3) {
			appendBitsToBuffer(accumData, 10, buf, &result.bitLength);
			accumData = 0;
			accumCount = 0;
		}
	}
	if (accumCount > 0)  // 1 or 2 digits remaining
		appendBitsToBuffer(accumData, accumCount * 3 + 1, buf, &result.bitLength);
	result.data = buf;
	return result;
}
Function: 
pub fn make_alphanumeric(text: &str, buf: &'a mut [u8]) -> Self {
		let mut bb = BitBuffer::new(buf);
		let mut accumdata: u32 = 0;
		let mut accumcount: u8 = 0;
		for c in text.chars() {
			let i: usize = ALPHANUMERIC_CHARSET.find(c)
				.expect("String contains unencodable characters in alphanumeric mode");
			accumdata = accumdata * 45 + u32::try_from(i).unwrap();
			accumcount += 1;
			if accumcount == 2 {
				bb.append_bits(accumdata, 11);
				accumdata = 0;
				accumcount = 0;
			}
		}
		if accumcount > 0 {  // 1 character remaining
			bb.append_bits(accumdata, 6);
		}
		QrSegment::new(QrSegmentMode::Alphanumeric, text.len(), bb.data, bb.length)
	}
Unixcoder Score: -0.006224371027201414
--------------------------------------------------
C_Code: 
struct debug_section_info
{
  /* Section file offset.  */
  off_t offset;
  /* Section size.  */
  size_t size;
  /* Section contents, after read from file.  */
  const unsigned char *data;
}
Function: 
crate struct BorrowData<'tcx> {
    /// Location where the borrow reservation starts.
    /// In many cases, this will be equal to the activation location but not always.
    crate reserve_location: Location,
    /// Location where the borrow is activated. None if this is not a
    /// 2-phase borrow.
    crate activation_location: Option<Location>,
    /// What kind of borrow this is
    crate kind: mir::BorrowKind,
    /// The region for which this borrow is live
    crate region: Region<'tcx>,
    /// Place from which we are borrowing
    crate borrowed_place: mir::Place<'tcx>,
    /// Place to which the borrow was stored
    crate assigned_place: mir::Place<'tcx>,
}
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.c", "source_rust_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.rs", "c_fragment": "if (bitLen > 0)\n\tmemset(buf, 0, ((size_t)bitLen + 7) / 8 * sizeof(buf[0]));", "rust_fragment": "vec![]", "description": "Initialization of buffer in C vs empty vector in Rust", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly match ('qrcodegen_makeAlphanumeric' vs 'make_segments'), but both refer to QR code segment creation logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI calls detected. [Filter 4: Semantic Domain Mismatch] -> Both deal with QR code segment generation, same domain. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are implementations (function definitions), not calls or tests. [Task Analysis] -> C function builds an alphanumeric segment by processing characters and appending bits; Rust function dispatches to appropriate segment creation based on text type. [Similarity] -> Full structural mismatch due to different approaches (manual bit manipulation vs dispatch logic), but partial semantic alignment in QR segment creation. [Knowledge Extraction] -> Extract API mappings for segment creation and character processing patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.c", "source_rust_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.rs", "c_api": "qrcodegen_makeAlphanumeric", "rust_api": "QrSegment::make_alphanumeric", "mapping_type": "function", "description": "Alphanumeric segment creation", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly match ('qrcodegen_makeAlphanumeric' vs 'make_segments'), but both refer to QR code segment creation logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI calls detected. [Filter 4: Semantic Domain Mismatch] -> Both deal with QR code segment generation, same domain. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are implementations (function definitions), not calls or tests. [Task Analysis] -> C function builds an alphanumeric segment by processing characters and appending bits; Rust function dispatches to appropriate segment creation based on text type. [Similarity] -> Full structural mismatch due to different approaches (manual bit manipulation vs dispatch logic), but partial semantic alignment in QR segment creation. [Knowledge Extraction] -> Extract API mappings for segment creation and character processing patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.c", "source_rust_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.rs", "c_api": "strchr(ALPHANUMERIC_CHARSET, *text)", "rust_api": "QrSegment::is_alphanumeric", "mapping_type": "function", "description": "Character validation against alphanumeric charset", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly match ('qrcodegen_makeAlphanumeric' vs 'make_segments'), but both refer to QR code segment creation logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI calls detected. [Filter 4: Semantic Domain Mismatch] -> Both deal with QR code segment generation, same domain. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are implementations (function definitions), not calls or tests. [Task Analysis] -> C function builds an alphanumeric segment by processing characters and appending bits; Rust function dispatches to appropriate segment creation based on text type. [Similarity] -> Full structural mismatch due to different approaches (manual bit manipulation vs dispatch logic), but partial semantic alignment in QR segment creation. [Knowledge Extraction] -> Extract API mappings for segment creation and character processing patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.c", "source_rust_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.rs", "c_api": "appendBitsToBuffer", "rust_api": "QrSegment::make_alphanumeric", "mapping_type": "function", "description": "Appending bits to buffer for QR segment", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly match ('qrcodegen_makeAlphanumeric' vs 'make_segments'), but both refer to QR code segment creation logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI calls detected. [Filter 4: Semantic Domain Mismatch] -> Both deal with QR code segment generation, same domain. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are implementations (function definitions), not calls or tests. [Task Analysis] -> C function builds an alphanumeric segment by processing characters and appending bits; Rust function dispatches to appropriate segment creation based on text type. [Similarity] -> Full structural mismatch due to different approaches (manual bit manipulation vs dispatch logic), but partial semantic alignment in QR segment creation. [Knowledge Extraction] -> Extract API mappings for segment creation and character processing patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.c", "source_rust_file": "Partial__qrcodegen_makeAlphanumeric__idx144393_rank3.rs", "c_fragment": "for (; *text != '\\0'; text++) {\n\tconst char *temp = (char *)strchr(ALPHANUMERIC_CHARSET, *text);\n\taccumData = accumData * 45 + (unsigned int)(temp - ALPHANUMERIC_CHARSET);\n\taccumCount++;\n\tif (accumCount == 2) {\n\t\tappendBitsToBuffer(accumData, 11, buf, &result.bitLength);\n\t\taccumData = 0;\n\t\taccumCount = 0;\n\t}\n}", "rust_fragment": "if QrSegment::is_alphanumeric(text) {\n\t\tQrSegment::make_alphanumeric(text)\n\t}", "description": "Character-by-character processing in C vs dispatch to alphanumeric segment in Rust", "reasoning": "[Filter 1: Entity Name Check] -> Names do not directly match ('qrcodegen_makeAlphanumeric' vs 'make_segments'), but both refer to QR code segment creation logic. [Filter 2: Empty/Trivial Code] -> Neither side is empty. [Filter 3: FFI Wrapper] -> No FFI calls detected. [Filter 4: Semantic Domain Mismatch] -> Both deal with QR code segment generation, same domain. [Filter 5: Empty Structs] -> Not applicable. [Filter 6: Definition vs Usage Asymmetry] -> Both are implementations (function definitions), not calls or tests. [Task Analysis] -> C function builds an alphanumeric segment by processing characters and appending bits; Rust function dispatches to appropriate segment creation based on text type. [Similarity] -> Full structural mismatch due to different approaches (manual bit manipulation vs dispatch logic), but partial semantic alignment in QR segment creation. [Knowledge Extraction] -> Extract API mappings for segment creation and character processing patterns."}]
Unixcoder Score: -0.006507269572466612
--------------------------------------------------
C_Code: 
struct qrcodegen_Segment qrcodegen_makeNumeric(const char *digits, uint8_t buf[]) {
	struct qrcodegen_Segment result;
	size_t len = strlen(digits);
	result.mode = qrcodegen_Mode_NUMERIC;
	int bitLen = calcSegmentBitLength(result.mode, len);
	result.numChars = (int)len;
	if (bitLen > 0)
		memset(buf, 0, ((size_t)bitLen + 7) / 8 * sizeof(buf[0]));
	result.bitLength = 0;

	unsigned int accumData = 0;
	int accumCount = 0;
	for (; *digits != '\0'; digits++) {
		char c = *digits;
		accumData = accumData * 10 + (unsigned int)(c - '0');
		accumCount++;
		if (accumCount == 3) {
			appendBitsToBuffer(accumData, 10, buf, &result.bitLength);
			accumData = 0;
			accumCount = 0;
		}
	}
	if (accumCount > 0)  // 1 or 2 digits remaining
		appendBitsToBuffer(accumData, accumCount * 3 + 1, buf, &result.bitLength);
	result.data = buf;
	return result;
}
Function: 
pub fn make_numeric(text: &str) -> Self {
		let mut bb = BitBuffer(Vec::with_capacity(text.len() * 3 + (text.len() + 2) / 3));
		let mut accumdata: u32 = 0;
		let mut accumcount: u8 = 0;
		for b in text.bytes() {
			assert!((b'0' ..= b'9').contains(&b), "String contains non-numeric characters");
			accumdata = accumdata * 10 + u32::from(b - b'0');
			accumcount += 1;
			if accumcount == 3 {
				bb.append_bits(accumdata, 10);
				accumdata = 0;
				accumcount = 0;
			}
		}
		if accumcount > 0 {  // 1 or 2 digits remaining
			bb.append_bits(accumdata, accumcount * 3 + 1);
		}
		QrSegment::new(QrSegmentMode::Numeric, text.len(), bb.0)
	}
Unixcoder Score: -0.0076917377300560474
--------------------------------------------------
