C_Code: 
std::string CheckerMock::GetAppId(const CheckerManager::StoreInfo &info)
{
    return info.bundleName;
}
Function: 
pub fn bundle_name(&self) -> &str {
        &self.bundle_name
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx485_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx485_rank1.rs", "c_api": "REQUEST_HILOGE", "rust_api": "info!(...)", "mapping_type": "function", "description": "Error logging mechanism", "reasoning": "[Task Analysis] C function is a database query with error handling and row iteration; Rust function builds SQL and delegates to inner function. [Similarity] Names don't match exactly but both perform database query logic. [Knowledge Extraction] No full structural match due to different control flow and logic. Partial match in error handling and data retrieval patterns. API mappings found for SQL construction and data access patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx485_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx485_rank1.rs", "c_api": "queryRet->GoToRow(i)", "rust_api": "self.get_app_task_qos_infos_inner(&sql)", "mapping_type": "method", "description": "Move to specific row in query result", "reasoning": "[Task Analysis] C function is a database query with error handling and row iteration; Rust function builds SQL and delegates to inner function. [Similarity] Names don't match exactly but both perform database query logic. [Knowledge Extraction] No full structural match due to different control flow and logic. Partial match in error handling and data retrieval patterns. API mappings found for SQL construction and data access patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx485_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx485_rank1.rs", "c_api": "res.push_back(TaskQosInfo{ taskId, action, mode, state, priority })", "rust_api": "self.get_app_task_qos_infos_inner(&sql)", "mapping_type": "method", "description": "Add retrieved data to result collection", "reasoning": "[Task Analysis] C function is a database query with error handling and row iteration; Rust function builds SQL and delegates to inner function. [Similarity] Names don't match exactly but both perform database query logic. [Knowledge Extraction] No full structural match due to different control flow and logic. Partial match in error handling and data retrieval patterns. API mappings found for SQL construction and data access patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__GetAppTaskQosInfos__idx485_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx485_rank1.rs", "c_fragment": "if (store_ == nullptr) {\n        return -1;\n    }", "rust_fragment": "self.get_app_task_qos_infos_inner(&sql)", "description": "Both check for null/valid state before proceeding with operation", "reasoning": "[Task Analysis] C function is a database query with error handling and row iteration; Rust function builds SQL and delegates to inner function. [Similarity] Names don't match exactly but both perform database query logic. [Knowledge Extraction] No full structural match due to different control flow and logic. Partial match in error handling and data retrieval patterns. API mappings found for SQL construction and data access patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx485_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx485_rank1.rs", "c_api": "queryRet->GetInt(0, taskId)", "rust_api": "self.get_app_task_qos_infos_inner(&sql)", "mapping_type": "method", "description": "Read integer value from query result at column index", "reasoning": "[Task Analysis] C function is a database query with error handling and row iteration; Rust function builds SQL and delegates to inner function. [Similarity] Names don't match exactly but both perform database query logic. [Knowledge Extraction] No full structural match due to different control flow and logic. Partial match in error handling and data retrieval patterns. API mappings found for SQL construction and data access patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__GetAppTaskQosInfos__idx485_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx485_rank1.rs", "c_fragment": "if (queryRet == nullptr) {\n        REQUEST_HILOGE(\"GetRunningTasksArray result set is nullptr\");\n        return -1;\n    }", "rust_fragment": "self.get_app_task_qos_infos_inner(&sql)", "description": "Both handle null result set case with error logging and early return", "reasoning": "[Task Analysis] C function is a database query with error handling and row iteration; Rust function builds SQL and delegates to inner function. [Similarity] Names don't match exactly but both perform database query logic. [Knowledge Extraction] No full structural match due to different control flow and logic. Partial match in error handling and data retrieval patterns. API mappings found for SQL construction and data access patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx485_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx485_rank1.rs", "c_api": "queryRet->GetRowCount(rowCount)", "rust_api": "self.get_app_task_qos_infos_inner(&sql)", "mapping_type": "method", "description": "Get row count from query result", "reasoning": "[Task Analysis] C function is a database query with error handling and row iteration; Rust function builds SQL and delegates to inner function. [Similarity] Names don't match exactly but both perform database query logic. [Knowledge Extraction] No full structural match due to different control flow and logic. Partial match in error handling and data retrieval patterns. API mappings found for SQL construction and data access patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx485_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx485_rank1.rs", "c_api": "store_->QueryByStep(std::string(sql))", "rust_api": "self.get_app_task_qos_infos_inner(&sql)", "mapping_type": "function", "description": "Database query execution", "reasoning": "[Task Analysis] C function is a database query with error handling and row iteration; Rust function builds SQL and delegates to inner function. [Similarity] Names don't match exactly but both perform database query logic. [Knowledge Extraction] No full structural match due to different control flow and logic. Partial match in error handling and data retrieval patterns. API mappings found for SQL construction and data access patterns."}]
Unixcoder Score: 0.0032346982043236494
--------------------------------------------------
C_Code: 
std::pair<int32_t, SchemaMeta> CloudServiceImpl::GetSchemaMeta(int32_t userId, const std::string &bundleName,
    int32_t instanceId)
{
    SchemaMeta schemaMeta;
    auto [status, cloudInfo] = GetCloudInfoFromMeta(userId);
    if (status != SUCCESS) {
        // GetCloudInfo has print the log info. so we don`t need print again.
        return { status, schemaMeta };
    }
    if (!bundleName.empty() && !cloudInfo.Exist(bundleName, instanceId)) {
        ZLOGD("bundleName:%{public}s instanceId:%{public}d is not exist", bundleName.c_str(), instanceId);
        return { ERROR, schemaMeta };
    }
    std::string schemaKey = cloudInfo.GetSchemaKey(bundleName, instanceId);
    if (MetaDataManager::GetInstance().LoadMeta(schemaKey, schemaMeta, true) &&
        schemaMeta.metaVersion == SchemaMeta::CURRENT_VERSION) {
        return { SUCCESS, schemaMeta };
    }
    UpgradeSchemaMeta(userId, schemaMeta);
    HapInfo hapInfo{ .user = userId, .instIndex = instanceId, .bundleName = bundleName };
    std::tie(status, schemaMeta) = GetSchemaFromHap(hapInfo);
    if (status == SUCCESS) {
        MetaDataManager::GetInstance().SaveMeta(schemaKey, schemaMeta, true);
        return { status, schemaMeta };
    }
    if (!Account::GetInstance()->IsVerified(userId)) {
        ZLOGE("user:%{public}d is locked!", userId);
        return { ERROR, schemaMeta };
    }
    std::tie(status, schemaMeta) = GetAppSchemaFromServer(userId, bundleName);
    if (status == NOT_SUPPORT) {
        ZLOGW("app not support, del cloudInfo! userId:%{public}d, bundleName:%{public}s", userId, bundleName.c_str());
        MetaDataManager::GetInstance().DelMeta(cloudInfo.GetKey(), true);
        return { status, schemaMeta };
    }
    if (status != SUCCESS) {
        return { status, schemaMeta };
    }
    MetaDataManager::GetInstance().SaveMeta(schemaKey, schemaMeta, true);
    return { SUCCESS, schemaMeta };
}
Function: 
pub(crate) fn get_app_schema(
        &mut self,
        user_id: i32,
        bundle_name: &str,
    ) -> ConnectResult<RwLockReadGuard<Schema>> {
        self.infos.entry(user_id).or_default();
        let infos = self.infos.get_mut(&user_id).unwrap();

        let mut lock = infos.app_schema.write().unwrap();

        let mut msg_parcel = MsgParcel::new();

        msg_parcel
            .write_string16(bundle_name)
            .map_err(|_| Error::WriteMsgParcelFailed)?;

        let function_number = GetAppSchema as u32;
        let remote_obj = self
            .remote_obj
            .clone()
            .ok_or(Error::CreateMsgParcelFailed)?;
        let mut receive = remote_obj
            .send_request(function_number, &mut msg_parcel)
            .map_err(|_| Error::SendRequestFailed)?;

        lock.read(&mut receive)?;

        drop(lock);

        Ok(infos.app_schema.read().unwrap())
    }
Unixcoder Score: 6.096938523114659e-05
--------------------------------------------------
C_Code: 
std::pair<int32_t, SchemaMeta> CloudServiceImpl::GetSchemaFromHap(const HapInfo &hapInfo)
{
    SchemaMeta schemaMeta;
    AppInfo info{ .bundleName = hapInfo.bundleName, .userId = hapInfo.user, .appIndex = hapInfo.instIndex };
    auto schemas = GetSchemaHelper::GetInstance().GetSchemaFromHap(CLOUD_SCHEMA, info);
    for (auto &schema : schemas) {
        if (schemaMeta.Unmarshall(schema)) {
            return { SUCCESS, schemaMeta };
        }
    }
    ZLOGD("get schema from hap failed, bundleName:%{public}s", hapInfo.bundleName.c_str());
    return { ERROR, schemaMeta };
}
Function: 
fn deserialize(parcel: &mut MsgParcel) -> IpcResult<Self> {
        let col_name = parcel.read_string16()?;
        let cloud_name = parcel.read_string16()?;
        let typ = parcel.read::<FieldType>()?;
        let primary = parcel.read::<bool>()?;
        let nullable = parcel.read::<bool>()?;

        let result = Field {
            col_name,
            alias: cloud_name,
            typ,
            primary,
            nullable,
        };
        Ok(result)
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4489_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4489_rank2.rs", "c_api": "LOGE", "rust_api": "loge!", "mapping_type": "function", "description": "Error logging function", "reasoning": "[Task Analysis] C function handles package removal event and extracts metadata, while Rust function handles app restore event with similar data flow. [Similarity] Names don't match but logic is semantically related (event handling, data extraction, logging). [Knowledge Extraction] Found partial structural match in event handling and data processing, and API mappings for logging and data flow operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4489_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4489_rank2.rs", "c_api": "want.GetIntParam", "rust_api": "Value::Number", "mapping_type": "function", "description": "Extracting integer parameter from event data", "reasoning": "[Task Analysis] C function handles package removal event and extracts metadata, while Rust function handles app restore event with similar data flow. [Similarity] Names don't match but logic is semantically related (event handling, data extraction, logging). [Knowledge Extraction] Found partial structural match in event handling and data processing, and API mappings for logging and data flow operations."}, {"knowledge_type": "Partial", "source_c_file": "Partial__HandlePackageRemoved__idx4489_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4489_rank2.rs", "c_fragment": "if (appId.empty() || userId == INVALID_USERID || appIndex == -1) {\n        LOGE(\"[FATAL]Get removed owner info failed, userId=%{public}d, appId=%{public}s, appIndex=%{public}d\",\n            userId, appId.c_str(), appIndex);\n        return;\n    }", "rust_fragment": "if let Ok(load) = AssetPlugin::get_instance().load_plugin() {\n        let mut params = ExtDbMap::new();\n        params.insert(PARAM_NAME_USER_ID, Value::Number(user_id as u32));\n        params.insert(PARAM_NAME_BUNDLE_NAME, Value::Bytes(bundle_name.as_bytes().to_vec()));\n        params.insert(PARAM_NAME_APP_INDEX, Value::Number(app_index as u32));", "description": "Both functions validate input data and handle error conditions before proceeding with processing.", "reasoning": "[Task Analysis] C function handles package removal event and extracts metadata, while Rust function handles app restore event with similar data flow. [Similarity] Names don't match but logic is semantically related (event handling, data extraction, logging). [Knowledge Extraction] Found partial structural match in event handling and data processing, and API mappings for logging and data flow operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4489_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4489_rank2.rs", "c_api": "want.GetStringParam", "rust_api": "Value::Bytes", "mapping_type": "function", "description": "Extracting string parameter from event data", "reasoning": "[Task Analysis] C function handles package removal event and extracts metadata, while Rust function handles app restore event with similar data flow. [Similarity] Names don't match but logic is semantically related (event handling, data extraction, logging). [Knowledge Extraction] Found partial structural match in event handling and data processing, and API mappings for logging and data flow operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4489_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4489_rank2.rs", "c_api": "want.GetBundle", "rust_api": "CStr::from_ptr", "mapping_type": "function", "description": "Extracting bundle name from event data", "reasoning": "[Task Analysis] C function handles package removal event and extracts metadata, while Rust function handles app restore event with similar data flow. [Similarity] Names don't match but logic is semantically related (event handling, data extraction, logging). [Knowledge Extraction] Found partial structural match in event handling and data processing, and API mappings for logging and data flow operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4489_rank2.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4489_rank2.rs", "c_api": "LOGI", "rust_api": "logi!", "mapping_type": "function", "description": "Info logging function", "reasoning": "[Task Analysis] C function handles package removal event and extracts metadata, while Rust function handles app restore event with similar data flow. [Similarity] Names don't match but logic is semantically related (event handling, data extraction, logging). [Knowledge Extraction] Found partial structural match in event handling and data processing, and API mappings for logging and data flow operations."}]
Unixcoder Score: -0.0021477502305060625
--------------------------------------------------
C_Code: 
std::string CheckerMock::GetAppId(const CheckerManager::StoreInfo &info)
{
    return info.bundleName;
}
Function: 
pub fn app_id(&self) -> &str {
        &self.app_id
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx629_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx629_rank1.rs", "c_api": "queryRet->GetInt(0, taskId)", "rust_api": "info.task_id", "mapping_type": "field_access", "description": "Accessing task_id field from query result.", "reasoning": "[Task Analysis] C function handles database query and result parsing, Rust function calls database and maps results to tasks. [Similarity] Names don't match but logic is semantically aligned (DB query → task creation). [Knowledge Extraction] Full match blocked by length and domain mismatch (C: DB logic, Rust: task mapping), but partial fragments and API mappings found."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx629_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx629_rank1.rs", "c_api": "res.push_back(TaskQosInfo{ taskId, action, mode, state, priority })", "rust_api": "Task { ... }", "mapping_type": "pattern", "description": "Creating a new task object from query result fields.", "reasoning": "[Task Analysis] C function handles database query and result parsing, Rust function calls database and maps results to tasks. [Similarity] Names don't match but logic is semantically aligned (DB query → task creation). [Knowledge Extraction] Full match blocked by length and domain mismatch (C: DB logic, Rust: task mapping), but partial fragments and API mappings found."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx629_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx629_rank1.rs", "c_api": "queryRet->GetInt(2, mode)", "rust_api": "info.mode", "mapping_type": "field_access", "description": "Accessing mode field from query result.", "reasoning": "[Task Analysis] C function handles database query and result parsing, Rust function calls database and maps results to tasks. [Similarity] Names don't match but logic is semantically aligned (DB query → task creation). [Knowledge Extraction] Full match blocked by length and domain mismatch (C: DB logic, Rust: task mapping), but partial fragments and API mappings found."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx629_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx629_rank1.rs", "c_api": "queryRet->GetInt(3, state)", "rust_api": "info.state", "mapping_type": "field_access", "description": "Accessing state field from query result.", "reasoning": "[Task Analysis] C function handles database query and result parsing, Rust function calls database and maps results to tasks. [Similarity] Names don't match but logic is semantically aligned (DB query → task creation). [Knowledge Extraction] Full match blocked by length and domain mismatch (C: DB logic, Rust: task mapping), but partial fragments and API mappings found."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx629_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx629_rank1.rs", "c_api": "queryRet->GetInt(4, priority)", "rust_api": "info.priority", "mapping_type": "field_access", "description": "Accessing priority field from query result.", "reasoning": "[Task Analysis] C function handles database query and result parsing, Rust function calls database and maps results to tasks. [Similarity] Names don't match but logic is semantically aligned (DB query → task creation). [Knowledge Extraction] Full match blocked by length and domain mismatch (C: DB logic, Rust: task mapping), but partial fragments and API mappings found."}, {"knowledge_type": "Partial", "source_c_file": "Partial__GetAppTaskQosInfos__idx629_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx629_rank1.rs", "c_fragment": "for (auto i = 0; i < rowCount; i++) {\n        if (queryRet->GoToRow(i) != OHOS::NativeRdb::E_OK) {\n            REQUEST_HILOGE(\"GetRunningTasksArray result set go to %{public}d row failed\", i);\n            return -1;\n        }\n        int taskId;\n        int action;\n        int mode;\n        int state;\n        int priority;\n        queryRet->GetInt(0, taskId);   // Line 0 is 'task_id'\n        queryRet->GetInt(1, action);   // Line 1 is 'action'\n        queryRet->GetInt(2, mode);     // Line 2 is 'mode'\n        queryRet->GetInt(3, state);    // Line 3 is 'state'\n        queryRet->GetInt(4, priority); // Line 4 is 'priority'\n        res.push_back(TaskQosInfo{ taskId, action, mode, state, priority });\n    }", "rust_fragment": "iter().map(|info| Task {\n            uid,\n            task_id: info.task_id,\n            mode: Mode::from(info.mode),\n            action: Action::from(info.action),\n            priority: info.priority,\n        })", "description": "Iterating over query results and mapping each row to a task object.", "reasoning": "[Task Analysis] C function handles database query and result parsing, Rust function calls database and maps results to tasks. [Similarity] Names don't match but logic is semantically aligned (DB query → task creation). [Knowledge Extraction] Full match blocked by length and domain mismatch (C: DB logic, Rust: task mapping), but partial fragments and API mappings found."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__GetAppTaskQosInfos__idx629_rank1.c", "source_rust_file": "Partial__GetAppTaskQosInfos__idx629_rank1.rs", "c_api": "queryRet->GetInt(1, action)", "rust_api": "info.action", "mapping_type": "field_access", "description": "Accessing action field from query result.", "reasoning": "[Task Analysis] C function handles database query and result parsing, Rust function calls database and maps results to tasks. [Similarity] Names don't match but logic is semantically aligned (DB query → task creation). [Knowledge Extraction] Full match blocked by length and domain mismatch (C: DB logic, Rust: task mapping), but partial fragments and API mappings found."}]
Unixcoder Score: -0.003036698792129755
--------------------------------------------------
C_Code: 
std::pair<int32_t, SchemaMeta> CloudServiceImpl::GetSchemaFromHap(const HapInfo &hapInfo)
{
    SchemaMeta schemaMeta;
    AppInfo info{ .bundleName = hapInfo.bundleName, .userId = hapInfo.user, .appIndex = hapInfo.instIndex };
    auto schemas = GetSchemaHelper::GetInstance().GetSchemaFromHap(CLOUD_SCHEMA, info);
    for (auto &schema : schemas) {
        if (schemaMeta.Unmarshall(schema)) {
            return { SUCCESS, schemaMeta };
        }
    }
    ZLOGD("get schema from hap failed, bundleName:%{public}s", hapInfo.bundleName.c_str());
    return { ERROR, schemaMeta };
}
Function: 
fn deserialize(parcel: &mut MsgParcel) -> IpcResult<Self> {
        let index = parcel.read::<u32>()?;
        match index {
            0 => Ok(FieldRaw::Null),
            1 => {
                let number = parcel.read::<i64>()?;
                Ok(FieldRaw::Number(number))
            }
            2 => {
                let real = parcel.read::<f64>()?;
                Ok(FieldRaw::Real(real))
            }
            3 => {
                let text = parcel.read_string16()?;
                Ok(FieldRaw::Text(text))
            }
            4 => {
                let boolean = parcel.read::<bool>()?;
                Ok(FieldRaw::Bool(boolean))
            }
            5 => {
                let blob = parcel.read::<Vec<u8>>()?;
                Ok(FieldRaw::Blob(blob))
            }
            6 => {
                let asset = parcel.read::<CloudAsset>()?;
                Ok(FieldRaw::Asset(asset))
            }
            7 => {
                let assets = parcel.read::<CloudAssets>()?;
                Ok(FieldRaw::Assets(assets))
            }
            _ => Err(IpcStatusCode::Failed),
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.c", "source_rust_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.rs", "c_api": "want.GetBundle()", "rust_api": "calling_info.bundle_name()", "mapping_type": "function", "description": "Retrieval of bundle name from input parameters", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data from CE DB and checks existence. [Similarity] No structural similarity at function level due to different domains (event handling vs DB operations). [Knowledge Extraction] No full/partial match due to domain mismatch (package event handling vs database operations). API mappings identified based on similar logical operations: data preparation in C maps to data deletion/check in Rust."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.c", "source_rust_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.rs", "c_api": "want.GetIntParam(SANDBOX_APP_INDEX, -1)", "rust_api": "calling_info.app_index()", "mapping_type": "function", "description": "Retrieval of sandbox app index from input parameters", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data from CE DB and checks existence. [Similarity] No structural similarity at function level due to different domains (event handling vs DB operations). [Knowledge Extraction] No full/partial match due to domain mismatch (package event handling vs database operations). API mappings identified based on similar logical operations: data preparation in C maps to data deletion/check in Rust."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.c", "source_rust_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.rs", "c_api": "want.GetIntParam(USER_ID, INVALID_USERID)", "rust_api": "calling_info.user_id()", "mapping_type": "function", "description": "Retrieval of user ID from input parameters", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data from CE DB and checks existence. [Similarity] No structural similarity at function level due to different domains (event handling vs DB operations). [Knowledge Extraction] No full/partial match due to domain mismatch (package event handling vs database operations). API mappings identified based on similar logical operations: data preparation in C maps to data deletion/check in Rust."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.c", "source_rust_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.rs", "c_api": "want.GetStringParam(APP_ID)", "rust_api": "calling_info.app_id()", "mapping_type": "function", "description": "Retrieval of application ID from input parameters", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data from CE DB and checks existence. [Similarity] No structural similarity at function level due to different domains (event handling vs DB operations). [Knowledge Extraction] No full/partial match due to domain mismatch (package event handling vs database operations). API mappings identified based on similar logical operations: data preparation in C maps to data deletion/check in Rust."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.c", "source_rust_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.rs", "c_api": "ParseGroupIds(...)", "rust_api": "db.delete_datas(...)", "mapping_type": "function", "description": "Processing group IDs and deleting data from database", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data from CE DB and checks existence. [Similarity] No structural similarity at function level due to different domains (event handling vs DB operations). [Knowledge Extraction] No full/partial match due to domain mismatch (package event handling vs database operations). API mappings identified based on similar logical operations: data preparation in C maps to data deletion/check in Rust."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.c", "source_rust_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.rs", "c_api": "onPackageRemoved(...)", "rust_api": "db.is_data_exists(...)", "mapping_type": "function", "description": "Callback invocation and data existence check", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data from CE DB and checks existence. [Similarity] No structural similarity at function level due to different domains (event handling vs DB operations). [Knowledge Extraction] No full/partial match due to domain mismatch (package event handling vs database operations). API mappings identified based on similar logical operations: data preparation in C maps to data deletion/check in Rust."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.c", "source_rust_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.rs", "c_api": "want.GetStringParam(DEVELOPER_ID)", "rust_api": "calling_info.developer_id()", "mapping_type": "function", "description": "Retrieval of developer ID from input parameters", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data from CE DB and checks existence. [Similarity] No structural similarity at function level due to different domains (event handling vs DB operations). [Knowledge Extraction] No full/partial match due to domain mismatch (package event handling vs database operations). API mappings identified based on similar logical operations: data preparation in C maps to data deletion/check in Rust."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.c", "source_rust_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.rs", "c_api": "ConstAssetBlob { .size = ..., .data = ... }", "rust_api": "Database::build(...)", "mapping_type": "pattern", "description": "Creation of asset blob for data transfer", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data from CE DB and checks existence. [Similarity] No structural similarity at function level due to different domains (event handling vs DB operations). [Knowledge Extraction] No full/partial match due to domain mismatch (package event handling vs database operations). API mappings identified based on similar logical operations: data preparation in C maps to data deletion/check in Rust."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.c", "source_rust_file": "API_Mapping__HandlePackageRemoved__idx4480_rank1.rs", "c_api": "want.GetStringParam(GROUP_IDS)", "rust_api": "calling_info.group_ids()", "mapping_type": "function", "description": "Retrieval of group IDs from input parameters", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data from CE DB and checks existence. [Similarity] No structural similarity at function level due to different domains (event handling vs DB operations). [Knowledge Extraction] No full/partial match due to domain mismatch (package event handling vs database operations). API mappings identified based on similar logical operations: data preparation in C maps to data deletion/check in Rust."}]
Unixcoder Score: -0.006798950023949146
--------------------------------------------------
C_Code: 
std::pair<int32_t, SchemaMeta> CloudServiceImpl::GetSchemaFromHap(const HapInfo &hapInfo)
{
    SchemaMeta schemaMeta;
    AppInfo info{ .bundleName = hapInfo.bundleName, .userId = hapInfo.user, .appIndex = hapInfo.instIndex };
    auto schemas = GetSchemaHelper::GetInstance().GetSchemaFromHap(CLOUD_SCHEMA, info);
    for (auto &schema : schemas) {
        if (schemaMeta.Unmarshall(schema)) {
            return { SUCCESS, schemaMeta };
        }
    }
    ZLOGD("get schema from hap failed, bundleName:%{public}s", hapInfo.bundleName.c_str());
    return { ERROR, schemaMeta };
}
Function: 
pub fn get_app_schema(&mut self, bundle_name: &str) -> SyncResult<SchemaMeta> {
        let schema_ipc = self.connect.get_app_schema(self.user_id, bundle_name)?;
        Ok(SchemaMeta::from(schema_ipc.deref()))
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_fragment": "std::string appId = want.GetStringParam(APP_ID);\n    int appIndex = isSandBoxApp ? want.GetIntParam(SANDBOX_APP_INDEX, -1) : want.GetIntParam(APP_INDEX, -1);\n    if (appId.empty() || userId == INVALID_USERID || appIndex == -1) {\n        LOGE(\"[FATAL]Get removed owner info failed, userId=%{public}d, appId=%{public}s, appIndex=%{public}d\",\n            userId, appId.c_str(), appIndex);\n        return;\n    }\n    std::string owner = appId + OWNER_INFO_SEPARATOR + std::to_string(appIndex);\n    ConstAssetBlob ownerBlob = { .size = owner.size(), .data = reinterpret_cast<const uint8_t *>(owner.c_str()) };", "rust_fragment": "let owner: Vec<u8> = unsafe { slice::from_raw_parts(owner.data, owner.size as usize).to_vec() };", "description": "Both extract and process owner information from input parameters into a blob structure.", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_api": "want.GetIntParam(...)", "rust_api": "user_id: i32", "mapping_type": "function", "description": "Extracting integer parameter from input structure", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_api": "want.GetStringParam(APP_ID)", "rust_api": "owner: Vec<u8> = unsafe { slice::from_raw_parts(owner.data, owner.size as usize).to_vec() }", "mapping_type": "function", "description": "Extracting string parameter from input structure", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_api": "onPackageRemoved(...)", "rust_api": "delete_on_package_removed(&calling_info)", "mapping_type": "function", "description": "Invoking callback or operation with structured data", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_fragment": "if (onPackageRemoved != nullptr) {\n        onPackageRemoved({ userId, appIndex, ownerBlob, developerIdBlob, groupIdBlobArray, bundleNameBlob });\n    }", "rust_fragment": "for calling_info in construct_calling_infos(user_id, owner.clone(), developer_id, group_ids) {\n        clear_cryptos(&calling_info);\n        let res = match delete_on_package_removed(&calling_info) {", "description": "Both involve invoking a callback or operation with structured data after validation.", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__HandlePackageRemoved__idx4484_rank1.c", "source_rust_file": "Partial__HandlePackageRemoved__idx4484_rank1.rs", "c_api": "ConstAssetBlob ownerBlob = { .size = owner.size(), .data = reinterpret_cast<const uint8_t *>(owner.c_str()) };", "rust_api": "let owner: Vec<u8> = unsafe { slice::from_raw_parts(owner.data, owner.size as usize).to_vec() };", "mapping_type": "type", "description": "Converting string to byte blob for data transfer", "reasoning": "[Task Analysis] C function handles package removal event and prepares data for callback; Rust function deletes data by owner and handles cleanup. [Similarity] Names refer to different concepts (HandlePackageRemoved vs delete_data_by_owner), domains differ (event handling vs data deletion), and code lengths are significantly different (>3x). [Knowledge Extraction] No full match due to domain mismatch and length difference. However, both involve processing owner info and calling callbacks/operations with similar data structures. Extract partial structural fragments and API mappings based on shared logic patterns."}]
Unixcoder Score: -0.0161665640771389
--------------------------------------------------
C_Code: 
std::pair<int32_t, SchemaMeta> CloudServiceImpl::GetSchemaFromHap(const HapInfo &hapInfo)
{
    SchemaMeta schemaMeta;
    AppInfo info{ .bundleName = hapInfo.bundleName, .userId = hapInfo.user, .appIndex = hapInfo.instIndex };
    auto schemas = GetSchemaHelper::GetInstance().GetSchemaFromHap(CLOUD_SCHEMA, info);
    for (auto &schema : schemas) {
        if (schemaMeta.Unmarshall(schema)) {
            return { SUCCESS, schemaMeta };
        }
    }
    ZLOGD("get schema from hap failed, bundleName:%{public}s", hapInfo.bundleName.c_str());
    return { ERROR, schemaMeta };
}
Function: 
fn try_from(value: u8) -> Result<Self, Self::Error> {
        let typ = match value {
            0 => FieldType::Null,
            1 => FieldType::Number,
            2 => FieldType::Real,
            3 => FieldType::Text,
            4 => FieldType::Bool,
            5 => FieldType::Blob,
            6 => FieldType::Asset,
            7 => FieldType::Assets,
            _ => return Err(Error::InvalidFieldType),
        };
        Ok(typ)
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "ZLOGD(...)", "rust_api": "log::debug!(...)", "mapping_type": "function", "description": "Debug logging", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "ZLOGE(...)", "rust_api": "log::error!(...)", "mapping_type": "function", "description": "Error logging", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "map_err(|_| Error::WriteMsgParcelFailed)", "rust_api": "map_err(|_| Error::WriteMsgParcelFailed)", "mapping_type": "pattern", "description": "Error handling for message parcel writing", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "MetaDataManager::GetInstance().LoadMeta(schemaKey, schemaMeta, true)", "rust_api": "database.load_meta(...)", "mapping_type": "function", "description": "Loading metadata from database", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "std::tie(status, schemaMeta) = GetAppSchemaFromServer(userId, bundleName)", "rust_api": "let result = database.get_app_schema_from_server(...)", "mapping_type": "function", "description": "Retrieving app schema from server", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "MetaDataManager::GetInstance().SaveMeta(schemaKey, schemaMeta, true)", "rust_api": "database.save_meta(...)", "mapping_type": "function", "description": "Saving metadata to database", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "std::tie(status, schemaMeta) = GetSchemaFromHap(hapInfo)", "rust_api": "let result = database.get_schema_from_hap(...)", "mapping_type": "function", "description": "Retrieving schema from HAP", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "map_err(|_| Error::SendRequestFailed)", "rust_api": "map_err(|_| Error::SendRequestFailed)", "mapping_type": "pattern", "description": "Error handling for sending request", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "MetaDataManager::GetInstance().DelMeta(cloudInfo.GetKey(), true)", "rust_api": "database.delete_meta(...)", "mapping_type": "function", "description": "Deleting metadata from database", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "ZLOGW(...)", "rust_api": "log::warn!(...)", "mapping_type": "function", "description": "Warning logging", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5058_rank2.rs", "c_api": "return { status, schemaMeta };", "rust_api": "Ok(Self { ... })", "mapping_type": "pattern", "description": "Returning result with success/failure status", "reasoning": "[Task Analysis] C function is a complex logic flow for retrieving schema metadata with multiple conditional checks and database operations; Rust function is a constructor-like method that builds a database stub via IPC communication. [Similarity] Names do not refer to the same concept (GetSchemaMeta vs new), and domains are different (metadata retrieval vs IPC communication). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to database operations and error handling patterns."}]
Unixcoder Score: -0.02545762062072754
--------------------------------------------------
C_Code: 
std::pair<bool, StoreMetaData> AppDataListenerWrap::LoadMetaData(const std::string &bundleName,
    const std::string &storeId, int32_t userId)
{
    StoreMetaData metaData;
    metaData.deviceId = DeviceManagerAdapter::GetInstance().GetLocalDevice().uuid;
    metaData.bundleName = bundleName;
    metaData.storeId = storeId;
    metaData.user = std::to_string(userId);
    auto ret = MetaDataManager::GetInstance().LoadMeta(metaData.GetKeyWithoutPath(), metaData);
    if (!ret) {
        metaData.user = SYSTEM_USER;
        ret = MetaDataManager::GetInstance().LoadMeta(metaData.GetKeyWithoutPath(), metaData);
    }
    return { ret, metaData };
}
Function: 
pub fn get_app_schema(&mut self, bundle_name: &str) -> SyncResult<SchemaMeta> {
        let schema_ipc = self.connect.get_app_schema(self.user_id, bundle_name)?;
        Ok(SchemaMeta::from(schema_ipc.deref()))
    }
Unixcoder Score: -0.026696855202317238
--------------------------------------------------
C_Code: 
std::pair<int32_t, SchemaMeta> CloudServiceImpl::GetSchemaFromHap(const HapInfo &hapInfo)
{
    SchemaMeta schemaMeta;
    AppInfo info{ .bundleName = hapInfo.bundleName, .userId = hapInfo.user, .appIndex = hapInfo.instIndex };
    auto schemas = GetSchemaHelper::GetInstance().GetSchemaFromHap(CLOUD_SCHEMA, info);
    for (auto &schema : schemas) {
        if (schemaMeta.Unmarshall(schema)) {
            return { SUCCESS, schemaMeta };
        }
    }
    ZLOGD("get schema from hap failed, bundleName:%{public}s", hapInfo.bundleName.c_str());
    return { ERROR, schemaMeta };
}
Function: 
pub(crate) fn get_app_schema(
        &mut self,
        user_id: i32,
        bundle_name: &str,
    ) -> ConnectResult<RwLockReadGuard<Schema>> {
        self.infos.entry(user_id).or_default();
        let infos = self.infos.get_mut(&user_id).unwrap();

        let mut lock = infos.app_schema.write().unwrap();

        let mut msg_parcel = MsgParcel::new();

        msg_parcel
            .write_string16(bundle_name)
            .map_err(|_| Error::WriteMsgParcelFailed)?;

        let function_number = GetAppSchema as u32;
        let remote_obj = self
            .remote_obj
            .clone()
            .ok_or(Error::CreateMsgParcelFailed)?;
        let mut receive = remote_obj
            .send_request(function_number, &mut msg_parcel)
            .map_err(|_| Error::SendRequestFailed)?;

        lock.read(&mut receive)?;

        drop(lock);

        Ok(infos.app_schema.read().unwrap())
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__Show__idx864_rank2.c", "source_rust_file": "Partial__Show__idx864_rank2.rs", "c_fragment": "if (ret != ExceptionErrorCode::E_OK) {\n        REQUEST_HILOGE(\"End Request Show err, tid: %{public}s, failed: %{public}d\", tid.c_str(), ret);\n        return ret;\n    }\n\n    int32_t errCode = rets[0].code;\n    if (errCode != E_OK) {\n        REQUEST_HILOGE(\"End Request Show, tid: %{public}s, failed: %{public}d\", tid.c_str(), errCode);\n        return errCode;\n    }\n    info = rets[0].info;", "rust_fragment": "if len > GET_INFO_MAX {\n            info!(\"Service show: out of size: {}\", len);\n            reply.write(&(ErrorCode::Other as i32))?;\n            return Err(IpcStatusCode::Failed);\n        }\n\n        let ipc_uid = ipc::Skeleton::calling_uid();\n        let mut vec = vec![(ErrorCode::Other, TaskInfo::new()); len];\n        for i in 0..len {\n            let task_id: String = data.read()?;\n            info!(\"Service show tid {}\", task_id);\n\n            let Ok(task_id) = task_id.parse::<u32>() else {\n                error!(\"Service show, failed: tid not valid: {}\", task_id);\n                sys_event!(\n                    ExecError,\n                    DfxCode::INVALID_IPC_MESSAGE_A18,\n                    &format!(\"Service show, failed: tid not valid: {}\", task_id)\n                );\n                set_code_with_index_other(&mut vec, i, ErrorCode::TaskNotFound);\n                continue;\n            };", "description": "Both perform validation checks and return early on failure, with error logging.", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code is a method that handles a 'Show' request, logging, validating input, querying a database, and returning results. The Rust code is a function that also handles a 'Show' request, with more complex validation and error handling logic. Both perform similar high-level operations (request handling, validation, data retrieval, response building) but differ in domain (C uses IPC-style logging and error codes, Rust uses more structured error handling and system events). The code lengths are not drastically different, and both are implementations, not tests. However, the semantic domains differ significantly (C-style IPC vs Rust-style system event logging and structured error handling). There are no full structural matches due to domain mismatch, but there are partial matches in control flow and data handling patterns. API mappings can be extracted for similar operations like logging, data reading, and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Show__idx864_rank2.c", "source_rust_file": "Partial__Show__idx864_rank2.rs", "c_api": "data.read()", "rust_api": "data.read()", "mapping_type": "method", "description": "Reading data from a parcel", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code is a method that handles a 'Show' request, logging, validating input, querying a database, and returning results. The Rust code is a function that also handles a 'Show' request, with more complex validation and error handling logic. Both perform similar high-level operations (request handling, validation, data retrieval, response building) but differ in domain (C uses IPC-style logging and error codes, Rust uses more structured error handling and system events). The code lengths are not drastically different, and both are implementations, not tests. However, the semantic domains differ significantly (C-style IPC vs Rust-style system event logging and structured error handling). There are no full structural matches due to domain mismatch, but there are partial matches in control flow and data handling patterns. API mappings can be extracted for similar operations like logging, data reading, and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Show__idx864_rank2.c", "source_rust_file": "Partial__Show__idx864_rank2.rs", "c_api": "RequestServiceProxy::ShowTasks", "rust_api": "RequestDb::get_instance().query_task_uid", "mapping_type": "function", "description": "Querying task information from a database", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code is a method that handles a 'Show' request, logging, validating input, querying a database, and returning results. The Rust code is a function that also handles a 'Show' request, with more complex validation and error handling logic. Both perform similar high-level operations (request handling, validation, data retrieval, response building) but differ in domain (C uses IPC-style logging and error codes, Rust uses more structured error handling and system events). The code lengths are not drastically different, and both are implementations, not tests. However, the semantic domains differ significantly (C-style IPC vs Rust-style system event logging and structured error handling). There are no full structural matches due to domain mismatch, but there are partial matches in control flow and data handling patterns. API mappings can be extracted for similar operations like logging, data reading, and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Show__idx864_rank2.c", "source_rust_file": "Partial__Show__idx864_rank2.rs", "c_api": "rets[0].info", "rust_api": "task_info", "mapping_type": "field_access", "description": "Accessing task information from a result structure", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code is a method that handles a 'Show' request, logging, validating input, querying a database, and returning results. The Rust code is a function that also handles a 'Show' request, with more complex validation and error handling logic. Both perform similar high-level operations (request handling, validation, data retrieval, response building) but differ in domain (C uses IPC-style logging and error codes, Rust uses more structured error handling and system events). The code lengths are not drastically different, and both are implementations, not tests. However, the semantic domains differ significantly (C-style IPC vs Rust-style system event logging and structured error handling). There are no full structural matches due to domain mismatch, but there are partial matches in control flow and data handling patterns. API mappings can be extracted for similar operations like logging, data reading, and error handling."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Show__idx864_rank2.c", "source_rust_file": "Partial__Show__idx864_rank2.rs", "c_fragment": "REQUEST_HILOGD(\"Request Show, tid: %{public}s\", tid.c_str());\n    std::vector<std::string> tids = { tid };\n    TaskInfoRet infoRet{ .code = ExceptionErrorCode::E_OTHER };\n    std::vector<TaskInfoRet> rets = { infoRet };\n\n    int32_t ret = RequestServiceProxy::ShowTasks(tids, rets);", "rust_fragment": "debug!(\"Service show\");\n        let permission = PermissionChecker::check_down_permission();\n        let len: u32 = data.read()?;\n        let len = len as usize;\n\n        if len > GET_INFO_MAX {\n            info!(\"Service show: out of size: {}\", len);\n            reply.write(&(ErrorCode::Other as i32))?;\n            return Err(IpcStatusCode::Failed);\n        }\n\n        let ipc_uid = ipc::Skeleton::calling_uid();\n        let mut vec = vec![(ErrorCode::Other, TaskInfo::new()); len];", "description": "Both handle initial setup and validation of input data before proceeding with task processing.", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code is a method that handles a 'Show' request, logging, validating input, querying a database, and returning results. The Rust code is a function that also handles a 'Show' request, with more complex validation and error handling logic. Both perform similar high-level operations (request handling, validation, data retrieval, response building) but differ in domain (C uses IPC-style logging and error codes, Rust uses more structured error handling and system events). The code lengths are not drastically different, and both are implementations, not tests. However, the semantic domains differ significantly (C-style IPC vs Rust-style system event logging and structured error handling). There are no full structural matches due to domain mismatch, but there are partial matches in control flow and data handling patterns. API mappings can be extracted for similar operations like logging, data reading, and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Show__idx864_rank2.c", "source_rust_file": "Partial__Show__idx864_rank2.rs", "c_api": "REQUEST_HILOGD", "rust_api": "debug!", "mapping_type": "function", "description": "Logging at debug level", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code is a method that handles a 'Show' request, logging, validating input, querying a database, and returning results. The Rust code is a function that also handles a 'Show' request, with more complex validation and error handling logic. Both perform similar high-level operations (request handling, validation, data retrieval, response building) but differ in domain (C uses IPC-style logging and error codes, Rust uses more structured error handling and system events). The code lengths are not drastically different, and both are implementations, not tests. However, the semantic domains differ significantly (C-style IPC vs Rust-style system event logging and structured error handling). There are no full structural matches due to domain mismatch, but there are partial matches in control flow and data handling patterns. API mappings can be extracted for similar operations like logging, data reading, and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Show__idx864_rank2.c", "source_rust_file": "Partial__Show__idx864_rank2.rs", "c_api": "REQUEST_HILOGE", "rust_api": "error!", "mapping_type": "function", "description": "Logging at error level", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code is a method that handles a 'Show' request, logging, validating input, querying a database, and returning results. The Rust code is a function that also handles a 'Show' request, with more complex validation and error handling logic. Both perform similar high-level operations (request handling, validation, data retrieval, response building) but differ in domain (C uses IPC-style logging and error codes, Rust uses more structured error handling and system events). The code lengths are not drastically different, and both are implementations, not tests. However, the semantic domains differ significantly (C-style IPC vs Rust-style system event logging and structured error handling). There are no full structural matches due to domain mismatch, but there are partial matches in control flow and data handling patterns. API mappings can be extracted for similar operations like logging, data reading, and error handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Show__idx864_rank2.c", "source_rust_file": "Partial__Show__idx864_rank2.rs", "c_api": "reply.write()", "rust_api": "reply.write()", "mapping_type": "method", "description": "Writing data to a reply parcel", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] The C code is a method that handles a 'Show' request, logging, validating input, querying a database, and returning results. The Rust code is a function that also handles a 'Show' request, with more complex validation and error handling logic. Both perform similar high-level operations (request handling, validation, data retrieval, response building) but differ in domain (C uses IPC-style logging and error codes, Rust uses more structured error handling and system events). The code lengths are not drastically different, and both are implementations, not tests. However, the semantic domains differ significantly (C-style IPC vs Rust-style system event logging and structured error handling). There are no full structural matches due to domain mismatch, but there are partial matches in control flow and data handling patterns. API mappings can be extracted for similar operations like logging, data reading, and error handling."}]
Unixcoder Score: -0.027551492676138878
--------------------------------------------------
C_Code: 
std::pair<int32_t, SchemaMeta> CloudServiceImpl::GetSchemaFromHap(const HapInfo &hapInfo)
{
    SchemaMeta schemaMeta;
    AppInfo info{ .bundleName = hapInfo.bundleName, .userId = hapInfo.user, .appIndex = hapInfo.instIndex };
    auto schemas = GetSchemaHelper::GetInstance().GetSchemaFromHap(CLOUD_SCHEMA, info);
    for (auto &schema : schemas) {
        if (schemaMeta.Unmarshall(schema)) {
            return { SUCCESS, schemaMeta };
        }
    }
    ZLOGD("get schema from hap failed, bundleName:%{public}s", hapInfo.bundleName.c_str());
    return { ERROR, schemaMeta };
}
Function: 
fn deserialize(parcel: &mut MsgParcel) -> IpcResult<Self> {
        let app_id = parcel.read_string16()?;
        let bundle_name = parcel.read_string16()?;
        let cloud_switch = parcel.read::<i32>()? != 0;
        let instance_id = parcel.read::<i32>()?;

        let result = Self {
            app_id,
            bundle_name,
            cloud_switch,
            instance_id,
        };
        Ok(result)
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.rs", "c_api": "if (status != SUCCESS) { return { status, schemaMeta }; }", "rust_api": "map_err(|_| Error::WriteMsgParcelFailed)?", "mapping_type": "pattern", "description": "Early return on error condition", "reasoning": "[Task Analysis] C function handles schema metadata retrieval with multiple conditional checks and fallbacks; Rust function performs IPC communication to fetch app schema. [Similarity] Names don't match but both involve retrieving schema data. [Knowledge Extraction] No full structural match due to different domains (metadata management vs IPC communication). However, there are API mappings related to schema retrieval and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.rs", "c_api": "if (status != SUCCESS) { return { status, schemaMeta }; }", "rust_api": "map_err(|_| Error::SendRequestFailed)?", "mapping_type": "pattern", "description": "Error propagation on failed operation", "reasoning": "[Task Analysis] C function handles schema metadata retrieval with multiple conditional checks and fallbacks; Rust function performs IPC communication to fetch app schema. [Similarity] Names don't match but both involve retrieving schema data. [Knowledge Extraction] No full structural match due to different domains (metadata management vs IPC communication). However, there are API mappings related to schema retrieval and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.rs", "c_api": "return { status, schemaMeta };", "rust_api": "Ok(infos.app_schema.read().unwrap())", "mapping_type": "pattern", "description": "Return value pattern for successful operation", "reasoning": "[Task Analysis] C function handles schema metadata retrieval with multiple conditional checks and fallbacks; Rust function performs IPC communication to fetch app schema. [Similarity] Names don't match but both involve retrieving schema data. [Knowledge Extraction] No full structural match due to different domains (metadata management vs IPC communication). However, there are API mappings related to schema retrieval and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.c", "source_rust_file": "API_Mapping__GetSchemaMeta__idx5112_rank2.rs", "c_api": "if (status == SUCCESS) { MetaDataManager::GetInstance().SaveMeta(schemaKey, schemaMeta, true); return { status, schemaMeta }; }", "rust_api": "lock.read(&mut receive)?;", "mapping_type": "pattern", "description": "Successful data read and processing", "reasoning": "[Task Analysis] C function handles schema metadata retrieval with multiple conditional checks and fallbacks; Rust function performs IPC communication to fetch app schema. [Similarity] Names don't match but both involve retrieving schema data. [Knowledge Extraction] No full structural match due to different domains (metadata management vs IPC communication). However, there are API mappings related to schema retrieval and error handling patterns."}]
Unixcoder Score: -0.027609970420598984
--------------------------------------------------
