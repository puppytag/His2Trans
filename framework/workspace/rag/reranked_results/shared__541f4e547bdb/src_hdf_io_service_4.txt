C_Code: 
void ResponseMessageReceiver::ShutdownChannel()
{
    {
        std::lock_guard<std::mutex> lock(sockFdMutex_);
        if (sockFd_ > 0) {
            serviceHandler_->RemoveFileDescriptorListener(sockFd_);
            fdsan_close_with_tag(sockFd_, REQUEST_FDSAN_TAG);
        }
        sockFd_ = -1;
    }
    this->handler_->OnChannelBroken();
}
Function: 
fn handle_subscribe(
        &mut self,
        tid: u32,
        pid: u64,
        _uid: u64,
        _token_id: u64,
        tx: Sender<ErrorCode>,
    ) {
        if let Some(_client) = self.clients.get_mut(&pid) {
            self.pid_map.insert(tid, pid);
            let _ = tx.send(ErrorCode::ErrOk);
        } else {
            info!("channel not open, pid {}", pid);
            let _ = tx.send(ErrorCode::ChannelNotOpen);
        }
    }
Unixcoder Score: 0.07688210904598236
--------------------------------------------------
C_Code: 
bool DownloadServiceStub::OnRemove(MessageParcel &data, MessageParcel &reply)
{
    if (!CheckPermission()) {
        DOWNLOAD_HILOGE("query mime type no permission, pid:%{public}d", IPCSkeleton::GetCallingPid());
        return false;
    }
    bool result = Remove(data.ReadInt32());
    if (!reply.WriteBool(result)) {
        DOWNLOAD_HILOGE("WriteBool failed");
        return false;
    }
    return true;
}
Function: 
fn remove(&self, data: &BorrowedMsgParcel, reply: &mut BorrowedMsgParcel) -> IpcResult<()> {
        Ok(())
    }
Unixcoder Score: 0.07073437422513962
--------------------------------------------------
C_Code: 
void ResponseMessageReceiver::ShutdownChannel()
{
    {
        std::lock_guard<std::mutex> lock(sockFdMutex_);
        if (sockFd_ > 0) {
            serviceHandler_->RemoveFileDescriptorListener(sockFd_);
            fdsan_close_with_tag(sockFd_, REQUEST_FDSAN_TAG);
        }
        sockFd_ = -1;
    }
    this->handler_->OnChannelBroken();
}
Function: 
async fn run(mut self) {
        loop {
            let recv = match self.rx.recv().await {
                Ok(message) => message,
                Err(e) => {
                    error!("ClientManager recv error {:?}", e);
                    sys_event!(
                        ExecFault,
                        DfxCode::UDS_FAULT_03,
                        &format!("ClientManager recv error {:?}", e)
                    );
                    continue;
                }
            };

            match recv {
                ClientEvent::OpenChannel(pid, tx) => self.handle_open_channel(pid, tx),
                ClientEvent::Subscribe(tid, pid, uid, token_id, tx) => {
                    self.handle_subscribe(tid, pid, uid, token_id, tx)
                }
                ClientEvent::Unsubscribe(tid, tx) => self.handle_unsubscribe(tid, tx),
                ClientEvent::TaskFinished(tid) => self.handle_task_finished(tid),
                ClientEvent::Terminate(pid, tx) => self.handle_process_terminated(pid, tx),
                ClientEvent::SendResponse(tid, version, status_code, reason, headers) => {
                    if let Some(&pid) = self.pid_map.get(&tid) {
                        if let Some((tx, _fd)) = self.clients.get_mut(&pid) {
                            if let Err(err) = tx.send(ClientEvent::SendResponse(
                                tid,
                                version,
                                status_code,
                                reason,
                                headers,
                            )) {
                                error!("send response error, {}", err);
                                sys_event!(
                                    ExecFault,
                                    DfxCode::UDS_FAULT_02,
                                    &format!("send response error, {}", err)
                                );
                            }
                        } else {
                            debug!("response client not found");
                        }
                    } else {
                        debug!("response pid not found");
                    }
                }
                ClientEvent::SendNotifyData(subscribe_type, notify_data) => {
                    if let Some(&pid) = self.pid_map.get(&(notify_data.task_id)) {
                        if let Some((tx, _fd)) = self.clients.get_mut(&pid) {
                            if let Err(err) =
                                tx.send(ClientEvent::SendNotifyData(subscribe_type, notify_data))
                            {
                                error!("send notify data error, {}", err);
                                sys_event!(
                                    ExecFault,
                                    DfxCode::UDS_FAULT_02,
                                    &format!("send notify data error, {}", err)
                                );
                            }
                        } else {
                            debug!("response client not found");
                        }
                    } else {
                        debug!("notify data pid not found");
                    }
                }
                ClientEvent::SendFaults(tid, subscribe_type, reason) => {
                    if let Some(&pid) = self.pid_map.get(&tid) {
                        if let Some((tx, _fd)) = self.clients.get_mut(&pid) {
                            if let Err(err) =
                                tx.send(ClientEvent::SendFaults(tid, subscribe_type, reason))
                            {
                                error!("send faults error, {}", err);
                                sys_event!(
                                    ExecFault,
                                    DfxCode::UDS_FAULT_02,
                                    &format!("send faults error, {}", err)
                                );
                            }
                        }
                    }
                }
                ClientEvent::SendWaitNotify(tid, reason) => {
                    if let Some(&pid) = self.pid_map.get(&tid) {
                        if let Some((tx, _fd)) = self.clients.get_mut(&pid) {
                            if let Err(err) = tx.send(ClientEvent::SendWaitNotify(tid, reason)) {
                                error!("send faults error, {}", err);
                                sys_event!(
                                    ExecFault,
                                    DfxCode::UDS_FAULT_02,
                                    &format!("send faults error, {}", err)
                                );
                            }
                        }
                    }
                }
                _ => {}
            }

            debug!("ClientManager handle message done");
        }
    }
Unixcoder Score: 0.0666106715798378
--------------------------------------------------
C_Code: 
void ResponseMessageReceiver::ShutdownChannel()
{
    {
        std::lock_guard<std::mutex> lock(sockFdMutex_);
        if (sockFd_ > 0) {
            serviceHandler_->RemoveFileDescriptorListener(sockFd_);
            fdsan_close_with_tag(sockFd_, REQUEST_FDSAN_TAG);
        }
        sockFd_ = -1;
    }
    this->handler_->OnChannelBroken();
}
Function: 
pub(crate) fn open_channel(&self, pid: u64) -> Result<Arc<UnixDatagram>, ErrorCode> {
        let (tx, rx) = channel::<Result<Arc<UnixDatagram>, ErrorCode>>();
        let event = ClientEvent::OpenChannel(pid, tx);
        if !self.send_event(event) {
            return Err(ErrorCode::Other);
        }
        let rx = Recv::new(rx);
        match rx.get() {
            Some(ret) => ret,
            None => {
                error!("open channel fail, recv none");
                sys_event!(
                    ExecFault,
                    DfxCode::UDS_FAULT_03,
                    "open channel fail, recv none"
                );
                Err(ErrorCode::Other)
            }
        }
    }
Unixcoder Score: 0.05948197469115257
--------------------------------------------------
C_Code: 
bool DownloadServiceStub::OnRemove(MessageParcel &data, MessageParcel &reply)
{
    if (!CheckPermission()) {
        DOWNLOAD_HILOGE("query mime type no permission, pid:%{public}d", IPCSkeleton::GetCallingPid());
        return false;
    }
    bool result = Remove(data.ReadInt32());
    if (!reply.WriteBool(result)) {
        DOWNLOAD_HILOGE("WriteBool failed");
        return false;
    }
    return true;
}
Function: 
fn remove(&self, data: &BorrowedMsgParcel, reply: &mut BorrowedMsgParcel) -> IpcResult<()> {
        self.0.remove(data, reply)
    }
Unixcoder Score: 0.05547710880637169
--------------------------------------------------
C_Code: 
pid_t IPCSkeleton::GetCallingPid()
    {
        if (GetDBinderServiceStubInterface() == nullptr) {
            return 0;
        }
        return GetDBinderServiceStubInterface()->GetCallingPid();
    }
Function: 
fn skeleton() {
    unsafe {
        assert_eq!(
            Skeleton::calling_device_id(),
            (*GetCallingDeviceID()).to_string()
        );
        assert_eq!(Skeleton::calling_full_token_id(), GetCallingFullTokenID());
        assert_eq!(Skeleton::calling_pid(), GetCallingPid());
        assert_eq!(Skeleton::calling_real_pid(), GetCallingRealPid());
        assert_eq!(Skeleton::calling_token_id(), GetCallingTokenID());
        assert_eq!(Skeleton::calling_uid(), GetCallingUid());
        assert_eq!(Skeleton::first_full_token_id(), GetFirstFullTokenID());
        assert_eq!(Skeleton::first_token_id(), GetFirstTokenID());
        assert_eq!(Skeleton::self_token_id(), SelfTokenID());
        assert_eq!(Skeleton::is_local_calling(), IsLocalCalling());
        assert_eq!(Skeleton::local_device_id(), (*LocalDeviceID()).to_string());
        assert_eq!(
            Skeleton::reset_calling_identity(),
            (*ResetCallingIdentity()).to_string()
        );
    }
}
Unixcoder Score: 0.03982027992606163
--------------------------------------------------
C_Code: 
struct RemoteServiceStub
Function: 
pub struct SystemAbility {
    inner: UniquePtr<SystemAbilityWrapper>,
}
Unixcoder Score: 0.0331140011548996
--------------------------------------------------
C_Code: 
struct RemoteServiceStub
Function: 
pub struct AbilityStub {
    remote: RemoteStubWrapper,
}
Unixcoder Score: 0.03299470245838165
--------------------------------------------------
C_Code: 
struct RemoteServiceStub
Function: 
pub struct UnsubscribeHandler {
    inner: Unsubscribe,
}
Unixcoder Score: 0.03223653882741928
--------------------------------------------------
C_Code: 
struct RemoteServiceStub
Function: 
pub struct AbilityStub {
    inner: Box<dyn RemoteStub>,
}
Unixcoder Score: 0.03192155808210373
--------------------------------------------------
