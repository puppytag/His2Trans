C_Code: 
int32_t InvokerListenThreadStub(uint32_t code, IpcIo *data, IpcIo *reply, MessageOption option, OnRemoteRequest func)
{
    (void)code;
    (void)data;
    (void)reply;
    (void)option;
    (void)func;
    return ERR_NONE;
}
Function: 
fn on_remote_request(&self, code: u32, data: &mut MsgParcel, reply: &mut MsgParcel) -> i32 {
        R::on_remote_request(self, code, data, reply)
    }
Unixcoder Score: 0.089283287525177
--------------------------------------------------
C_Code: 
int32_t InvokerListenThreadStub(uint32_t code, IpcIo *data, IpcIo *reply, MessageOption option, OnRemoteRequest func)
{
    (void)code;
    (void)data;
    (void)reply;
    (void)option;
    (void)func;
    return ERR_NONE;
}
Function: 
pub fn on_remote_request(
        &mut self,
        code: u32,
        data: Pin<&mut MessageParcel>,
        reply: Pin<&mut MessageParcel>,
    ) -> i32 {
        unsafe {
            let mut data = MsgParcel::from_ptr(data.get_unchecked_mut() as *mut MessageParcel);
            let mut reply = MsgParcel::from_ptr(reply.get_unchecked_mut() as *mut MessageParcel);
            self.inner.on_remote_request(code, &mut data, &mut reply)
        }
    }
Unixcoder Score: 0.07552743703126907
--------------------------------------------------
C_Code: 
int32_t InvokerListenThreadStub(uint32_t code, IpcIo *data, IpcIo *reply, MessageOption option, OnRemoteRequest func)
{
    (void)code;
    (void)data;
    (void)reply;
    (void)option;
    (void)func;
    return ERR_NONE;
}
Function: 
fn on_remote_request(&self, code: u32, data: &mut MsgParcel, reply: &mut MsgParcel) -> i32 {
            0
        }
Unixcoder Score: 0.07345409691333771
--------------------------------------------------
C_Code: 
void SystemAbilityManager::NotifySystemAbilityChanged(int32_t systemAbilityId, const std::string& deviceId,
    int32_t code, const sptr<ISystemAbilityStatusChange>& listener)
{
    HILOGD("NotifySystemAbilityChanged, SA:%{public}d", systemAbilityId);
    if (listener == nullptr) {
        HILOGE("%{public}s listener null pointer!", __func__);
        return;
    }

    switch (code) {
        case static_cast<uint32_t>(SamgrInterfaceCode::ADD_SYSTEM_ABILITY_TRANSACTION): {
            listener->OnAddSystemAbility(systemAbilityId, deviceId);
            break;
        }
        case static_cast<uint32_t>(SamgrInterfaceCode::REMOVE_SYSTEM_ABILITY_TRANSACTION): {
            listener->OnRemoveSystemAbility(systemAbilityId, deviceId);
            break;
        }
        default:
            break;
    }
}
Function: 
pub fn subscribe_system_ability(
        said: i32,
        on_add: fn(i32, &str),
        on_remove: fn(i32, &str),
    ) -> UnsubscribeHandler {
        info!("subscribe system ability {}", said);
        UnsubscribeHandler::new(Unsubscribe::Ability(SubscribeSystemAbility(
            said, on_add, on_remove,
        )))
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__SubscribeSystemAbility__idx4890_rank1.c", "source_rust_file": "Partial__SubscribeSystemAbility__idx4890_rank1.rs", "c_api": "SubscribeSystemAbility(systemAbilityId, listener)", "rust_api": "SubscribeSystemAbility(said, on_add, on_remove)", "mapping_type": "function", "description": "Subscribe to system ability with ID and callback functions", "reasoning": "[Task Analysis] C function creates a system ability subscription handler with callbacks, Rust function does the same with a different API structure. [Similarity] Names don't match exactly but both perform system ability subscription logic. [Knowledge Extraction] Found partial structural match in the core subscription logic and API mappings for system ability handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__SubscribeSystemAbility__idx4890_rank1.c", "source_rust_file": "Partial__SubscribeSystemAbility__idx4890_rank1.rs", "c_api": "SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager()", "rust_api": "UnsubscribeHandler::new(Unsubscribe::Ability(SubscribeSystemAbility(...)))", "mapping_type": "function", "description": "System ability manager access and handler creation", "reasoning": "[Task Analysis] C function creates a system ability subscription handler with callbacks, Rust function does the same with a different API structure. [Similarity] Names don't match exactly but both perform system ability subscription logic. [Knowledge Extraction] Found partial structural match in the core subscription logic and API mappings for system ability handling."}, {"knowledge_type": "Partial", "source_c_file": "Partial__SubscribeSystemAbility__idx4890_rank1.c", "source_rust_file": "Partial__SubscribeSystemAbility__idx4890_rank1.rs", "c_fragment": "auto sysm = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();\n    if (sysm == nullptr) {\n        return nullptr;\n    }\n\n    sptr<ISystemAbilityStatusChange> listener = new SystemAbilityStatusChangeWrapper(onAdd, onRemove);\n    sysm->SubscribeSystemAbility(systemAbilityId, listener);\n    return std::make_unique<UnSubscribeSystemAbilityHandler>(systemAbilityId, listener);", "rust_fragment": "debug!(\"subscribe system ability {}\", said);\n        UnsubscribeHandler::new(Unsubscribe::Ability(SubscribeSystemAbility(\n            said, on_add, on_remove,\n        )))", "description": "Both functions handle system ability subscription with callback registration and return a handler object.", "reasoning": "[Task Analysis] C function creates a system ability subscription handler with callbacks, Rust function does the same with a different API structure. [Similarity] Names don't match exactly but both perform system ability subscription logic. [Knowledge Extraction] Found partial structural match in the core subscription logic and API mappings for system ability handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__SubscribeSystemAbility__idx4890_rank1.c", "source_rust_file": "Partial__SubscribeSystemAbility__idx4890_rank1.rs", "c_api": "std::make_unique<UnSubscribeSystemAbilityHandler>(systemAbilityId, listener)", "rust_api": "UnsubscribeHandler::new(Unsubscribe::Ability(...))", "mapping_type": "function", "description": "Creation of unsubscribe handler for system ability", "reasoning": "[Task Analysis] C function creates a system ability subscription handler with callbacks, Rust function does the same with a different API structure. [Similarity] Names don't match exactly but both perform system ability subscription logic. [Knowledge Extraction] Found partial structural match in the core subscription logic and API mappings for system ability handling."}]
Unixcoder Score: -0.015361391007900238
--------------------------------------------------
C_Code: 
bool DownloadServiceStub::OnEventOff(MessageParcel &data, MessageParcel &reply)
{
    if (!CheckPermission()) {
        DOWNLOAD_HILOGE("de-register listener, pid:%{public}d", IPCSkeleton::GetCallingPid());
        return false;
    }
    DOWNLOAD_HILOGD("DownloadServiceStub::OnEventOff in");
    uint32_t taskId = data.ReadUint32();
    std::string type = data.ReadString();
    DOWNLOAD_HILOGD("DownloadServiceStub::OnEventOff taskId = %{public}d type=%{public}s ", taskId, type.c_str());
    bool result = Off(taskId, type);
    if (!reply.WriteBool(result)) {
        return false;
    }
    DOWNLOAD_HILOGD("DownloadServiceStub::OnEventOff out");
    return true;
}
Function: 
fn off(&self, data: &BorrowedMsgParcel, reply: &mut BorrowedMsgParcel) -> IpcResult<()> {
        self.0.off(data, reply)
    }
Unixcoder Score: -0.02287028729915619
--------------------------------------------------
C_Code: 
void UnloadingStateHandler::OnEnter(const std::shared_ptr<SystemAbilityContext>& context)
{
    auto listener = listener_.lock();
    if (listener == nullptr) {
        HILOGE("Scheduler:listener is null");
        return;
    }
    listener->OnAbilityUnloadingLocked(context->systemAbilityId);
}
Function: 
pub fn unload_system_ability(said: i32) -> i32 {
        info!("unload system ability {}", said);
        UnloadSystemAbility(said)
    }
Unixcoder Score: -0.026616351678967476
--------------------------------------------------
C_Code: 
int32_t RdbServiceStub::OnUnlockCloudContainer(MessageParcel &data, MessageParcel &reply)
{
    RdbSyncerParam param;
    if (!ITypesUtil::Unmarshal(data, param)) {
        ZLOGE("Unmarshal failed");
        return IPC_STUB_INVALID_DATA_ERR;
    }

    auto status = UnlockCloudContainer(param);
    if (!ITypesUtil::Marshal(reply, status)) {
        ZLOGE("Marshal status:0x%{public}x", status);
        return IPC_STUB_WRITE_PARCEL_ERR;
    }
    return RDB_OK;
}
Function: 
pub(crate) fn unlock(&mut self, session_id: i32) -> DatabaseStubResult<()> {
        let mut msg_parcel = MsgParcel::new();
        msg_parcel
            .write(&session_id)
            .map_err(|_| Error::WriteMsgParcelFailed)?;

        let function_number = Unlock as u32;
        let remote_obj = self
            .remote_obj
            .as_ref()
            .ok_or(Error::CreateMsgParcelFailed)?;
        let mut receive = remote_obj
            .send_request(function_number, &mut msg_parcel)
            .map_err(|_| Error::SendRequestFailed)?;

        let error = receive
            .read::<Error>()
            .map_err(|_| Error::ReadMsgParcelFailed)?;
        if !error.eq(&Error::Success) {
            return Err(error);
        }
        Ok(())
    }
Unixcoder Score: -0.03113102726638317
--------------------------------------------------
C_Code: 
void Request::OnFaultsReceive(const std::shared_ptr<int32_t> &tid, const std::shared_ptr<SubscribeType> &type,
    const std::shared_ptr<Reason> &reason)
{
    std::lock_guard<std::mutex> lock(listenerMutex_);
    auto listener = notifyDataListenerMap_.find(*type);
    if (listener != notifyDataListenerMap_.end()) {
        listener->second->OnFaultsReceive(tid, type, reason);
    }
}
Function: 
pub(crate) fn faults(tid: u32, client_manager: &ClientManagerEntry, reason: Reason) {
        client_manager.send_faults(tid, SubscribeType::FaultOccur, reason)
    }
Unixcoder Score: -0.032649971544742584
--------------------------------------------------
C_Code: 
int32_t ISystemAbilityManagerMock::UnSubscribeSystemAbility(int32_t systemAbilityId,
    const sptr<ISystemAbilityStatusChange>& listener)
{
    return 0;
}
Function: 
pub fn remove_system_ability(said: i32) -> i32 {
        info!("remove system ability {}", said);
        RemoveSystemAbility(said)
    }
Unixcoder Score: -0.03265899419784546
--------------------------------------------------
C_Code: 
void DownloadServiceTask::SetStatus(DownloadStatus status, ErrorCode code, PausedReason reason)
{
    auto stateChange = [this](DownloadStatus status, ErrorCode code, PausedReason reason) -> bool {
        std::lock_guard<std::recursive_mutex> autoLock(mutex_);
        bool isChanged = false;
        if (status != this->status_) {
            this->status_ = status;
            isChanged = true;
        }
        if (code != this->code_) {
            this->code_ = code;
            isChanged = true;
        }
        if (this->reason_ != PAUSED_BY_USER) {
            if (!isOnline_ && reason == PAUSED_WAITING_TO_RETRY) {
                reason = PAUSED_WAITING_FOR_NETWORK;
            }
            if (reason != this->reason_) {
                this->reason_ = reason;
                isChanged = true;
            }
        }

        return isChanged;
    };
    DOWNLOAD_HILOGI("Status [%{public}d], Code [%{public}d], Reason [%{public}d]", status, code, reason);
    if (!stateChange(status, code, reason)) {
        return;
    }
    if (eventCb_ != nullptr) {
        std::lock_guard<std::recursive_mutex> autoLock(mutex_);
        switch (status_) {
            case SESSION_SUCCESS:
                eventCb_("complete", taskId_, 0, 0, true);
                break;

            case SESSION_PAUSED:
                eventCb_("pause", taskId_, 0, 0, true);
                break;

            case SESSION_FAILED:
                eventCb_("fail", taskId_, code_, 0, true);
                break;

            default:
                break;
        }
    }
}
Function: 
pub fn set_status(&self, state: State, reason: Reason) -> bool {
        {
            let mut current_status = self.status.lock().unwrap();
            if state == current_status.state && reason == current_status.reason {
                return true;
            }
            let mut progress_guard = self.progress.lock().unwrap();
            let index = progress_guard.common_data.index;
            let current_state = current_status.state;
            match state {
                State::PAUSED | State::STOPPED => {
                    if current_state != State::RUNNING
                        && current_state != State::RETRYING
                        && current_state != State::WAITING
                    {
                        return false;
                    }
                    self.set_code(index, reason);
                }
                State::FAILED | State::COMPLETED => {
                    if current_state != State::RUNNING && current_state != State::RETRYING {
                        return false;
                    }
                    if state == State::FAILED {
                        let file_counts = self.conf.file_specs.len();
                        for i in index..file_counts {
                            self.set_code(i, reason);
                        }
                    }
                }
                State::WAITING => {
                    if current_state != State::RUNNING
                        && current_state != State::RETRYING
                        && current_state != State::INITIALIZED
                    {
                        return false;
                    }
                    self.set_code(index, reason);
                }
                State::REMOVED => self.set_code(index, reason),
                _ => {}
            }
            current_status.mtime = get_current_timestamp();
            progress_guard.common_data.state = state;
            current_status.state = state;
            current_status.reason = reason;
            println!("current state is {:?}, reason is {:?}", state, reason);
        }
        self.state_change_notify(state);
        true
    }
Unixcoder Score: -0.037512220442295074
--------------------------------------------------
