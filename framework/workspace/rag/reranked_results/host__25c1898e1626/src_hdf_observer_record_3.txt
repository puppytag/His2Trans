C_Code: 
void TestOnEventWrapperCb(OnRustCb callback, HiSysEventRecordC record)
{
    // do nothing
}
Function: 
fn test_hisysevent_query_001() {
    // write two events at first.
    let mut ret = hisysevent::write(
        "HIVIEWDFX",
        "PLUGIN_LOAD",
        EventType::Behavior,
        &[hisysevent::build_str_param!("STRING_SINGLE", "test_hisysevent_query_001")]
    );
    assert!(ret == SUCCEED);
    ret = hisysevent::write(
        "HIVIEWDFX",
        "PLUGIN_UNLOAD",
        EventType::Behavior,
        &[hisysevent::build_str_param!("STRING_SINGLE", "test_hisysevent_query_001")]
    );
    assert!(ret == SUCCEED);
    // query event.
    let query_arg = QueryArg {
        begin_time: -1,
        end_time: -1,
        max_events: 2,
    };
    let query_rules = [
        QueryRule {
            domain: "HIVIEWDFX",
            event_list: vec![
                "PLUGIN_LOAD",
                "PLUGIN_UNLOAD",
            ],
            condition: "{\"version\":\"V1\",\"condition\":{\"and\":[{\"param\":\"
                NAME\",\"op\":\"=\",\"value\":\"SysEventService\"}]}}",
        },
        QueryRule {
            domain: "HIVIEWDFX",
            event_list: vec![
                "PLUGIN_LOAD",
            ],
            condition: "",
        }
    ];
    // step1: construct a querier.
    let querier = Querier::new(|records: &[HiSysEventRecord]| {
        for item in records {
            assert!(item.get_domain() == "HIVIEWDFX");
        }
    }, |reason: i32, total: i32| {
        assert!(reason == SUCCEED);
        assert!(total == QUERY_CNT);
    }).expect("Construct a querier by Querier::new");
    // step2: query.
    ret = hisysevent::query(&query_arg, &query_rules, &querier);
    assert!(ret == SUCCEED);
    // step3: recycle allocated memories of this Querier.
    querier.try_to_recycle();
    ret = hisysevent::query(&query_arg, &query_rules, &querier);
    assert!(ret == LISTENER_NOT_EXIST);
}
Unixcoder Score: 0.07475896924734116
--------------------------------------------------
C_Code: 
bool DownloadServiceTask::CheckResumeCondition()
{
    if (!isOnline_) {
        return false;
    }
    return true;
}
Function: 
pub fn check_net_work_status(&self) -> bool {
        if !self.is_satisfied_configuration() {
            if self.conf.common_data.mode == Mode::FRONTEND || !self.conf.common_data.retry {
                self.set_status(State::FAILED, Reason::UnSupportedNetWorkType);
                return false;
            }
            if self.set_status(State::WAITING, Reason::UnSupportedNetWorkType) {
                self.record_waitting_network_time();
            }
            return false;
        }
        true
    }
Unixcoder Score: 0.015106111764907837
--------------------------------------------------
C_Code: 
bool Parcel::WriteUint32(uint32_t value)
    {
        if (GetDBinderServiceStubInterface() == nullptr) {
            return false;
        }
        return GetDBinderServiceStubInterface()->WriteUint32(value);
    }
Function: 
pub fn send_request(&self, code: u32, data: &mut MsgParcel) -> IpcResult<MsgParcel> {
        let mut reply = MsgParcel::new();
        let mut option = MsgOption::new();
        match mem::replace(&mut data.inner, ParcelMem::Null) {
            ParcelMem::Unique(mut p) => {
                let res = self.inner.SendRequest(
                    code,
                    p.pin_mut(),
                    reply.pin_mut().unwrap(),
                    option.inner.pin_mut(),
                );
                data.inner = ParcelMem::Unique(p);
                match res {
                    0 => Ok(reply),
                    29189 => Err(IpcStatusCode::ServiceDied),
                    _ => Err(IpcStatusCode::Failed),
                }
            }
            _ => Err(IpcStatusCode::Failed),
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__record_stack_limit__idx136303_rank5.h", "source_rust_file": "API_Mapping__record_stack_limit__idx136303_rank5.rs", "c_api": "alloc(Layout::from_size_align(...))", "rust_api": "alloc(Layout::from_size_align(...))", "mapping_type": "function", "description": "Heap memory allocation for stack", "reasoning": "[FFI Check] -> The Rust code contains FFI calls to libc functions like `sigaltstack`, `sigaction`, `sigemptyset`, and `alloc`, which are typical of system-level operations. [Task Analysis] -> The C code appears to be setting up a stack limit for a task, while the Rust code sets up a signal handler with an alternate stack. [Similarity] -> While both involve stack management, the domains are different: C focuses on stack limit recording, Rust on signal handling setup. [Knowledge Extraction] -> The FFI wrapper nature of the Rust code blocks Full/Partial classification, but API mappings can still be extracted for the system-level operations involved."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__record_stack_limit__idx136303_rank5.h", "source_rust_file": "API_Mapping__record_stack_limit__idx136303_rank5.rs", "c_api": "libc::sigaction", "rust_api": "libc::sigaction", "mapping_type": "function", "description": "Registering signal handler", "reasoning": "[FFI Check] -> The Rust code contains FFI calls to libc functions like `sigaltstack`, `sigaction`, `sigemptyset`, and `alloc`, which are typical of system-level operations. [Task Analysis] -> The C code appears to be setting up a stack limit for a task, while the Rust code sets up a signal handler with an alternate stack. [Similarity] -> While both involve stack management, the domains are different: C focuses on stack limit recording, Rust on signal handling setup. [Knowledge Extraction] -> The FFI wrapper nature of the Rust code blocks Full/Partial classification, but API mappings can still be extracted for the system-level operations involved."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__record_stack_limit__idx136303_rank5.h", "source_rust_file": "API_Mapping__record_stack_limit__idx136303_rank5.rs", "c_api": "libc::sigemptyset", "rust_api": "libc::sigemptyset", "mapping_type": "function", "description": "Initializing signal mask", "reasoning": "[FFI Check] -> The Rust code contains FFI calls to libc functions like `sigaltstack`, `sigaction`, `sigemptyset`, and `alloc`, which are typical of system-level operations. [Task Analysis] -> The C code appears to be setting up a stack limit for a task, while the Rust code sets up a signal handler with an alternate stack. [Similarity] -> While both involve stack management, the domains are different: C focuses on stack limit recording, Rust on signal handling setup. [Knowledge Extraction] -> The FFI wrapper nature of the Rust code blocks Full/Partial classification, but API mappings can still be extracted for the system-level operations involved."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__record_stack_limit__idx136303_rank5.h", "source_rust_file": "API_Mapping__record_stack_limit__idx136303_rank5.rs", "c_api": "record_sp_limit", "rust_api": "libc::sigaltstack", "mapping_type": "function", "description": "Setting up alternate signal stack", "reasoning": "[FFI Check] -> The Rust code contains FFI calls to libc functions like `sigaltstack`, `sigaction`, `sigemptyset`, and `alloc`, which are typical of system-level operations. [Task Analysis] -> The C code appears to be setting up a stack limit for a task, while the Rust code sets up a signal handler with an alternate stack. [Similarity] -> While both involve stack management, the domains are different: C focuses on stack limit recording, Rust on signal handling setup. [Knowledge Extraction] -> The FFI wrapper nature of the Rust code blocks Full/Partial classification, but API mappings can still be extracted for the system-level operations involved."}]
Unixcoder Score: 0.01034027524292469
--------------------------------------------------
C_Code: 
sptr<DownloadServiceAbility> DownloadServiceAbility::GetInstance()
{
    if (instance_ == nullptr) {
        std::lock_guard<std::mutex> autoLock(instanceLock_);
        if (instance_ == nullptr) {
            instance_ = new DownloadServiceAbility(DOWNLOAD_SERVICE_ID, true);
        }
    }
    return instance_;
}
Function: 
pub fn get_ability_instance() -> &'static mut RequestAbility {
        static mut REQUESTABILITY: Option<RequestAbility> = None;
        static ONCE: Once = Once::new();
        unsafe {
            ONCE.call_once(|| {
                REQUESTABILITY = Some(RequestAbility::new(
                    ServerRunState::NoStart,
                    Mutex::new(HashMap::new()),
                ));
            });
            REQUESTABILITY.as_mut().unwrap()
        }
    }
Unixcoder Score: 0.00545748183503747
--------------------------------------------------
C_Code: 
bool DownloadServiceTask::CheckResumeCondition()
{
    if (!isOnline_) {
        return false;
    }
    return true;
}
Function: 
fn handle_download_error(&self, result: &Result<(), HttpClientError>) -> bool {
        match result {
            Ok(_) => return true,
            Err(err) => {
                if !self.net_work_online() {
                    return false;
                }
                match err.error_kind() {
                    ErrorKind::Timeout => {
                        self.set_status(State::FAILED, Reason::ContinuousTaskTimeOut);
                    }
                    ErrorKind::UserAborted => {}
                    _ => {
                        self.set_status(State::FAILED, Reason::OthersError);
                    }
                }
                return false;
            }
        }
    }
Unixcoder Score: 0.003797737415879965
--------------------------------------------------
C_Code: 
void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,
    uv_req_t* req) {
  /* Shortcut for handle->last_input_record.Event.KeyEvent. */
#define KEV handle->last_input_record.Event.KeyEvent

  DWORD records_left, records_read;
  uv_buf_t buf;
  off_t buf_used;

  assert(handle->type == UV_TTY);
  handle->flags &= ~UV_HANDLE_READ_PENDING;

  if (!(handle->flags & UV_HANDLE_READING) ||
      !(handle->flags & UV_HANDLE_TTY_RAW)) {
    goto out;
  }

  if (!REQ_SUCCESS(req)) {
    /* An error occurred while waiting for the event. */
    if ((handle->flags & UV_HANDLE_READING)) {
      handle->flags &= ~UV_HANDLE_READING;
      uv__set_sys_error(loop, GET_REQ_ERROR(req));
      handle->read_cb((uv_stream_t*)handle, -1, uv_null_buf_);
    }
    goto out;
  }

  /* Fetch the number of events  */
  if (!GetNumberOfConsoleInputEvents(handle->handle, &records_left)) {
    handle->flags &= ~UV_HANDLE_READING;
    uv__set_sys_error(loop, GetLastError());
    handle->read_cb((uv_stream_t*)handle, -1, uv_null_buf_);
    goto out;
  }

  /* Windows sends a lot of events that we're not interested in, so buf */
  /* will be allocated on demand, when there's actually something to emit. */
  buf = uv_null_buf_;
  buf_used = 0;

  while ((records_left > 0 || handle->last_key_len > 0) &&
         (handle->flags & UV_HANDLE_READING)) {
    if (handle->last_key_len == 0) {
      /* Read the next input record */
      if (!ReadConsoleInputW(handle->handle,
                             &handle->last_input_record,
                             1,
                             &records_read)) {
        uv__set_sys_error(loop, GetLastError());
        handle->flags &= ~UV_HANDLE_READING;
        handle->read_cb((uv_stream_t*) handle, -1, buf);
        goto out;
      }
      records_left--;

      /* Ignore events that are not keyboard events */
      if (handle->last_input_record.EventType != KEY_EVENT) {
        continue;
      }

      /* Ignore keyup events, unless the left alt key was held and a valid */
      /* unicode character was emitted. */
      if (!KEV.bKeyDown && !(((KEV.dwControlKeyState & LEFT_ALT_PRESSED) ||
          KEV.wVirtualKeyCode==VK_MENU) && KEV.uChar.UnicodeChar != 0)) {
        continue;
      }

      /* Ignore keypresses to numpad number keys if the left alt is held */
      /* because the user is composing a character, or windows simulating */
      /* this. */
      if ((KEV.dwControlKeyState & LEFT_ALT_PRESSED) &&
          !(KEV.dwControlKeyState & ENHANCED_KEY) &&
          (KEV.wVirtualKeyCode == VK_INSERT ||
          KEV.wVirtualKeyCode == VK_END ||
          KEV.wVirtualKeyCode == VK_DOWN ||
          KEV.wVirtualKeyCode == VK_NEXT ||
          KEV.wVirtualKeyCode == VK_LEFT ||
          KEV.wVirtualKeyCode == VK_CLEAR ||
          KEV.wVirtualKeyCode == VK_RIGHT ||
          KEV.wVirtualKeyCode == VK_HOME ||
          KEV.wVirtualKeyCode == VK_UP ||
          KEV.wVirtualKeyCode == VK_PRIOR ||
          KEV.wVirtualKeyCode == VK_NUMPAD0 ||
          KEV.wVirtualKeyCode == VK_NUMPAD1 ||
          KEV.wVirtualKeyCode == VK_NUMPAD2 ||
          KEV.wVirtualKeyCode == VK_NUMPAD3 ||
          KEV.wVirtualKeyCode == VK_NUMPAD4 ||
          KEV.wVirtualKeyCode == VK_NUMPAD5 ||
          KEV.wVirtualKeyCode == VK_NUMPAD6 ||
          KEV.wVirtualKeyCode == VK_NUMPAD7 ||
          KEV.wVirtualKeyCode == VK_NUMPAD8 ||
          KEV.wVirtualKeyCode == VK_NUMPAD9)) {
        continue;
      }

      if (KEV.uChar.UnicodeChar != 0) {
        int prefix_len, char_len;

        /* Character key pressed */
        if (KEV.uChar.UnicodeChar >= 0xD800 &&
            KEV.uChar.UnicodeChar < 0xDC00) {
          /* UTF-16 high surrogate */
          handle->last_utf16_high_surrogate = KEV.uChar.UnicodeChar;
          continue;
        }

        /* Prefix with \u033 if alt was held, but alt was not used as part */
        /* a compose sequence. */
        if ((KEV.dwControlKeyState & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))
            && !(KEV.dwControlKeyState & (LEFT_CTRL_PRESSED |
            RIGHT_CTRL_PRESSED)) && KEV.bKeyDown) {
          handle->last_key[0] = '\033';
          prefix_len = 1;
        } else {
          prefix_len = 0;
        }

        if (KEV.uChar.UnicodeChar >= 0xDC00 &&
            KEV.uChar.UnicodeChar < 0xE000) {
          /* UTF-16 surrogate pair */
          WCHAR utf16_buffer[2] = { handle->last_utf16_high_surrogate,
                                    KEV.uChar.UnicodeChar};
          char_len = WideCharToMultiByte(CP_UTF8,
                                         0,
                                         utf16_buffer,
                                         2,
                                         &handle->last_key[prefix_len],
                                         sizeof handle->last_key,
                                         NULL,
                                         NULL);
        } else {
          /* Single UTF-16 character */
          char_len = WideCharToMultiByte(CP_UTF8,
                                         0,
                                         &KEV.uChar.UnicodeChar,
                                         1,
                                         &handle->last_key[prefix_len],
                                         sizeof handle->last_key,
                                         NULL,
                                         NULL);
        }

        /* Whatever happened, the last character wasn't a high surrogate. */
        handle->last_utf16_high_surrogate = 0;

        /* If the utf16 character(s) couldn't be converted something must */
        /* be wrong. */
        if (!char_len) {
          uv__set_sys_error(loop, GetLastError());
          handle->flags &= ~UV_HANDLE_READING;
          handle->read_cb((uv_stream_t*) handle, -1, buf);
          goto out;
        }

        handle->last_key_len = (unsigned char) (prefix_len + char_len);
        handle->last_key_offset = 0;
        continue;

      } else {
        /* Function key pressed */
        const char* vt100;
        size_t prefix_len, vt100_len;

        vt100 = get_vt100_fn_key(KEV.wVirtualKeyCode,
                                  !!(KEV.dwControlKeyState & SHIFT_PRESSED),
                                  !!(KEV.dwControlKeyState & (
                                    LEFT_CTRL_PRESSED |
                                    RIGHT_CTRL_PRESSED)),
                                  &vt100_len);

        /* If we were unable to map to a vt100 sequence, just ignore. */
        if (!vt100) {
          continue;
        }

        /* Prefix with \x033 when the alt key was held. */
        if (KEV.dwControlKeyState & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)) {
          handle->last_key[0] = '\033';
          prefix_len = 1;
        } else {
          prefix_len = 0;
        }

        /* Copy the vt100 sequence to the handle buffer. */
        assert(prefix_len + vt100_len < sizeof handle->last_key);
        memcpy(&handle->last_key[prefix_len], vt100, vt100_len);

        handle->last_key_len = (unsigned char) (prefix_len + vt100_len);
        handle->last_key_offset = 0;
        continue;
      }
    } else {
      /* Copy any bytes left from the last keypress to the user buffer. */
      if (handle->last_key_offset < handle->last_key_len) {
        /* Allocate a buffer if needed */
        if (buf_used == 0) {
          buf = handle->alloc_cb((uv_handle_t*) handle, 1024);
        }

        buf.base[buf_used++] = handle->last_key[handle->last_key_offset++];

        /* If the buffer is full, emit it */
        if (buf_used == buf.len) {
          handle->read_cb((uv_stream_t*) handle, buf_used, buf);
          buf = uv_null_buf_;
          buf_used = 0;
        }

        continue;
      }

      /* Apply dwRepeat from the last input record. */
      if (--KEV.wRepeatCount > 0) {
        handle->last_key_offset = 0;
        continue;
      }

      handle->last_key_len = 0;
      continue;
    }
  }

  /* Send the buffer back to the user */
  if (buf_used > 0) {
    handle->read_cb((uv_stream_t*) handle, buf_used, buf);
  }

 out:
  /* Wait for more input events. */
  if ((handle->flags & UV_HANDLE_READING) &&
      !(handle->flags & UV_HANDLE_READ_PENDING)) {
    uv_tty_queue_read(loop, handle);
  }

  DECREASE_PENDING_REQ_COUNT(handle);

#undef KEV
}
Function: 
fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        let handle = get_handle(c::STD_INPUT_HANDLE)?;
        if !is_console(handle) {
            unsafe {
                let handle = Handle::from_raw_handle(handle);
                let ret = handle.read(buf);
                handle.into_raw_handle(); // Don't close the handle
                return ret;
            }
        }

        // If there are bytes in the incomplete utf-8, start with those.
        // (No-op if there is nothing in the buffer.)
        let mut bytes_copied = self.incomplete_utf8.read(buf);

        if bytes_copied == buf.len() {
            return Ok(bytes_copied);
        } else if buf.len() - bytes_copied < 4 {
            // Not enough space to get a UTF-8 byte. We will use the incomplete UTF8.
            let mut utf16_buf = [MaybeUninit::new(0); 1];
            // Read one u16 character.
            let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, 1, &mut self.surrogate)?;
            // Read bytes, using the (now-empty) self.incomplete_utf8 as extra space.
            let read_bytes = utf16_to_utf8(
                unsafe { MaybeUninit::slice_assume_init_ref(&utf16_buf[..read]) },
                &mut self.incomplete_utf8.bytes,
            )?;

            // Read in the bytes from incomplete_utf8 until the buffer is full.
            self.incomplete_utf8.len = read_bytes as u8;
            // No-op if no bytes.
            bytes_copied += self.incomplete_utf8.read(&mut buf[bytes_copied..]);
            Ok(bytes_copied)
        } else {
            let mut utf16_buf = [MaybeUninit::<u16>::uninit(); MAX_BUFFER_SIZE / 2];

            // In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16. So
            // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets
            // lost.
            let amount = cmp::min(buf.len() / 3, utf16_buf.len());
            let read =
                read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;
            // Safety `read_u16s_fixup_surrogates` returns the number of items
            // initialized.
            let utf16s = unsafe { MaybeUninit::slice_assume_init_ref(&utf16_buf[..read]) };
            match utf16_to_utf8(utf16s, buf) {
                Ok(value) => return Ok(bytes_copied + value),
                Err(e) => return Err(e),
            }
        }
    }
Unixcoder Score: -0.014646440744400024
--------------------------------------------------
C_Code: 
bool DownloadServiceProxy::CheckPermission()
{
    DOWNLOAD_HILOGD("DownloadServiceProxy::CheckPermission in");
    MessageParcel data, reply;
    MessageOption option;
    if (!data.WriteInterfaceToken(GetDescriptor())) {
        DOWNLOAD_HILOGE(" Failed to write parcelable ");
        return false;
    }

    int32_t result = Remote()->SendRequest(CMD_CHECKPERMISSION, data, reply, option);
    if (result != ERR_NONE) {
        DOWNLOAD_HILOGE(" DownloadServiceProxy::CheckPermission fail, ret = %{public}d ", result);
        return false;
    }
    bool ret = reply.ReadBool();
    DOWNLOAD_HILOGD("DownloadServiceProxy::CheckPermission out [ret: %{public}d]", ret);
    return ret;
}
Function: 
fn on_remote_request(
    stub: &dyn RequestServiceInterface,
    code: u32,
    data: &BorrowedMsgParcel,
    reply: &mut BorrowedMsgParcel,
) -> IpcResult<()> {
    info!(LOG_LABEL, "on_remote_request code {}", @public(code));
    let service_token: InterfaceToken =
        InterfaceToken::new("OHOS.Download.RequestServiceInterface");
    let token: InterfaceToken = match data.read::<InterfaceToken>() {
        Ok(i) => i,
        _ => InterfaceToken::new("token error"),
    };
    if service_token.get_token() != token.get_token() {
        error!(LOG_LABEL, "token error");
        return Err(IpcStatusCode::Failed);
    }
    match code.try_into()? {
        RequestCode::Construct => stub.construct(data, reply),
        RequestCode::Pause => stub.pause(data, reply),
        RequestCode::Query => stub.show(data, reply),
        RequestCode::QueryMimeType => stub.query_mime_type(data, reply),
        RequestCode::Remove => stub.remove(data, reply),
        RequestCode::Resume => stub.resume(data, reply),
        RequestCode::On => stub.on(data, reply),
        RequestCode::Off => stub.off(data, reply),
        RequestCode::Start => stub.start(data, reply),
        RequestCode::Stop => stub.stop(data, reply),
        RequestCode::Show => stub.show(data, reply),
        RequestCode::Touch => stub.touch(data, reply),
        RequestCode::Search => stub.search(data, reply),
        RequestCode::Clear => stub.clear(data, reply),
    }
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__uv_process_tty_read_raw_req__idx127450_rank3.c", "source_rust_file": "API_Mapping__uv_process_tty_read_raw_req__idx127450_rank3.rs", "c_api": "WideCharToMultiByte", "rust_api": "c::WideCharToMultiByte", "mapping_type": "function", "description": "UTF-16 to UTF-8 character encoding conversion", "reasoning": "[FFI Check] -> [Task Analysis] -> [Similarity] -> [Knowledge Extraction] -> [Filter 1: Entity Name Check] -> [Filter 2: Empty/Trivial Code] -> [Filter 3: FFI Wrapper] -> [Filter 4: Semantic Domain Mismatch] -> [Filter 5: Empty Structs] -> [Filter 6: Definition vs Usage Asymmetry] -> [Full/Partial/API Analysis] -> [Structural Fragments] -> [API Mappings]"}]
Unixcoder Score: -0.0174955353140831
--------------------------------------------------
C_Code: 
bool DBinderService::CheckInvokeListenThreadIllegal(IPCObjectProxy *proxy, MessageParcel &data, MessageParcel &reply)
{
    int err = proxy->InvokeListenThread(data, reply);
    if (err != ERR_NONE) {
        DBINDER_LOGE(LOG_LABEL, "start service listen error:%{public}d handle:%{public}d", err, proxy->GetHandle());
        return true;
    }
    return false;
}
Function: 
pub fn send_request(&self, code: u32, data: &mut MsgParcel) -> IpcResult<MsgParcel> {
        let mut reply = MsgParcel::new();
        let mut option = MsgOption::new();
        match mem::replace(&mut data.inner, ParcelMem::Null) {
            ParcelMem::Unique(mut p) => {
                let res = self.inner.SendRequest(
                    code,
                    p.pin_mut(),
                    reply.pin_mut().unwrap(),
                    option.inner.pin_mut(),
                );
                data.inner = ParcelMem::Unique(p);
                match res {
                    0 => Ok(reply),
                    29189 => Err(IpcStatusCode::ServiceDied),
                    _ => Err(IpcStatusCode::Failed),
                }
            }
            _ => Err(IpcStatusCode::Failed),
        }
    }
Unixcoder Score: -0.02876988984644413
--------------------------------------------------
C_Code: 
bool DownloadServiceAbility::Off(uint32_t taskId, const std::string &type)
{
    std::string combineType = type + "-" + std::to_string(taskId);
    DOWNLOAD_HILOGI("DownloadServiceAbility::Off started.");
    std::lock_guard<std::mutex> lck(listenerMapMutex_);
    auto iter = registeredListeners_.find(combineType);
    if (iter != registeredListeners_.end()) {
        DOWNLOAD_HILOGE("DownloadServiceAbility::Off delete type=%{public}s object message.", combineType.c_str());
        registeredListeners_.erase(iter);
        return true;
    }
    return false;
}
Function: 
pub fn off(&self, task_id: u32, off_type: String) -> ErrorCode {
        debug!(LOG_LABEL, "off");
        let key = off_type + &String::from("-") + &task_id.to_string();
        debug!(LOG_LABEL, "off key {}",  @public(key));
        let reg_obj = self.reg_remote_obj.lock().unwrap().clone();
        if !reg_obj.contains_key(&key) {
            error!(LOG_LABEL, "off {} nonexistence",  @public(key));
            return ErrorCode::Other;
        }
        self.reg_remote_obj.lock().unwrap().remove(&key);
        debug!(LOG_LABEL, "off end {}",  @public(&key));
        ErrorCode::ErrOk
    }
Unixcoder Score: -0.031947437673807144
--------------------------------------------------
C_Code: 
inline void
rust_task::record_stack_limit() {
    assert(stk);
    assert((uintptr_t)stk->end - RED_ZONE_SIZE
      - (uintptr_t)stk->data >= LIMIT_OFFSET
           && "Stack size must be greater than LIMIT_OFFSET");
    record_sp_limit(stk->data + LIMIT_OFFSET + RED_ZONE_SIZE);
}
Function: 
unsafe fn get_stack_start() -> Option<*mut libc::c_void> {
        let mut ret = None;
        let mut attr: libc::pthread_attr_t = crate::mem::zeroed();
        #[cfg(target_os = "freebsd")]
        assert_eq!(libc::pthread_attr_init(&mut attr), 0);
        #[cfg(target_os = "freebsd")]
        let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);
        #[cfg(not(target_os = "freebsd"))]
        let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);
        if e == 0 {
            let mut stackaddr = crate::ptr::null_mut();
            let mut stacksize = 0;
            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize), 0);
            ret = Some(stackaddr);
        }
        if e == 0 || cfg!(target_os = "freebsd") {
            assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);
        }
        ret
    }
Unixcoder Score: -0.0322437509894371
--------------------------------------------------
