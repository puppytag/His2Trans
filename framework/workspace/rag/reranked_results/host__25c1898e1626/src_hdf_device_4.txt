C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn insert_before_n(+data: T, neighbour: dlist_node<T>) -> dlist_node<T> {
        let mut nobe = self.new_link(data);
        self.insert_left(nobe, neighbour);
        option::get(nobe)
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_fragment": "new_node->next = old_node;\n  new_node->prev = old_node->prev;\n  old_node->prev->next = new_node;\n  old_node->prev = new_node;", "rust_fragment": "self.insert_right(neighbour, self.new_link(data));", "description": "Both code blocks perform insertion of a new node into a doubly-linked list structure.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_api": "new_node->prev = old_node->prev;", "rust_api": "self.insert_right(neighbour, self.new_link(data));", "mapping_type": "function", "description": "Setting the previous pointer of the new node to the previous node of the old node", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_api": "old_node->prev->next = new_node;", "rust_api": "self.insert_right(neighbour, self.new_link(data));", "mapping_type": "function", "description": "Updating the next pointer of the previous node to point to the new node", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_api": "old_node->prev = new_node;", "rust_api": "self.insert_right(neighbour, self.new_link(data));", "mapping_type": "function", "description": "Updating the previous pointer of the old node to point to the new node", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_api": "new_node->next = old_node;", "rust_api": "self.insert_right(neighbour, self.new_link(data));", "mapping_type": "function", "description": "Inserting a new node after a specified node in a doubly-linked list", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}]
Unixcoder Score: 0.04162955656647682
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn insert_left(nobe: dlist_link<T>, neighbour: dlist_node<T>) {
        self.assert_mine(neighbour);
        assert self.size > 0;
        self.link(neighbour.prev, nobe);
        self.link(nobe, some(neighbour));
        self.size += 1;
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx134515_rank4.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx134515_rank4.rs", "c_api": "old_node->prev->next = new_node", "rust_api": "self.link(self.tl, nobe)", "mapping_type": "method", "description": "Updating previous node's next pointer in list", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node, while Rust function adds a node to a tail of a list with size tracking. [Similarity] Names don't match but both involve list/node manipulation. [Knowledge Extraction] Filter 1 fails (names refer to different concepts), Filter 2 passes (both have logic), Filter 3 passes (no FFI), Filter 4 fails (memory management vs list abstraction), Filter 5 passes (both have fields), Filter 6 passes (both are definitions). Since domains are mismatched, Full is blocked. Partial is also blocked due to domain mismatch. API mappings are possible if we find equivalent operations in the logic. However, the core logic of list manipulation is not semantically equivalent between C and Rust (C does pointer manipulation, Rust abstracts with link management). Therefore, no full/partial match, but we can extract API mappings based on similar operations in context."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx134515_rank4.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx134515_rank4.rs", "c_api": "new_node->next = old_node", "rust_api": "self.link(self.tl, nobe)", "mapping_type": "method", "description": "Inserting a node into a list structure", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node, while Rust function adds a node to a tail of a list with size tracking. [Similarity] Names don't match but both involve list/node manipulation. [Knowledge Extraction] Filter 1 fails (names refer to different concepts), Filter 2 passes (both have logic), Filter 3 passes (no FFI), Filter 4 fails (memory management vs list abstraction), Filter 5 passes (both have fields), Filter 6 passes (both are definitions). Since domains are mismatched, Full is blocked. Partial is also blocked due to domain mismatch. API mappings are possible if we find equivalent operations in the logic. However, the core logic of list manipulation is not semantically equivalent between C and Rust (C does pointer manipulation, Rust abstracts with link management). Therefore, no full/partial match, but we can extract API mappings based on similar operations in context."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx134515_rank4.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx134515_rank4.rs", "c_api": "old_node->prev = new_node", "rust_api": "self.tl = nobe", "mapping_type": "method", "description": "Updating tail pointer to new node", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node, while Rust function adds a node to a tail of a list with size tracking. [Similarity] Names don't match but both involve list/node manipulation. [Knowledge Extraction] Filter 1 fails (names refer to different concepts), Filter 2 passes (both have logic), Filter 3 passes (no FFI), Filter 4 fails (memory management vs list abstraction), Filter 5 passes (both have fields), Filter 6 passes (both are definitions). Since domains are mismatched, Full is blocked. Partial is also blocked due to domain mismatch. API mappings are possible if we find equivalent operations in the logic. However, the core logic of list manipulation is not semantically equivalent between C and Rust (C does pointer manipulation, Rust abstracts with link management). Therefore, no full/partial match, but we can extract API mappings based on similar operations in context."}]
Unixcoder Score: 0.020240699872374535
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn make_mine(nobe: dlist_node<T>) {
        if option::is_some(nobe.root) {
            fail "Cannot insert node that's already on a dlist!"
        }
        nobe.root = some(self);
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank2.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank2.rs", "c_api": "new_node->next = old_node;", "rust_api": "self.insert_right(neighbour, self.new_link(data));", "mapping_type": "pattern", "description": "Inserting a node after a specified neighbor in a doubly-linked list.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Structural fragments match in the concept of inserting nodes in a list, but full structural similarity is blocked due to domain mismatch (low-level pointer manipulation vs high-level abstraction). API mappings are extracted for the core insertion operation."}, {"knowledge_type": "Partial", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank2.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank2.rs", "c_fragment": "new_node->next = old_node;\n  new_node->prev = old_node->prev;\n  old_node->prev->next = new_node;\n  old_node->prev = new_node;", "rust_fragment": "self.insert_right(neighbour, self.new_link(data));", "description": "Inserting a new node into a doubly-linked list structure.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Structural fragments match in the concept of inserting nodes in a list, but full structural similarity is blocked due to domain mismatch (low-level pointer manipulation vs high-level abstraction). API mappings are extracted for the core insertion operation."}]
Unixcoder Score: 0.01947242021560669
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
pub fn splice_before(&mut self, list: LinkedList<T>) {
        unsafe {
            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {
                Some(parts) => parts,
                _ => return,
            };
            let node_prev = match self.current {
                None => self.list.tail,
                Some(node) => node.as_ref().prev,
            };
            self.list.splice_nodes(node_prev, self.current, splice_head, splice_tail, splice_len);
            self.index += splice_len;
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134561_rank2.c", "source_rust_file": "Partial__ares__insert_in_list__idx134561_rank2.rs", "c_api": "old_node->prev->next = new_node;", "rust_api": "l.insert_before(3, one);", "mapping_type": "function", "description": "Update the next pointer of the previous node to point to the new node.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node before another node; Rust function tests a doubly-linked list implementation by inserting a value before a given node and asserting consistency. [Similarity] Names do not match ('ares__insert_in_list' vs 'test_dlist_insert_before_head'), but both involve list insertion logic. [Knowledge Extraction] The domain is consistent (doubly-linked list manipulation), and there's a partial structural match in the insertion logic, but not full structural similarity due to different scopes and purposes (implementation vs test). API mappings are present for the core list insertion operation."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134561_rank2.c", "source_rust_file": "Partial__ares__insert_in_list__idx134561_rank2.rs", "c_api": "old_node->prev = new_node;", "rust_api": "l.insert_before(3, one);", "mapping_type": "function", "description": "Update the previous pointer of the target node to point to the new node.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node before another node; Rust function tests a doubly-linked list implementation by inserting a value before a given node and asserting consistency. [Similarity] Names do not match ('ares__insert_in_list' vs 'test_dlist_insert_before_head'), but both involve list insertion logic. [Knowledge Extraction] The domain is consistent (doubly-linked list manipulation), and there's a partial structural match in the insertion logic, but not full structural similarity due to different scopes and purposes (implementation vs test). API mappings are present for the core list insertion operation."}, {"knowledge_type": "Partial", "source_c_file": "Partial__ares__insert_in_list__idx134561_rank2.c", "source_rust_file": "Partial__ares__insert_in_list__idx134561_rank2.rs", "c_fragment": "new_node->next = old_node;\n  new_node->prev = old_node->prev;\n  old_node->prev->next = new_node;\n  old_node->prev = new_node;", "rust_fragment": "l.insert_before(3, one);", "description": "Inserting a node before a given node in a doubly-linked list.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node before another node; Rust function tests a doubly-linked list implementation by inserting a value before a given node and asserting consistency. [Similarity] Names do not match ('ares__insert_in_list' vs 'test_dlist_insert_before_head'), but both involve list insertion logic. [Knowledge Extraction] The domain is consistent (doubly-linked list manipulation), and there's a partial structural match in the insertion logic, but not full structural similarity due to different scopes and purposes (implementation vs test). API mappings are present for the core list insertion operation."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134561_rank2.c", "source_rust_file": "Partial__ares__insert_in_list__idx134561_rank2.rs", "c_api": "new_node->prev = old_node->prev;", "rust_api": "l.insert_before(3, one);", "mapping_type": "function", "description": "Set the previous pointer of the new node to the previous node of the target node.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node before another node; Rust function tests a doubly-linked list implementation by inserting a value before a given node and asserting consistency. [Similarity] Names do not match ('ares__insert_in_list' vs 'test_dlist_insert_before_head'), but both involve list insertion logic. [Knowledge Extraction] The domain is consistent (doubly-linked list manipulation), and there's a partial structural match in the insertion logic, but not full structural similarity due to different scopes and purposes (implementation vs test). API mappings are present for the core list insertion operation."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134561_rank2.c", "source_rust_file": "Partial__ares__insert_in_list__idx134561_rank2.rs", "c_api": "new_node->next = old_node;", "rust_api": "l.insert_before(3, one);", "mapping_type": "function", "description": "Insert a node before a specified node in a doubly-linked list.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node before another node; Rust function tests a doubly-linked list implementation by inserting a value before a given node and asserting consistency. [Similarity] Names do not match ('ares__insert_in_list' vs 'test_dlist_insert_before_head'), but both involve list insertion logic. [Knowledge Extraction] The domain is consistent (doubly-linked list manipulation), and there's a partial structural match in the insertion logic, but not full structural similarity due to different scopes and purposes (implementation vs test). API mappings are present for the core list insertion operation."}]
Unixcoder Score: 0.0189207810908556
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn insert_n_before(nobe: dlist_node<T>, neighbour: dlist_node<T>) {
        self.make_mine(nobe);
        self.insert_left(some(nobe), neighbour);
    }
Unixcoder Score: 0.015769105404615402
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn link(+before: dlist_link<T>, +after: dlist_link<T>) {
        alt before {
            some(neighbour) { neighbour.next = after; }
            none            { self.hd        = after; }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134513_rank3.c", "source_rust_file": "Partial__ares__insert_in_list__idx134513_rank3.rs", "c_api": "old_node->prev->next = new_node", "rust_api": "self.link(nobe.prev, nobe.next)", "mapping_type": "function", "description": "Updating forward pointer in a doubly-linked list", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node, while Rust function removes a node from a doubly-linked list. [Similarity] Both involve pointer manipulation and list re-linking, but the operations are inverse (insert vs unlink). [Knowledge Extraction] No full structural match due to semantic mismatch (insert vs remove), but partial structural fragments and API mappings can be extracted based on shared list manipulation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134513_rank3.c", "source_rust_file": "Partial__ares__insert_in_list__idx134513_rank3.rs", "c_api": "new_node->next = old_node", "rust_api": "self.link(nobe.prev, nobe.next)", "mapping_type": "function", "description": "Linking nodes in a doubly-linked list", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node, while Rust function removes a node from a doubly-linked list. [Similarity] Both involve pointer manipulation and list re-linking, but the operations are inverse (insert vs unlink). [Knowledge Extraction] No full structural match due to semantic mismatch (insert vs remove), but partial structural fragments and API mappings can be extracted based on shared list manipulation patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__ares__insert_in_list__idx134513_rank3.c", "source_rust_file": "Partial__ares__insert_in_list__idx134513_rank3.rs", "c_fragment": "new_node->next = old_node;\n  new_node->prev = old_node->prev;\n  old_node->prev->next = new_node;\n  old_node->prev = new_node;", "rust_fragment": "self.link(nobe.prev, nobe.next);\n        nobe.prev = none; // Release extraneous references.\n        nobe.next = none;\n        nobe.root = none;", "description": "Both manipulate linked list nodes by updating next/prev pointers to rewire the list structure.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node, while Rust function removes a node from a doubly-linked list. [Similarity] Both involve pointer manipulation and list re-linking, but the operations are inverse (insert vs unlink). [Knowledge Extraction] No full structural match due to semantic mismatch (insert vs remove), but partial structural fragments and API mappings can be extracted based on shared list manipulation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134513_rank3.c", "source_rust_file": "Partial__ares__insert_in_list__idx134513_rank3.rs", "c_api": "old_node->prev = new_node", "rust_api": "nobe.prev = none", "mapping_type": "function", "description": "Updating backward pointer in a doubly-linked list", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node, while Rust function removes a node from a doubly-linked list. [Similarity] Both involve pointer manipulation and list re-linking, but the operations are inverse (insert vs unlink). [Knowledge Extraction] No full structural match due to semantic mismatch (insert vs remove), but partial structural fragments and API mappings can be extracted based on shared list manipulation patterns."}]
Unixcoder Score: 0.015764635056257248
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
pub fn insert_before(&mut self, item: T) {
        unsafe {
            let spliced_node = Box::leak(Box::new_in(Node::new(item), &self.list.alloc)).into();
            let node_prev = match self.current {
                None => self.list.tail,
                Some(node) => node.as_ref().prev,
            };
            self.list.splice_nodes(node_prev, self.current, spliced_node, spliced_node, 1);
            self.index += 1;
        }
    }
Unixcoder Score: 0.015681050717830658
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn insert_right(neighbour: dlist_node<T>, nobe: dlist_link<T>) {
        self.assert_mine(neighbour);
        assert self.size > 0;
        self.link(nobe, neighbour.next);
        self.link(some(neighbour), nobe);
        self.size += 1;
    }
Unixcoder Score: 0.014833975583314896
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn insert_right(neighbour: dlist_node<T>, nobe: dlist_link<T>) {
        self.assert_mine(neighbour);
        assert self.size > 0;
        self.link(nobe, neighbour.next);
        self.link(some(neighbour), nobe);
        self.size += 1;
    }
Unixcoder Score: 0.013938218355178833
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn insert_n_before(nobe: dlist_node<T>, neighbour: dlist_node<T>) {
        self.make_mine(nobe);
        self.insert_left(some(nobe), neighbour);
    }
Unixcoder Score: 0.013685491867363453
--------------------------------------------------
