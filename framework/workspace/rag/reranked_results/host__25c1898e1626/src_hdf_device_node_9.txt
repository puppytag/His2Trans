C_Code: 
struct FT_DriverRec_
Function: 
struct BitmapMetrics {
        // Outer glyph bearings that affect the computed bounds. We distinguish
        // those here from `inner_bearing_*` to account for CoreText behavior in
        // SBIX placement. Where the sbix originOffsetX/Y are applied only
        // within the bounds. Specified in font units.
        // 0 for CBDT, CBLC.
        bearing_x: f32,
        bearing_y: f32,
        // Scale factors to scale image to 1em.
        ppem_x: f32,
        ppem_y: f32,
        // Account for the fact that Sbix and CBDT/CBLC have a different origin
        // definition.
        placement_origin_bottom_left: bool,
        // Specified as a pixel value, to be scaled by `ppem_*` as an
        // offset applied to placing the image within the bounds rectangle.
        inner_bearing_x: f32,
        inner_bearing_y: f32,
        // Some, but not all, bitmap glyphs have a special bitmap advance
        advance: f32,
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5177_rank1.c", "source_rust_file": "Partial__Marshal__idx5177_rank1.rs", "c_fragment": "SetValue(node[GET_NAME(name)], name);\n    SetValue(node[GET_NAME(alias)], alias);\n    SetValue(node[GET_NAME(tables)], tables);\n    SetValue(node[GET_NAME(version)], version);\n    SetValue(node[GET_NAME(bundleName)], bundleName);\n    SetValue(node[GET_NAME(user)], user);\n    SetValue(node[GET_NAME(deviceId)], deviceId);\n    SetValue(node[GET_NAME(autoSyncType)], autoSyncType);", "rust_fragment": "Database {\n            name: value.name.clone(),\n            alias: value.alias.clone(),\n            tables,\n        }", "description": "Both perform field assignment from source object to destination structure, though C uses SetValue while Rust directly assigns fields.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Database object into a JSON node, while Rust function 'from' converts an ipc_conn::Database into a Database struct. [Similarity] Names don't match but both perform data serialization/transfer logic. [Knowledge Extraction] Found partial structural match in loop and field assignment patterns, and API mappings for field access and collection operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5177_rank1.c", "source_rust_file": "Partial__Marshal__idx5177_rank1.rs", "c_api": "SetValue(...)", "rust_api": "tables.insert(...)", "mapping_type": "function", "description": "Assigning values to a container", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Database object into a JSON node, while Rust function 'from' converts an ipc_conn::Database into a Database struct. [Similarity] Names don't match but both perform data serialization/transfer logic. [Knowledge Extraction] Found partial structural match in loop and field assignment patterns, and API mappings for field access and collection operations."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5177_rank1.c", "source_rust_file": "Partial__Marshal__idx5177_rank1.rs", "c_fragment": "for t in &value.tables.0 {\n            tables.insert(t.table_name.clone(), Table::from(t));\n        }", "rust_fragment": "for t in &value.tables.0 {\n            tables.insert(t.table_name.clone(), Table::from(t));\n        }", "description": "Both iterate over a collection and insert transformed elements into a new container.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Database object into a JSON node, while Rust function 'from' converts an ipc_conn::Database into a Database struct. [Similarity] Names don't match but both perform data serialization/transfer logic. [Knowledge Extraction] Found partial structural match in loop and field assignment patterns, and API mappings for field access and collection operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5177_rank1.c", "source_rust_file": "Partial__Marshal__idx5177_rank1.rs", "c_api": "node[GET_NAME(name)]", "rust_api": "value.name.clone()", "mapping_type": "field_access", "description": "Accessing and copying a field from source object to destination", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Database object into a JSON node, while Rust function 'from' converts an ipc_conn::Database into a Database struct. [Similarity] Names don't match but both perform data serialization/transfer logic. [Knowledge Extraction] Found partial structural match in loop and field assignment patterns, and API mappings for field access and collection operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5177_rank1.c", "source_rust_file": "Partial__Marshal__idx5177_rank1.rs", "c_api": "node[GET_NAME(alias)]", "rust_api": "value.alias.clone()", "mapping_type": "field_access", "description": "Accessing and copying a field from source object to destination", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Database object into a JSON node, while Rust function 'from' converts an ipc_conn::Database into a Database struct. [Similarity] Names don't match but both perform data serialization/transfer logic. [Knowledge Extraction] Found partial structural match in loop and field assignment patterns, and API mappings for field access and collection operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5177_rank1.c", "source_rust_file": "Partial__Marshal__idx5177_rank1.rs", "c_api": "tables", "rust_api": "tables.insert(t.table_name.clone(), Table::from(t))", "mapping_type": "pattern", "description": "Collection insertion operation", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Database object into a JSON node, while Rust function 'from' converts an ipc_conn::Database into a Database struct. [Similarity] Names don't match but both perform data serialization/transfer logic. [Knowledge Extraction] Found partial structural match in loop and field assignment patterns, and API mappings for field access and collection operations."}]
Unixcoder Score: -0.007271153386682272
--------------------------------------------------
C_Code: 
struct TT_DriverRec_
Function: 
struct CBufferContents {
    length: u32,
    info: *mut CGlyphInfo,
    position: *mut CGlyphPosition,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_api": "GetValue(node, GET_NAME(autoSyncType), autoSyncType)", "rust_api": "value.auto_sync_type.clone()", "mapping_type": "function", "description": "Field extraction from source to destination", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_api": "GetValue(node, GET_NAME(user), user)", "rust_api": "value.user.clone()", "mapping_type": "function", "description": "Field extraction from source to destination", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_fragment": "GetValue(node, GET_NAME(name), name);\n    GetValue(node, GET_NAME(alias), alias);\n    GetValue(node, GET_NAME(tables), tables);\n    GetValue(node, GET_NAME(dbName), name);\n    GetValue(node, GET_NAME(autoSyncType), autoSyncType);\n    GetValue(node, GET_NAME(user), user);\n    GetValue(node, GET_NAME(deviceId), deviceId);\n    GetValue(node, GET_NAME(version), version);\n    GetValue(node, GET_NAME(bundleName), bundleName);", "rust_fragment": "Database {\n            name: value.name.clone(),\n            alias: value.alias.clone(),\n            tables,\n        }", "description": "Both extract and assign fields from a source to construct a Database struct, though C uses GetValue calls and Rust directly accesses fields.", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_api": "GetValue(node, GET_NAME(alias), alias)", "rust_api": "value.alias.clone()", "mapping_type": "function", "description": "Field extraction from source to destination", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_api": "GetValue(node, GET_NAME(tables), tables)", "rust_api": "value.tables.0", "mapping_type": "field_access", "description": "Accessing nested data structure for further processing", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_fragment": "GetValue(node, GET_NAME(tables), tables);", "rust_fragment": "for t in &value.tables.0 {\n            tables.insert(t.table_name.clone(), Table::from(t));\n        }", "description": "Both handle the 'tables' field, with C extracting it via GetValue and Rust iterating over a collection to build a HashMap.", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_api": "GetValue(node, GET_NAME(version), version)", "rust_api": "value.version.clone()", "mapping_type": "function", "description": "Field extraction from source to destination", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_api": "GetValue(node, GET_NAME(deviceId), deviceId)", "rust_api": "value.device_id.clone()", "mapping_type": "function", "description": "Field extraction from source to destination", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_api": "GetValue(node, GET_NAME(dbName), name)", "rust_api": "value.name.clone()", "mapping_type": "function", "description": "Field extraction from source to destination", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_api": "GetValue(node, GET_NAME(bundleName), bundleName)", "rust_api": "value.bundle_name.clone()", "mapping_type": "function", "description": "Field extraction from source to destination", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5177_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5177_rank2.rs", "c_api": "GetValue(node, GET_NAME(name), name)", "rust_api": "value.name.clone()", "mapping_type": "function", "description": "Field extraction from source to destination", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls, while Rust code is a from function that builds a Database struct from an ipc_conn::Database value. [Similarity] Names don't match exactly but both perform data extraction and struct construction. [Knowledge Extraction] There are partial structural matches in field assignment and loop-based collection building, and API mappings for field access and data construction patterns."}]
Unixcoder Score: -0.012230562046170235
--------------------------------------------------
C_Code: 
struct DirectDriverLoadingInfoLUNARG
Function: 
struct BufferSizes {
        // Known size buffers
        path_reduced: u32,
        path_reduced2: u32,
        path_reduced_scan: u32,
        path_monoids: u32,
        path_bboxes: u32,
        draw_reduced: u32,
        draw_monoids: u32,
        info: u32,
        clip_inps: u32,
        clip_els: u32,
        clip_bics: u32,
        clip_bboxes: u32,
        draw_bboxes: u32,
        bump_alloc: u32,
        indirect_count: u32,
        bin_headers: u32,
        paths: u32,
        // Bump allocated buffers
        lines: u32,
        bin_data: u32,
        tiles: u32,
        seg_counts: u32,
        segments: u32,
        ptcl: u32,
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__Unmarshal__idx5187_rank4.c", "source_rust_file": "Partial__Unmarshal__idx5187_rank4.rs", "c_fragment": "for fd in &value.fields.0 {\n            fields.push(Field::from(fd));\n        }", "rust_fragment": "GetValue(node, GET_NAME(fields), fields);", "description": "Both iterate over a collection and populate a target field.", "reasoning": "[Task Analysis] C function processes JSON deserialization, Rust function converts IPC struct to Table. [Similarity] Names don't match but both perform data extraction/translation. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for field assignment."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5187_rank4.c", "source_rust_file": "Partial__Unmarshal__idx5187_rank4.rs", "c_api": "GetValue(node, GET_NAME(name), name)", "rust_api": "name: value.table_name.clone()", "mapping_type": "field_access", "description": "Extracts and assigns a string field from JSON to struct field.", "reasoning": "[Task Analysis] C function processes JSON deserialization, Rust function converts IPC struct to Table. [Similarity] Names don't match but both perform data extraction/translation. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for field assignment."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5187_rank4.c", "source_rust_file": "Partial__Unmarshal__idx5187_rank4.rs", "c_api": "GetValue(node, GET_NAME(fields), fields)", "rust_api": "fields.push(Field::from(fd))", "mapping_type": "pattern", "description": "Populates a collection with transformed elements from source.", "reasoning": "[Task Analysis] C function processes JSON deserialization, Rust function converts IPC struct to Table. [Similarity] Names don't match but both perform data extraction/translation. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for field assignment."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5187_rank4.c", "source_rust_file": "Partial__Unmarshal__idx5187_rank4.rs", "c_api": "GetValue(node, GET_NAME(alias), alias)", "rust_api": "alias: value.alias.clone()", "mapping_type": "field_access", "description": "Extracts and assigns a string field from JSON to struct field.", "reasoning": "[Task Analysis] C function processes JSON deserialization, Rust function converts IPC struct to Table. [Similarity] Names don't match but both perform data extraction/translation. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for field assignment."}]
Unixcoder Score: -0.021666886284947395
--------------------------------------------------
C_Code: 
struct FT_DriverRec_
Function: 
struct Reader {
    reader: png::Reader<cxx::UniquePtr<ffi::ReadTrait>>,
    last_interlace_info: Option<png::InterlaceInfo>,
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank5.c", "source_rust_file": "Partial__Marshal__idx5188_rank5.rs", "c_api": "SetValue(node[GET_NAME(tables)], tables)", "rust_api": "fields: ipc_conn::Fields(fields)", "mapping_type": "field_access", "description": "Assignment of field value from source to destination.", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node from member variables. Rust code is a conversion function that builds an `OrderTable` from a `Table` by cloning fields and converting them. [Similarity] Names don't match (`Marshal` vs `try_from`, `name` vs `table_name`), but both perform data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (JSON marshaling vs struct conversion). Partial match in field copying logic. API mappings found for field assignment and cloning operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank5.c", "source_rust_file": "Partial__Marshal__idx5188_rank5.rs", "c_api": "SetValue(node[GET_NAME(bundleName)], bundleName)", "rust_api": "fields.push(ipc_fd)", "mapping_type": "pattern", "description": "Appending elements to a collection.", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node from member variables. Rust code is a conversion function that builds an `OrderTable` from a `Table` by cloning fields and converting them. [Similarity] Names don't match (`Marshal` vs `try_from`, `name` vs `table_name`), but both perform data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (JSON marshaling vs struct conversion). Partial match in field copying logic. API mappings found for field assignment and cloning operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank5.c", "source_rust_file": "Partial__Marshal__idx5188_rank5.rs", "c_api": "SetValue(node[GET_NAME(alias)], alias)", "rust_api": "table_name: value.name.clone()", "mapping_type": "field_access", "description": "Assignment of field value from source to destination.", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node from member variables. Rust code is a conversion function that builds an `OrderTable` from a `Table` by cloning fields and converting them. [Similarity] Names don't match (`Marshal` vs `try_from`, `name` vs `table_name`), but both perform data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (JSON marshaling vs struct conversion). Partial match in field copying logic. API mappings found for field assignment and cloning operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank5.c", "source_rust_file": "Partial__Marshal__idx5188_rank5.rs", "c_api": "SetValue(node[GET_NAME(deviceId)], deviceId)", "rust_api": "fields.push(ipc_fd)", "mapping_type": "pattern", "description": "Appending elements to a collection.", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node from member variables. Rust code is a conversion function that builds an `OrderTable` from a `Table` by cloning fields and converting them. [Similarity] Names don't match (`Marshal` vs `try_from`, `name` vs `table_name`), but both perform data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (JSON marshaling vs struct conversion). Partial match in field copying logic. API mappings found for field assignment and cloning operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank5.c", "source_rust_file": "Partial__Marshal__idx5188_rank5.rs", "c_api": "SetValue(node[GET_NAME(autoSyncType)], autoSyncType)", "rust_api": "fields.push(ipc_fd)", "mapping_type": "pattern", "description": "Appending elements to a collection.", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node from member variables. Rust code is a conversion function that builds an `OrderTable` from a `Table` by cloning fields and converting them. [Similarity] Names don't match (`Marshal` vs `try_from`, `name` vs `table_name`), but both perform data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (JSON marshaling vs struct conversion). Partial match in field copying logic. API mappings found for field assignment and cloning operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank5.c", "source_rust_file": "Partial__Marshal__idx5188_rank5.rs", "c_api": "SetValue(node[GET_NAME(version)], version)", "rust_api": "fields.push(ipc_fd)", "mapping_type": "pattern", "description": "Appending elements to a collection.", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node from member variables. Rust code is a conversion function that builds an `OrderTable` from a `Table` by cloning fields and converting them. [Similarity] Names don't match (`Marshal` vs `try_from`, `name` vs `table_name`), but both perform data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (JSON marshaling vs struct conversion). Partial match in field copying logic. API mappings found for field assignment and cloning operations."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5188_rank5.c", "source_rust_file": "Partial__Marshal__idx5188_rank5.rs", "c_fragment": "SetValue(node[GET_NAME(name)], name);\n    SetValue(node[GET_NAME(alias)], alias);\n    SetValue(node[GET_NAME(tables)], tables);\n    SetValue(node[GET_NAME(version)], version);\n    SetValue(node[GET_NAME(bundleName)], bundleName);\n    SetValue(node[GET_NAME(user)], user);\n    SetValue(node[GET_NAME(deviceId)], deviceId);\n    SetValue(node[GET_NAME(autoSyncType)], autoSyncType);", "rust_fragment": "let ipc_fd = ipc_conn::Field::try_from(fd)?;\n            fields.push(ipc_fd);", "description": "Field assignment and copying logic in both languages.", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node from member variables. Rust code is a conversion function that builds an `OrderTable` from a `Table` by cloning fields and converting them. [Similarity] Names don't match (`Marshal` vs `try_from`, `name` vs `table_name`), but both perform data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (JSON marshaling vs struct conversion). Partial match in field copying logic. API mappings found for field assignment and cloning operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank5.c", "source_rust_file": "Partial__Marshal__idx5188_rank5.rs", "c_api": "SetValue(node[GET_NAME(user)], user)", "rust_api": "fields.push(ipc_fd)", "mapping_type": "pattern", "description": "Appending elements to a collection.", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node from member variables. Rust code is a conversion function that builds an `OrderTable` from a `Table` by cloning fields and converting them. [Similarity] Names don't match (`Marshal` vs `try_from`, `name` vs `table_name`), but both perform data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (JSON marshaling vs struct conversion). Partial match in field copying logic. API mappings found for field assignment and cloning operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank5.c", "source_rust_file": "Partial__Marshal__idx5188_rank5.rs", "c_api": "SetValue(node[GET_NAME(name)], name)", "rust_api": "alias: value.alias.clone()", "mapping_type": "field_access", "description": "Assignment of field value from source to destination.", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node from member variables. Rust code is a conversion function that builds an `OrderTable` from a `Table` by cloning fields and converting them. [Similarity] Names don't match (`Marshal` vs `try_from`, `name` vs `table_name`), but both perform data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (JSON marshaling vs struct conversion). Partial match in field copying logic. API mappings found for field assignment and cloning operations."}]
Unixcoder Score: -0.03631357476115227
--------------------------------------------------
C_Code: 
void ares__remove_from_list(struct list_node* node) {
  if (node->next != NULL) {
    node->prev->next = node->next;
    node->next->prev = node->prev;
    node->prev = NULL;
    node->next = NULL;
  }
}
Function: 
fn next(&mut self) -> Option<T> {
        while let Some(mut node) = self.it {
            unsafe {
                self.it = node.as_ref().next;
                self.idx += 1;

                if (self.pred)(&mut node.as_mut().element) {
                    // `unlink_node` is okay with aliasing `element` references.
                    self.list.unlink_node(node);
                    return Some(Box::from_raw(node.as_ptr()).element);
                }
            }
        }

        None
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx134559_rank1.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx134559_rank1.rs", "c_api": "new_node->prev = old_node->prev", "rust_api": "l.insert_n_before(three, two)", "mapping_type": "function", "description": "Set previous pointer when inserting node in a doubly-linked list", "reasoning": "[Task Analysis] C function manipulates linked list nodes by updating pointers; Rust function tests a doubly-linked list implementation with insert and push operations. [Similarity] Names do not match ('ares__insert_in_list' vs 'test_dlist_insert_n_before'), but both involve list node insertion logic. [Knowledge Extraction] The C code performs pointer manipulation for list insertion, while the Rust code tests similar behavior using a high-level API. There is no direct structural match due to different domains (low-level pointer manipulation vs high-level testing), but there are API mappings between list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx134559_rank1.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx134559_rank1.rs", "c_api": "old_node->prev = new_node", "rust_api": "l.insert_n_before(three, two)", "mapping_type": "function", "description": "Update previous pointer of the target node when inserting in a doubly-linked list", "reasoning": "[Task Analysis] C function manipulates linked list nodes by updating pointers; Rust function tests a doubly-linked list implementation with insert and push operations. [Similarity] Names do not match ('ares__insert_in_list' vs 'test_dlist_insert_n_before'), but both involve list node insertion logic. [Knowledge Extraction] The C code performs pointer manipulation for list insertion, while the Rust code tests similar behavior using a high-level API. There is no direct structural match due to different domains (low-level pointer manipulation vs high-level testing), but there are API mappings between list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx134559_rank1.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx134559_rank1.rs", "c_api": "new_node->next = old_node", "rust_api": "l.insert_n_before(three, two)", "mapping_type": "function", "description": "Insert node before another in a doubly-linked list", "reasoning": "[Task Analysis] C function manipulates linked list nodes by updating pointers; Rust function tests a doubly-linked list implementation with insert and push operations. [Similarity] Names do not match ('ares__insert_in_list' vs 'test_dlist_insert_n_before'), but both involve list node insertion logic. [Knowledge Extraction] The C code performs pointer manipulation for list insertion, while the Rust code tests similar behavior using a high-level API. There is no direct structural match due to different domains (low-level pointer manipulation vs high-level testing), but there are API mappings between list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx134559_rank1.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx134559_rank1.rs", "c_api": "old_node->prev->next = new_node", "rust_api": "l.insert_n_before(three, two)", "mapping_type": "function", "description": "Update next pointer of previous node when inserting in a doubly-linked list", "reasoning": "[Task Analysis] C function manipulates linked list nodes by updating pointers; Rust function tests a doubly-linked list implementation with insert and push operations. [Similarity] Names do not match ('ares__insert_in_list' vs 'test_dlist_insert_n_before'), but both involve list node insertion logic. [Knowledge Extraction] The C code performs pointer manipulation for list insertion, while the Rust code tests similar behavior using a high-level API. There is no direct structural match due to different domains (low-level pointer manipulation vs high-level testing), but there are API mappings between list insertion operations."}]
Unixcoder Score: -0.051793113350868225
--------------------------------------------------
C_Code: 
static void IpcJoinThread(bool initiative)
{
    if (g_connector == NULL) {
        RPC_LOG_ERROR("liteipc driver not init");
        return;
    }
    IpcJoinThreadLoop();
}
Function: 
pub fn join_work_thread() {
        JoinWorkThread();
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_api": "SetValue(node[GET_NAME(fields)], fields)", "rust_api": "typ: ipc_conn::FieldType::try_from(value.typ)?", "mapping_type": "pattern", "description": "Field assignment with type conversion in data transformation", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_api": "SetValue(node[GET_NAME(name)], name)", "rust_api": "col_name: value.col_name.clone()", "mapping_type": "pattern", "description": "Field assignment with cloning in data transformation", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_api": "SetValue(node[GET_NAME(alias)], alias)", "rust_api": "alias: value.alias.clone()", "mapping_type": "pattern", "description": "Field assignment with cloning in data transformation", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_fragment": "SetValue(node[GET_NAME(fields)], fields);", "rust_fragment": "typ: ipc_conn::FieldType::try_from(value.typ)?,", "description": "Copying a type field from source to destination with conversion.", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_fragment": "SetValue(node[GET_NAME(name)], name);", "rust_fragment": "col_name: value.col_name.clone(),", "description": "Copying a field value from source to destination in a data structure.", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_fragment": "SetValue(node[GET_NAME(alias)], alias);", "rust_fragment": "alias: value.alias.clone(),", "description": "Copying an alias field from source to destination in a data structure.", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}]
Unixcoder Score: -0.0560741052031517
--------------------------------------------------
C_Code: 
struct TT_DriverRec_
Function: 
struct DispatchInfo {
        use_large_path_scan: bool,

        // Dispatch workgroup counts for each pipeline
        path_reduce: WorkgroupSize,
        path_reduce2: WorkgroupSize,
        path_scan1: WorkgroupSize,
        path_scan: WorkgroupSize,
        bbox_clear: WorkgroupSize,
        flatten: WorkgroupSize,
        draw_reduce: WorkgroupSize,
        draw_leaf: WorkgroupSize,
        clip_reduce: WorkgroupSize,
        clip_leaf: WorkgroupSize,
        binning: WorkgroupSize,
        tile_alloc: WorkgroupSize,
        path_count_setup: WorkgroupSize,
        // Note: `path_count` must use an indirect dispatch
        backdrop: WorkgroupSize,
        coarse: WorkgroupSize,
        path_tiling_setup: WorkgroupSize,
        // Note: `path_tiling` must use an indirect dispatch
        fine: WorkgroupSize,
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__Marshal__idx5179_rank1.c", "source_rust_file": "API_Mapping__Marshal__idx5179_rank1.rs", "c_api": "SetValue(node[GET_NAME(name)], name)", "rust_api": "Database { name, ... }", "mapping_type": "pattern", "description": "Assigning a value to a field in a data structure", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node, while Rust code is a constructor for a Database struct. [Similarity] Names don't match ('Marshal' vs 'new'), and the domains are different (serialization vs struct construction). [Knowledge Extraction] No full structural match, but there are API mappings related to field assignment and data structure creation."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__Marshal__idx5179_rank1.c", "source_rust_file": "API_Mapping__Marshal__idx5179_rank1.rs", "c_api": "SetValue(node[GET_NAME(tables)], tables)", "rust_api": "Database { tables, ... }", "mapping_type": "pattern", "description": "Assigning a value to a field in a data structure", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node, while Rust code is a constructor for a Database struct. [Similarity] Names don't match ('Marshal' vs 'new'), and the domains are different (serialization vs struct construction). [Knowledge Extraction] No full structural match, but there are API mappings related to field assignment and data structure creation."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__Marshal__idx5179_rank1.c", "source_rust_file": "API_Mapping__Marshal__idx5179_rank1.rs", "c_api": "SetValue(node[GET_NAME(alias)], alias)", "rust_api": "Database { alias, ... }", "mapping_type": "pattern", "description": "Assigning a value to a field in a data structure", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node, while Rust code is a constructor for a Database struct. [Similarity] Names don't match ('Marshal' vs 'new'), and the domains are different (serialization vs struct construction). [Knowledge Extraction] No full structural match, but there are API mappings related to field assignment and data structure creation."}]
Unixcoder Score: -0.05650882422924042
--------------------------------------------------
C_Code: 
void ares__remove_from_list(struct list_node* node) {
  if (node->next != NULL) {
    node->prev->next = node->next;
    node->next->prev = node->prev;
    node->prev = NULL;
    node->next = NULL;
  }
}
Function: 
fn remove(nobe: dlist_node<T>) { self.unlink(nobe); }
Unixcoder Score: -0.05736574903130531
--------------------------------------------------
C_Code: 
void ares__remove_from_list(struct list_node* node) {
  if (node->next != NULL) {
    node->prev->next = node->next;
    node->next->prev = node->prev;
    node->prev = NULL;
    node->next = NULL;
  }
}
Function: 
pub fn remove(&mut self, at: usize) -> T {
        let len = self.len();
        assert!(at < len, "Cannot remove at an index outside of the list bounds");

        // Below, we iterate towards the node at the given index, either from
        // the start or the end, depending on which would be faster.
        let offset_from_end = len - at - 1;
        if at <= offset_from_end {
            let mut cursor = self.cursor_front_mut();
            for _ in 0..at {
                cursor.move_next();
            }
            cursor.remove_current().unwrap()
        } else {
            let mut cursor = self.cursor_back_mut();
            for _ in 0..offset_from_end {
                cursor.move_prev();
            }
            cursor.remove_current().unwrap()
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__ares__insert_in_list__idx134512_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134512_rank4.rs", "c_fragment": "new_node->next = old_node;\n  new_node->prev = old_node->prev;\n  old_node->prev->next = new_node;\n  old_node->prev = new_node;", "rust_fragment": "alt before {\n            some(neighbour) { neighbour.next = after; }\n            none            { self.hd        = after; }", "description": "Both code blocks perform insertion of a node/link into a doubly-linked list structure, updating next/prev pointers to maintain list integrity.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node between two existing nodes. Rust function links two nodes in a similar dlist structure. [Similarity] Names don't match but both perform list node insertion logic. [Knowledge Extraction] Found partial structural match in list manipulation, but not full structural similarity due to different control flow and data structures. No API mappings due to domain mismatch (C uses raw pointers, Rust uses Option-based links)."}]
Unixcoder Score: -0.057715218514204025
--------------------------------------------------
C_Code: 
void ares__remove_from_list(struct list_node* node) {
  if (node->next != NULL) {
    node->prev->next = node->next;
    node->next->prev = node->prev;
    node->prev = NULL;
    node->next = NULL;
  }
}
Function: 
pub unsafe fn remove(&mut self, entry: &mut UnsafeListEntry<T>) {
        rtassert!(!self.is_empty());
        // BEFORE:
        //     /----\ next ---> /-----\ next ---> /----\
        // ... |prev|           |entry|           |next| ...
        //     \----/ <--- prev \-----/ <--- prev \----/
        //
        // AFTER:
        //     /----\ next ---> /----\
        // ... |prev|           |next| ...
        //     \----/ <--- prev \----/
        let mut prev = entry.prev;
        let mut next = entry.next;
        // SAFETY: `prev` and `next` must meet all requirements for a mutable reference.entry
        unsafe { prev.as_mut() }.next = next;
        unsafe { next.as_mut() }.prev = prev;
        entry.next = NonNull::dangling();
        entry.prev = NonNull::dangling();
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx113841_rank5.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx113841_rank5.rs", "c_api": "old_node->prev->next = new_node", "rust_api": "self.list.split_off_after_node(self.current, split_off_idx)", "mapping_type": "function", "description": "Updating next pointer of previous node during insertion", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node between two existing nodes; Rust function splits a linked list after a given index. [Similarity] Names do not match, and domains are different (C: low-level pointer manipulation vs Rust: high-level list splitting). [Knowledge Extraction] No full or partial structural match. However, both involve linked list operations, so API mappings may exist for list manipulation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx113841_rank5.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx113841_rank5.rs", "c_api": "old_node->prev = new_node", "rust_api": "self.list.split_off_after_node(self.current, split_off_idx)", "mapping_type": "function", "description": "Updating previous pointer of the old node during insertion", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node between two existing nodes; Rust function splits a linked list after a given index. [Similarity] Names do not match, and domains are different (C: low-level pointer manipulation vs Rust: high-level list splitting). [Knowledge Extraction] No full or partial structural match. However, both involve linked list operations, so API mappings may exist for list manipulation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx113841_rank5.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx113841_rank5.rs", "c_api": "new_node->next = old_node", "rust_api": "self.list.split_off_after_node(self.current, split_off_idx)", "mapping_type": "function", "description": "Inserting a node into a linked list structure", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node between two existing nodes; Rust function splits a linked list after a given index. [Similarity] Names do not match, and domains are different (C: low-level pointer manipulation vs Rust: high-level list splitting). [Knowledge Extraction] No full or partial structural match. However, both involve linked list operations, so API mappings may exist for list manipulation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__ares__insert_in_list__idx113841_rank5.c", "source_rust_file": "API_Mapping__ares__insert_in_list__idx113841_rank5.rs", "c_api": "new_node->prev = old_node->prev", "rust_api": "self.list.split_off_after_node(self.current, split_off_idx)", "mapping_type": "function", "description": "Updating previous pointer during list insertion", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a node between two existing nodes; Rust function splits a linked list after a given index. [Similarity] Names do not match, and domains are different (C: low-level pointer manipulation vs Rust: high-level list splitting). [Knowledge Extraction] No full or partial structural match. However, both involve linked list operations, so API mappings may exist for list manipulation patterns."}]
Unixcoder Score: -0.05827583372592926
--------------------------------------------------
