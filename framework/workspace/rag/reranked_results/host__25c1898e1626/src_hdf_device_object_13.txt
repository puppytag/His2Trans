C_Code: 
struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
}
Function: 
struct BufferSizes {
        // Known size buffers
        path_reduced: u32,
        path_reduced2: u32,
        path_reduced_scan: u32,
        path_monoids: u32,
        path_bboxes: u32,
        draw_reduced: u32,
        draw_monoids: u32,
        info: u32,
        clip_inps: u32,
        clip_els: u32,
        clip_bics: u32,
        clip_bboxes: u32,
        draw_bboxes: u32,
        bump_alloc: u32,
        indirect_count: u32,
        bin_headers: u32,
        paths: u32,
        // Bump allocated buffers
        lines: u32,
        bin_data: u32,
        tiles: u32,
        seg_counts: u32,
        segments: u32,
        ptcl: u32,
    }
Unixcoder Score: 0.017220880836248398
--------------------------------------------------
C_Code: 
struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
}
Function: 
struct WorkgroupBufferInfo {
        size_in_bytes: u32,
        index: u32,
    }
Unixcoder Score: -0.006938052363693714
--------------------------------------------------
C_Code: 
PhysicalDeviceProperties( VkPhysicalDeviceProperties const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceProperties( *reinterpret_cast<PhysicalDeviceProperties const *>( &rhs ) )
    {
    }
Function: 
fn from(src: &vello_encoding::BufferSizes) -> Self {
        Self {
            path_reduced: src.path_reduced.size_in_bytes(),
            path_reduced2: src.path_reduced2.size_in_bytes(),
            path_reduced_scan: src.path_reduced_scan.size_in_bytes(),
            path_monoids: src.path_monoids.size_in_bytes(),
            path_bboxes: src.path_bboxes.size_in_bytes(),
            draw_reduced: src.draw_reduced.size_in_bytes(),
            draw_monoids: src.draw_monoids.size_in_bytes(),
            info: src.info.size_in_bytes(),
            clip_inps: src.clip_inps.size_in_bytes(),
            clip_els: src.clip_els.size_in_bytes(),
            clip_bics: src.clip_bics.size_in_bytes(),
            clip_bboxes: src.clip_bboxes.size_in_bytes(),
            draw_bboxes: src.draw_bboxes.size_in_bytes(),
            bump_alloc: src.bump_alloc.size_in_bytes(),
            indirect_count: src.indirect_count.size_in_bytes(),
            bin_headers: src.bin_headers.size_in_bytes(),
            paths: src.paths.size_in_bytes(),
            lines: src.lines.size_in_bytes(),
            bin_data: src.bin_data.size_in_bytes(),
            tiles: src.tiles.size_in_bytes(),
            seg_counts: src.seg_counts.size_in_bytes(),
            segments: src.segments.size_in_bytes(),
            ptcl: src.ptcl.size_in_bytes(),
        }
    }
Unixcoder Score: -0.011683203279972076
--------------------------------------------------
C_Code: 
DeviceCreateInfo( VkDeviceCreateInfo const & rhs ) VULKAN_HPP_NOEXCEPT : DeviceCreateInfo( *reinterpret_cast<DeviceCreateInfo const *>( &rhs ) ) {}
Function: 
fn from(src: &vello_encoding::BufferSizes) -> Self {
        Self {
            path_reduced: src.path_reduced.size_in_bytes(),
            path_reduced2: src.path_reduced2.size_in_bytes(),
            path_reduced_scan: src.path_reduced_scan.size_in_bytes(),
            path_monoids: src.path_monoids.size_in_bytes(),
            path_bboxes: src.path_bboxes.size_in_bytes(),
            draw_reduced: src.draw_reduced.size_in_bytes(),
            draw_monoids: src.draw_monoids.size_in_bytes(),
            info: src.info.size_in_bytes(),
            clip_inps: src.clip_inps.size_in_bytes(),
            clip_els: src.clip_els.size_in_bytes(),
            clip_bics: src.clip_bics.size_in_bytes(),
            clip_bboxes: src.clip_bboxes.size_in_bytes(),
            draw_bboxes: src.draw_bboxes.size_in_bytes(),
            bump_alloc: src.bump_alloc.size_in_bytes(),
            indirect_count: src.indirect_count.size_in_bytes(),
            bin_headers: src.bin_headers.size_in_bytes(),
            paths: src.paths.size_in_bytes(),
            lines: src.lines.size_in_bytes(),
            bin_data: src.bin_data.size_in_bytes(),
            tiles: src.tiles.size_in_bytes(),
            seg_counts: src.seg_counts.size_in_bytes(),
            segments: src.segments.size_in_bytes(),
            ptcl: src.ptcl.size_in_bytes(),
        }
    }
Unixcoder Score: -0.012169611640274525
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn insert_n_before(nobe: dlist_node<T>, neighbour: dlist_node<T>) {
        self.make_mine(nobe);
        self.insert_left(some(nobe), neighbour);
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_fragment": "new_node->next = old_node;\n  new_node->prev = old_node->prev;\n  old_node->prev->next = new_node;\n  old_node->prev = new_node;", "rust_fragment": "self.insert_right(neighbour, self.new_link(data));", "description": "Both code blocks perform insertion of a new node into a doubly-linked list structure.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_api": "new_node->prev = old_node->prev;", "rust_api": "self.insert_right(neighbour, self.new_link(data));", "mapping_type": "function", "description": "Setting the previous pointer of the new node to the previous node of the old node", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_api": "old_node->prev->next = new_node;", "rust_api": "self.insert_right(neighbour, self.new_link(data));", "mapping_type": "function", "description": "Updating the next pointer of the previous node to point to the new node", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_api": "old_node->prev = new_node;", "rust_api": "self.insert_right(neighbour, self.new_link(data));", "mapping_type": "function", "description": "Updating the previous pointer of the old node to point to the new node", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134528_rank4.c", "source_rust_file": "Partial__ares__insert_in_list__idx134528_rank4.rs", "c_api": "new_node->next = old_node;", "rust_api": "self.insert_right(neighbour, self.new_link(data));", "mapping_type": "function", "description": "Inserting a new node after a specified node in a doubly-linked list", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node after an existing node; Rust function inserts a new node after a given neighbor in a doubly-linked list. [Similarity] Both perform list insertion logic, but C uses raw pointer manipulation while Rust uses higher-level abstractions. [Knowledge Extraction] Names don't match but conceptually they are inserting nodes into a list structure. The structural fragments show similar control flow for node insertion. API mappings are present for list insertion operations."}]
Unixcoder Score: -0.026085300371050835
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn test_dlist_insert_n_before() {
        let l = create::<int>();
        l.assert_consistent(); let _one = l.push_n(1);
        l.assert_consistent(); let two = l.push_n(2);
        l.assert_consistent(); let three = create_node(3);
        l.assert_consistent(); assert l.len() == 2;
        l.assert_consistent(); l.insert_n_before(three, two);
        l.assert_consistent(); assert l.len() == 3;
        l.assert_consistent(); assert l.head() == 1;
        l.assert_consistent(); assert l.tail() == 2;
        l.assert_consistent(); assert l.pop().get() == 1;
        l.assert_consistent(); assert l.pop().get() == 3;
        l.assert_consistent(); assert l.pop().get() == 2;
        l.assert_consistent(); assert l.is_empty();
    }
Unixcoder Score: -0.026645511388778687
--------------------------------------------------
C_Code: 
struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
}
Function: 
struct BufferSizes {
        // Known size buffers
        path_reduced: u32,
        path_reduced2: u32,
        path_reduced_scan: u32,
        path_monoids: u32,
        path_bboxes: u32,
        draw_reduced: u32,
        draw_monoids: u32,
        info: u32,
        clip_inps: u32,
        clip_els: u32,
        clip_bics: u32,
        clip_bboxes: u32,
        draw_bboxes: u32,
        bump_alloc: u32,
        indirect_count: u32,
        bin_headers: u32,
        paths: u32,
        // Bump allocated buffers
        lines: u32,
        bin_data: u32,
        tiles: u32,
        seg_counts: u32,
        segments: u32,
        ptcl: u32,
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134517_rank3.c", "source_rust_file": "Partial__ares__insert_in_list__idx134517_rank3.rs", "c_api": "old_node->prev->next = new_node", "rust_api": "self.link(nobe, neighbour.next)", "mapping_type": "pattern", "description": "Updating the next pointer of the previous node to point to the new node.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node between two existing nodes; Rust function performs similar insertion logic in a doubly-linked list with assertions and size tracking. [Similarity] Names don't match but the core operation is semantically equivalent: inserting a node into a list structure. [Knowledge Extraction] Both perform list insertion logic, though Rust uses more safety checks and different naming. Extract API mappings for list node manipulation and structural fragments for the core insertion logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134517_rank3.c", "source_rust_file": "Partial__ares__insert_in_list__idx134517_rank3.rs", "c_api": "old_node->prev = new_node", "rust_api": "self.link(some(neighbour), nobe)", "mapping_type": "pattern", "description": "Updating the previous pointer of the old node to point to the new node.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node between two existing nodes; Rust function performs similar insertion logic in a doubly-linked list with assertions and size tracking. [Similarity] Names don't match but the core operation is semantically equivalent: inserting a node into a list structure. [Knowledge Extraction] Both perform list insertion logic, though Rust uses more safety checks and different naming. Extract API mappings for list node manipulation and structural fragments for the core insertion logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134517_rank3.c", "source_rust_file": "Partial__ares__insert_in_list__idx134517_rank3.rs", "c_api": "new_node->prev = old_node->prev", "rust_api": "self.link(some(neighbour), nobe)", "mapping_type": "pattern", "description": "Linking a new node to the previous node in the list.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node between two existing nodes; Rust function performs similar insertion logic in a doubly-linked list with assertions and size tracking. [Similarity] Names don't match but the core operation is semantically equivalent: inserting a node into a list structure. [Knowledge Extraction] Both perform list insertion logic, though Rust uses more safety checks and different naming. Extract API mappings for list node manipulation and structural fragments for the core insertion logic."}, {"knowledge_type": "Partial", "source_c_file": "Partial__ares__insert_in_list__idx134517_rank3.c", "source_rust_file": "Partial__ares__insert_in_list__idx134517_rank3.rs", "c_fragment": "new_node->next = old_node;\n  new_node->prev = old_node->prev;\n  old_node->prev->next = new_node;\n  old_node->prev = new_node;", "rust_fragment": "self.link(nobe, neighbour.next);\n        self.link(some(neighbour), nobe);", "description": "Inserts a new node between two existing nodes in a doubly-linked list.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node between two existing nodes; Rust function performs similar insertion logic in a doubly-linked list with assertions and size tracking. [Similarity] Names don't match but the core operation is semantically equivalent: inserting a node into a list structure. [Knowledge Extraction] Both perform list insertion logic, though Rust uses more safety checks and different naming. Extract API mappings for list node manipulation and structural fragments for the core insertion logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__ares__insert_in_list__idx134517_rank3.c", "source_rust_file": "Partial__ares__insert_in_list__idx134517_rank3.rs", "c_api": "new_node->next = old_node", "rust_api": "self.link(nobe, neighbour.next)", "mapping_type": "pattern", "description": "Linking a new node to the next node in the list.", "reasoning": "[Task Analysis] C function manipulates a doubly-linked list by inserting a new node between two existing nodes; Rust function performs similar insertion logic in a doubly-linked list with assertions and size tracking. [Similarity] Names don't match but the core operation is semantically equivalent: inserting a node into a list structure. [Knowledge Extraction] Both perform list insertion logic, though Rust uses more safety checks and different naming. Extract API mappings for list node manipulation and structural fragments for the core insertion logic."}]
Unixcoder Score: -0.026677541434764862
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
unsafe fn push_front_node(&mut self, node: Unique<Node<T>>) {
        // This method takes care not to create mutable references to whole nodes,
        // to maintain validity of aliasing pointers into `element`.
        unsafe {
            (*node.as_ptr()).next = self.head;
            (*node.as_ptr()).prev = None;
            let node = Some(NonNull::from(node));

            match self.head {
                None => self.tail = node,
                // Not creating new mutable (unique!) references overlapping `element`.
                Some(head) => (*head.as_ptr()).prev = node,
            }

            self.head = node;
            self.len += 1;
        }
    }
Unixcoder Score: -0.029589567333459854
--------------------------------------------------
C_Code: 
DeviceFaultCountsEXT( VkDeviceFaultCountsEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : DeviceFaultCountsEXT( *reinterpret_cast<DeviceFaultCountsEXT const *>( &rhs ) )
    {
    }
Function: 
fn from(src: &vello_encoding::WorkgroupCounts) -> Self {
        Self {
            use_large_path_scan: src.use_large_path_scan,
            path_reduce: (&src.path_reduce).into(),
            path_reduce2: (&src.path_reduce2).into(),
            path_scan1: (&src.path_scan1).into(),
            path_scan: (&src.path_scan).into(),
            bbox_clear: (&src.bbox_clear).into(),
            flatten: (&src.flatten).into(),
            draw_reduce: (&src.draw_reduce).into(),
            draw_leaf: (&src.draw_leaf).into(),
            clip_reduce: (&src.clip_reduce).into(),
            clip_leaf: (&src.clip_leaf).into(),
            binning: (&src.binning).into(),
            tile_alloc: (&src.tile_alloc).into(),
            path_count_setup: (&src.path_count_setup).into(),
            backdrop: (&src.backdrop).into(),
            coarse: (&src.coarse).into(),
            path_tiling_setup: (&src.path_tiling_setup).into(),
            fine: (&src.fine).into(),
        }
    }
Unixcoder Score: -0.029704194515943527
--------------------------------------------------
C_Code: 
void ares__insert_in_list(struct list_node* new_node,
                          struct list_node* old_node) {
  new_node->next = old_node;
  new_node->prev = old_node->prev;
  old_node->prev->next = new_node;
  old_node->prev = new_node;
}
Function: 
fn insert_right(neighbour: dlist_node<T>, nobe: dlist_link<T>) {
        self.assert_mine(neighbour);
        assert self.size > 0;
        self.link(nobe, neighbour.next);
        self.link(some(neighbour), nobe);
        self.size += 1;
    }
Unixcoder Score: -0.030232582241296768
--------------------------------------------------
