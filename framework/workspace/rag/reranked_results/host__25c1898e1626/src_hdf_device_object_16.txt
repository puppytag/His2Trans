C_Code: 
PublishedDataNode::PublishedDataNode() : VersionData(-1) {}
Function: 
fn read(&mut self, msg_parcel: &mut MsgParcel) -> Result<(), Error> {
        if msg_parcel
            .read::<i32>()
            .map_err(|_| Error::ReadMsgParcelFailed)?
            == 0
        {
            self.version = msg_parcel
                .read::<i32>()
                .map_err(|_| Error::ReadMsgParcelFailed)?;
            self.bundle_name = msg_parcel
                .read_string16()
                .map_err(|_| Error::ReadMsgParcelFailed)?;
            self.databases = msg_parcel
                .read::<Databases>()
                .map_err(|_| Error::ReadMsgParcelFailed)?;
            Ok(())
        } else {
            Err(Error::ReadMsgParcelFailed)
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__pointer_t__idx8708_rank2.h", "source_rust_file": "API_Mapping__pointer_t__idx8708_rank2.rs", "c_api": "node_t *node = new node_t();", "rust_api": "next: Option<Box<List<T>>>,", "mapping_type": "pattern", "description": "Node allocation and linking in a list", "reasoning": "[Task Analysis] The C code defines a lock-free queue using counted pointers and atomic compare-and-swap operations, while the Rust code defines a simple singly-linked list with Option<Box<>> for next node. [Similarity] The domain is mismatched: C uses low-level memory management and atomic operations for concurrency, while Rust uses high-level ownership semantics. [Knowledge Extraction] No full structural match due to domain mismatch and different data structures. However, there are API mappings related to list construction and node linking."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__pointer_t__idx8708_rank2.h", "source_rust_file": "API_Mapping__pointer_t__idx8708_rank2.rs", "c_api": "head.node = node; tail.node = node;", "rust_api": "value: T,", "mapping_type": "pattern", "description": "Initialization of list head/tail with dummy node", "reasoning": "[Task Analysis] The C code defines a lock-free queue using counted pointers and atomic compare-and-swap operations, while the Rust code defines a simple singly-linked list with Option<Box<>> for next node. [Similarity] The domain is mismatched: C uses low-level memory management and atomic operations for concurrency, while Rust uses high-level ownership semantics. [Knowledge Extraction] No full structural match due to domain mismatch and different data structures. However, there are API mappings related to list construction and node linking."}]
Unixcoder Score: -0.00712004816159606
--------------------------------------------------
C_Code: 
bool Serializable::GetValue(const json &node, const std::string &name, std::vector<uint8_t> &value)
{
    auto &subNode = GetSubNode(node, name);
    if (subNode.is_null() || !subNode.is_array()) {
        return false;
    }
    value = std::vector<uint8_t>(subNode);
    return true;
}
Function: 
pub(crate) fn vec_raw_read<T: Deserialize>(msg_parcel: &mut MsgParcel) -> IpcResult<Vec<T>> {
    let length = msg_parcel.read::<i32>()? as usize;
    let mut vector = Vec::with_capacity(length);
    for _ in 0..length {
        let value = msg_parcel.read::<T>()?;
        vector.push(value);
    }
    Ok(vector)
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__pointer_t__idx20551_rank3.h", "source_rust_file": "API_Mapping__pointer_t__idx20551_rank3.rs", "c_api": "compare_and_swap", "rust_api": "mpmc::Sender", "mapping_type": "type", "description": "Concurrent communication channel abstraction", "reasoning": "[Task Analysis] C code defines a lock-free queue with counted pointers and CAS operations; Rust code defines a SyncSender struct using mpmc::Sender. [Similarity] No structural similarity due to domain mismatch (low-level memory management vs high-level channel abstraction). [Knowledge Extraction] No full/partial match, but API mapping can be inferred from conceptual equivalence of concurrent communication patterns."}]
Unixcoder Score: -0.03568504378199577
--------------------------------------------------
C_Code: 
bool DataShareConfig::Marshal(json &node) const
{
    SetValue(node[GET_NAME(dataShareExtNames)], dataShareExtNames);
    SetValue(node[GET_NAME(updateLaunchNames)], updateLaunchNames);
    return true;
}
Function: 
fn serialize(&self, parcel: &mut MsgParcel) -> IpcResult<()> {
        parcel.write_string16(&self.asset_name)?;
        parcel.write_string16(&self.uri)?;
        parcel.write_string16(&self.sub_path)?;
        parcel.write_string16(&self.create_time)?;
        parcel.write_string16(&self.modify_time)?;
        parcel.write_string16(&self.size)?;
        parcel.write(&self.status)?;
        parcel.write_string16(&self.asset_id)?;
        parcel.write_string16(&self.hash)?;
        Ok(())
    }
Unixcoder Score: -0.042020753026008606
--------------------------------------------------
C_Code: 
struct pointer_t {
        node_t *node;
        uint32_t count;
        pointer_t() : node(NULL), count(0) {
        }
        pointer_t(node_t *node, uint32_t count) {
            this->node = node;
            this->count = count;
        }
        bool equals(pointer_t &other) {
            return node == other.node && count == other.count;
        }
    };

    struct node_t {
        T value;
        pointer_t next;

        node_t() {
            next.node = NULL;
            next.count = 0;
        }

        node_t(pointer_t next, T value) {
            this->next = next;
            this->value = value;
        }
    };

    // Always points to the first node in the list.
    pointer_t head;

    // Always points to a node in the list, (not necessarily the last).
    pointer_t tail;

    // Compare and swap counted pointers, we can only do this if pointr_t is
    // 8 bytes or less since that the maximum size CAS can handle.
    bool compare_and_swap(pointer_t *address,
        pointer_t *oldValue,
        pointer_t newValue) {

        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing
        // to GCC (possibly there are other, similar problems)
        if (sync::compare_and_swap(
                (uint64_t*) address,
                *(uint64_t*) oldValue,
                *(uint64_t*) &newValue)) {
            return true;
        }
        return false;
    }

public:
    lock_free_queue() {
        // We can only handle 64bit CAS for counted pointers, so this will
        // not work with 64bit pointers.
        assert (sizeof(pointer_t) == sizeof(uint64_t));

        // Allocate a dummy node to be used as the first node in the list.
        node_t *node = new node_t();

        // Head and tail both start out pointing to the dummy node.
        head.node = node;
        tail.node = node;
    }
Function: 
pub struct IterMut<'a, T: 'a> {
    head: Option<NonNull<Node<T>>>,
    tail: Option<NonNull<Node<T>>>,
    len: usize,
    marker: PhantomData<&'a mut Node<T>>,
}
Unixcoder Score: -0.04663107544183731
--------------------------------------------------
C_Code: 
struct pointer_t {
        node_t *node;
        uint32_t count;
        pointer_t() : node(NULL), count(0) {
        }
        pointer_t(node_t *node, uint32_t count) {
            this->node = node;
            this->count = count;
        }
        bool equals(pointer_t &other) {
            return node == other.node && count == other.count;
        }
    };

    struct node_t {
        T value;
        pointer_t next;

        node_t() {
            next.node = NULL;
            next.count = 0;
        }

        node_t(pointer_t next, T value) {
            this->next = next;
            this->value = value;
        }
    };

    // Always points to the first node in the list.
    pointer_t head;

    // Always points to a node in the list, (not necessarily the last).
    pointer_t tail;

    // Compare and swap counted pointers, we can only do this if pointr_t is
    // 8 bytes or less since that the maximum size CAS can handle.
    bool compare_and_swap(pointer_t *address,
        pointer_t *oldValue,
        pointer_t newValue) {

        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing
        // to GCC (possibly there are other, similar problems)
        if (sync::compare_and_swap(
                (uint64_t*) address,
                *(uint64_t*) oldValue,
                *(uint64_t*) &newValue)) {
            return true;
        }
        return false;
    }

public:
    lock_free_queue() {
        // We can only handle 64bit CAS for counted pointers, so this will
        // not work with 64bit pointers.
        assert (sizeof(pointer_t) == sizeof(uint64_t));

        // Allocate a dummy node to be used as the first node in the list.
        node_t *node = new node_t();

        // Head and tail both start out pointing to the dummy node.
        head.node = node;
        tail.node = node;
    }
Function: 
struct Node<T> {
    // XXX: this could be an uninitialized T if we're careful enough, and
    //      that would reduce memory usage (and be a bit faster).
    //      is it worth it?
    value: Option<T>,           // nullable for re-use of nodes
    next: AtomicPtr<Node<T>>,   // next node in the queue
}
Unixcoder Score: -0.05338890478014946
--------------------------------------------------
C_Code: 
struct pointer_t {
        node_t *node;
        uint32_t count;
        pointer_t() : node(NULL), count(0) {
        }
        pointer_t(node_t *node, uint32_t count) {
            this->node = node;
            this->count = count;
        }
        bool equals(pointer_t &other) {
            return node == other.node && count == other.count;
        }
    };

    struct node_t {
        T value;
        pointer_t next;

        node_t() {
            next.node = NULL;
            next.count = 0;
        }

        node_t(pointer_t next, T value) {
            this->next = next;
            this->value = value;
        }
    };

    // Always points to the first node in the list.
    pointer_t head;

    // Always points to a node in the list, (not necessarily the last).
    pointer_t tail;

    // Compare and swap counted pointers, we can only do this if pointr_t is
    // 8 bytes or less since that the maximum size CAS can handle.
    bool compare_and_swap(pointer_t *address,
        pointer_t *oldValue,
        pointer_t newValue) {

        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing
        // to GCC (possibly there are other, similar problems)
        if (sync::compare_and_swap(
                (uint64_t*) address,
                *(uint64_t*) oldValue,
                *(uint64_t*) &newValue)) {
            return true;
        }
        return false;
    }

public:
    lock_free_queue() {
        // We can only handle 64bit CAS for counted pointers, so this will
        // not work with 64bit pointers.
        assert (sizeof(pointer_t) == sizeof(uint64_t));

        // Allocate a dummy node to be used as the first node in the list.
        node_t *node = new node_t();

        // Head and tail both start out pointing to the dummy node.
        head.node = node;
        tail.node = node;
    }
Function: 
struct List<T> {
    value: T,
    next: Option<Box<List<T>>>,
}
Unixcoder Score: -0.053557343780994415
--------------------------------------------------
C_Code: 
struct pointer_t {
        node_t *node;
        uint32_t count;
        pointer_t() : node(NULL), count(0) {
        }
        pointer_t(node_t *node, uint32_t count) {
            this->node = node;
            this->count = count;
        }
        bool equals(pointer_t &other) {
            return node == other.node && count == other.count;
        }
    };

    struct node_t {
        T value;
        pointer_t next;

        node_t() {
            next.node = NULL;
            next.count = 0;
        }

        node_t(pointer_t next, T value) {
            this->next = next;
            this->value = value;
        }
    };

    // Always points to the first node in the list.
    pointer_t head;

    // Always points to a node in the list, (not necessarily the last).
    pointer_t tail;

    // Compare and swap counted pointers, we can only do this if pointr_t is
    // 8 bytes or less since that the maximum size CAS can handle.
    bool compare_and_swap(pointer_t *address,
        pointer_t *oldValue,
        pointer_t newValue) {

        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing
        // to GCC (possibly there are other, similar problems)
        if (sync::compare_and_swap(
                (uint64_t*) address,
                *(uint64_t*) oldValue,
                *(uint64_t*) &newValue)) {
            return true;
        }
        return false;
    }

public:
    lock_free_queue() {
        // We can only handle 64bit CAS for counted pointers, so this will
        // not work with 64bit pointers.
        assert (sizeof(pointer_t) == sizeof(uint64_t));

        // Allocate a dummy node to be used as the first node in the list.
        node_t *node = new node_t();

        // Head and tail both start out pointing to the dummy node.
        head.node = node;
        tail.node = node;
    }
Function: 
pub struct SyncSender<T> {
    inner: mpmc::Sender<T>,
}
Unixcoder Score: -0.055399730801582336
--------------------------------------------------
C_Code: 
struct pointer_t {
        node_t *node;
        uint32_t count;
        pointer_t() : node(NULL), count(0) {
        }
        pointer_t(node_t *node, uint32_t count) {
            this->node = node;
            this->count = count;
        }
        bool equals(pointer_t &other) {
            return node == other.node && count == other.count;
        }
    };

    struct node_t {
        T value;
        pointer_t next;

        node_t() {
            next.node = NULL;
            next.count = 0;
        }

        node_t(pointer_t next, T value) {
            this->next = next;
            this->value = value;
        }
    };

    // Always points to the first node in the list.
    pointer_t head;

    // Always points to a node in the list, (not necessarily the last).
    pointer_t tail;

    // Compare and swap counted pointers, we can only do this if pointr_t is
    // 8 bytes or less since that the maximum size CAS can handle.
    bool compare_and_swap(pointer_t *address,
        pointer_t *oldValue,
        pointer_t newValue) {

        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing
        // to GCC (possibly there are other, similar problems)
        if (sync::compare_and_swap(
                (uint64_t*) address,
                *(uint64_t*) oldValue,
                *(uint64_t*) &newValue)) {
            return true;
        }
        return false;
    }

public:
    lock_free_queue() {
        // We can only handle 64bit CAS for counted pointers, so this will
        // not work with 64bit pointers.
        assert (sizeof(pointer_t) == sizeof(uint64_t));

        // Allocate a dummy node to be used as the first node in the list.
        node_t *node = new node_t();

        // Head and tail both start out pointing to the dummy node.
        head.node = node;
        tail.node = node;
    }
Function: 
struct State<T> {
    stub: Node<T>,
    head: AtomicPtr<Node<T>>,
    tail: *mut Node<T>,
}
Unixcoder Score: -0.06171659752726555
--------------------------------------------------
C_Code: 
bool Database::Marshal(Serializable::json &node) const
{
    SetValue(node[GET_NAME(name)], name);
    SetValue(node[GET_NAME(alias)], alias);
    SetValue(node[GET_NAME(tables)], tables);
    SetValue(node[GET_NAME(version)], version);
    SetValue(node[GET_NAME(bundleName)], bundleName);
    SetValue(node[GET_NAME(user)], user);
    SetValue(node[GET_NAME(deviceId)], deviceId);
    SetValue(node[GET_NAME(autoSyncType)], autoSyncType);
    return true;
}
Function: 
fn try_from(value: &Database) -> Result<Self, SyncError> {
        let mut tables = vec![];
        for table in value.tables.values() {
            tables.push(table.try_into()?);
        }

        Ok(ipc_conn::Database {
            name: value.name.clone(),
            alias: value.alias.to_string(),
            tables: ipc_conn::SchemaOrderTables(tables),
        })
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_fragment": "for fd in &value.fields", "rust_fragment": "for fd in &value.fields", "description": "Iterates over fields in the table structure.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_api": "SetValue(node[GET_NAME(name)], name)", "rust_api": "table_name: value.name.clone()", "mapping_type": "field_access", "description": "Assigns the name field from source to destination.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_api": "SetValue(node[GET_NAME(alias)], alias)", "rust_api": "alias: value.alias.clone()", "mapping_type": "field_access", "description": "Assigns the alias field from source to destination.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_api": "SetValue(node[GET_NAME(fields)], fields)", "rust_api": "fields: ipc_conn::Fields(fields)", "mapping_type": "function", "description": "Converts and assigns fields to a new structure.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_api": "ipc_conn::Field::try_from(fd)?", "rust_api": "ipc_conn::Field::try_from(fd)?", "mapping_type": "function", "description": "Converts a field using a fallible conversion.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}]
Unixcoder Score: -0.0619022510945797
--------------------------------------------------
C_Code: 
bool Unmarshal(const json &node) override
        {
            GetValue(node, GET_NAME(bundleName), bundleName);
            GetValue(node, GET_NAME(accountId), accountId);
            GetValue(node, GET_NAME(storeId), storeId);
            return true;
        }
Function: 
fn deserialize(parcel: &mut MsgParcel) -> IpcResult<Self> {
        let app_id = parcel.read_string16()?;
        let bundle_name = parcel.read_string16()?;
        let cloud_switch = parcel.read::<i32>()? != 0;
        let instance_id = parcel.read::<i32>()?;

        let result = Self {
            app_id,
            bundle_name,
            cloud_switch,
            instance_id,
        };
        Ok(result)
    }
Unixcoder Score: -0.06508452445268631
--------------------------------------------------
