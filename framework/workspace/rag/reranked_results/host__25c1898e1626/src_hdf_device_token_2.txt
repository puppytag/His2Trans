C_Code: 
uint64_t SelfTokenID()
{
    return IPCSkeleton::GetSelfTokenID();
}
Function: 
fn skeleton() {
    unsafe {
        assert_eq!(
            Skeleton::calling_device_id(),
            (*GetCallingDeviceID()).to_string()
        );
        assert_eq!(Skeleton::calling_full_token_id(), GetCallingFullTokenID());
        assert_eq!(Skeleton::calling_pid(), GetCallingPid());
        assert_eq!(Skeleton::calling_real_pid(), GetCallingRealPid());
        assert_eq!(Skeleton::calling_token_id(), GetCallingTokenID());
        assert_eq!(Skeleton::calling_uid(), GetCallingUid());
        assert_eq!(Skeleton::first_full_token_id(), GetFirstFullTokenID());
        assert_eq!(Skeleton::first_token_id(), GetFirstTokenID());
        assert_eq!(Skeleton::self_token_id(), SelfTokenID());
        assert_eq!(Skeleton::is_local_calling(), IsLocalCalling());
        assert_eq!(Skeleton::local_device_id(), (*LocalDeviceID()).to_string());
        assert_eq!(
            Skeleton::reset_calling_identity(),
            (*ResetCallingIdentity()).to_string()
        );
    }
}
Unixcoder Score: 0.051233384758234024
--------------------------------------------------
C_Code: 
uint64_t GetSelfTokenID()
{
    return OHOS::IPCSkeleton::GetSelfTokenID();
}
Function: 
pub fn first_full_token_id() -> u64 {
        GetFirstFullTokenID()
    }
Unixcoder Score: 0.04802987724542618
--------------------------------------------------
C_Code: 
uint64_t GetSelfTokenID()
{
    return OHOS::IPCSkeleton::GetSelfTokenID();
}
Function: 
pub fn self_token_id() -> u64 {
        GetSelfTokenID()
    }
Unixcoder Score: 0.03837070241570473
--------------------------------------------------
C_Code: 
uint32_t GetCallingTokenID()
{
    return IPCSkeleton::GetCallingTokenID();
}
Function: 
fn skeleton() {
    unsafe {
        assert_eq!(
            Skeleton::calling_device_id(),
            (*GetCallingDeviceID()).to_string()
        );
        assert_eq!(Skeleton::calling_full_token_id(), GetCallingFullTokenID());
        assert_eq!(Skeleton::calling_pid(), GetCallingPid());
        assert_eq!(Skeleton::calling_real_pid(), GetCallingRealPid());
        assert_eq!(Skeleton::calling_token_id(), GetCallingTokenID());
        assert_eq!(Skeleton::calling_uid(), GetCallingUid());
        assert_eq!(Skeleton::first_full_token_id(), GetFirstFullTokenID());
        assert_eq!(Skeleton::first_token_id(), GetFirstTokenID());
        assert_eq!(Skeleton::self_token_id(), SelfTokenID());
        assert_eq!(Skeleton::is_local_calling(), IsLocalCalling());
        assert_eq!(Skeleton::local_device_id(), (*LocalDeviceID()).to_string());
        assert_eq!(
            Skeleton::reset_calling_identity(),
            (*ResetCallingIdentity()).to_string()
        );
    }
}
Unixcoder Score: 0.020085712894797325
--------------------------------------------------
C_Code: 
CDECL uintptr_t
rust_try(rust_try_fn f, void *fptr, void *env) {
    try {
        f(fptr, env);
    } catch (uintptr_t token) {
        assert(token != 0);
        return token;
    }
    return 0;
}
Function: 
pub fn map_children(
        &mut self,
        input: impl Iterator<Item = SyntaxNode>,
        output: impl Iterator<Item = SyntaxNode>,
    ) {
        for pairs in input.zip_longest(output) {
            let (input, output) = match pairs {
                itertools::EitherOrBoth::Both(l, r) => (l, r),
                itertools::EitherOrBoth::Left(_) => {
                    unreachable!("mapping more input nodes than there are output nodes")
                }
                itertools::EitherOrBoth::Right(_) => break,
            };

            self.map_node(input, output);
        }
    }
Unixcoder Score: 0.017713289707899094
--------------------------------------------------
C_Code: 
CDECL uintptr_t
rust_try(rust_try_fn f, void *fptr, void *env) {
    try {
        f(fptr, env);
    } catch (uintptr_t token) {
        assert(token != 0);
        return token;
    }
    return 0;
}
Function: 
pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),
                                              data: *mut u8,
                                              data_ptr: *mut usize,
                                              vtable_ptr: *mut usize)
                                              -> u32 {
    let mut payload = imp::payload();
    if intrinsics::try(f, data, &mut payload as *mut _ as *mut _) == 0 {
        0
    } else {
        let obj = mem::transmute::<_, raw::TraitObject>(imp::cleanup(payload));
        *data_ptr = obj.data as usize;
        *vtable_ptr = obj.vtable as usize;
        1
    }
}
Unixcoder Score: 0.015987562015652657
--------------------------------------------------
C_Code: 
CDECL uintptr_t
rust_try(rust_try_fn f, void *fptr, void *env) {
    try {
        f(fptr, env);
    } catch (uintptr_t token) {
        assert(token != 0);
        return token;
    }
    return 0;
}
Function: 
pub fn upmap_element(
        &self,
        input: &SyntaxElement,
        output_root: &SyntaxNode,
    ) -> Option<Result<SyntaxElement, MissingMapping>> {
        match input {
            SyntaxElement::Node(node) => {
                Some(self.upmap_node(node, output_root)?.map(SyntaxElement::Node))
            }
            SyntaxElement::Token(token) => {
                let upmap_parent = match self.upmap_node(&token.parent().unwrap(), output_root)? {
                    Ok(it) => it,
                    Err(err) => return Some(Err(err)),
                };

                let element = upmap_parent.children_with_tokens().nth(token.index()).unwrap();
                debug_assert!(
                    element.as_token().is_some_and(|it| it.kind() == token.kind()),
                    "token upmapping mapped to the wrong node ({token:?} -> {element:?})"
                );

                Some(Ok(element))
            }
        }
    }
Unixcoder Score: 0.015982601791620255
--------------------------------------------------
C_Code: 
CDECL uintptr_t
rust_try(rust_try_fn f, void *fptr, void *env) {
    try {
        f(fptr, env);
    } catch (uintptr_t token) {
        assert(token != 0);
        return token;
    }
    return 0;
}
Function: 
pub fn main() {
    fn change_then_remove(p: &Path, f: &fn()) {
        do (|| {
            unstable::change_dir_locked(p, || f());
        }).finally {
            os::remove_dir_recursive(p);
        }
    }

    fn mk_file(path: &str, directory: bool) {
        if directory {
            os::make_dir(&Path(path), 0xFFFF);
        } else {
            io::mk_file_writer(&Path(path), [io::Create]);
        }
    }

    fn abs_path(path: &str) -> Path {
        os::getcwd().push_many(Path(path).components)
    }

    fn glob_vec(pattern: &str) -> ~[Path] {
        glob(pattern).collect()
    }

    let root = tempfile::mkdtemp(&os::tmpdir(), "glob-tests");
    let root = root.expect("Should have created a temp directory");

    do change_then_remove(&root) {
        mk_file("aaa", true);
        mk_file("aaa/apple", true);
        mk_file("aaa/orange", true);
        mk_file("aaa/tomato", true);
        mk_file("aaa/tomato/tomato.txt", false);
        mk_file("aaa/tomato/tomoto.txt", false);
        mk_file("bbb", true);
        mk_file("bbb/specials", true);
        mk_file("bbb/specials/!", false);

        // windows does not allow `*` or `?` characters to exist in filenames
        if os::consts::FAMILY != os::consts::windows::FAMILY {
            mk_file("bbb/specials/*", false);
            mk_file("bbb/specials/?", false);
        }

        mk_file("bbb/specials/[", false);
        mk_file("bbb/specials/]", false);
        mk_file("ccc", true);
        mk_file("xyz", true);
        mk_file("xyz/x", false);
        mk_file("xyz/y", false);
        mk_file("xyz/z", false);

        assert_eq!(glob_vec(""), ~[]);
        assert_eq!(glob_vec("."), ~[]);
        assert_eq!(glob_vec(".."), ~[]);

        assert_eq!(glob_vec("aaa"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("aaa/"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("a"), ~[]);
        assert_eq!(glob_vec("aa"), ~[]);
        assert_eq!(glob_vec("aaaa"), ~[]);

        assert_eq!(glob_vec("aaa/apple"), ~[abs_path("aaa/apple")]);
        assert_eq!(glob_vec("aaa/apple/nope"), ~[]);

        // windows should support both / and \ as directory separators
        if os::consts::FAMILY == os::consts::windows::FAMILY {
            assert_eq!(glob_vec("aaa\\apple"), ~[abs_path("aaa/apple")]);
        }

        assert_eq!(glob_vec("???/"), ~[
            abs_path("aaa"),
            abs_path("bbb"),
            abs_path("ccc"),
            abs_path("xyz")]);

        assert_eq!(glob_vec("aaa/tomato/tom?to.txt"), ~[
            abs_path("aaa/tomato/tomato.txt"),
            abs_path("aaa/tomato/tomoto.txt")]);

        assert_eq!(glob_vec("xyz/?"), ~[
            abs_path("xyz/x"),
            abs_path("xyz/y"),
            abs_path("xyz/z")]);

        assert_eq!(glob_vec("a*"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("*a*"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("a*a"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("aaa*"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("*aaa"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("*aaa*"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("*a*a*a*"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("aaa*/"), ~[abs_path("aaa")]);

        assert_eq!(glob_vec("aaa/*"), ~[
            abs_path("aaa/apple"),
            abs_path("aaa/orange"),
            abs_path("aaa/tomato")]);

        assert_eq!(glob_vec("aaa/*a*"), ~[
            abs_path("aaa/apple"),
            abs_path("aaa/orange"),
            abs_path("aaa/tomato")]);

        assert_eq!(glob_vec("*/*/*.txt"), ~[
            abs_path("aaa/tomato/tomato.txt"),
            abs_path("aaa/tomato/tomoto.txt")]);

        assert_eq!(glob_vec("*/*/t[aob]m?to[.]t[!y]t"), ~[
            abs_path("aaa/tomato/tomato.txt"),
            abs_path("aaa/tomato/tomoto.txt")]);

        assert_eq!(glob_vec("aa[a]"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("aa[abc]"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("a[bca]a"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("aa[b]"), ~[]);
        assert_eq!(glob_vec("aa[xyz]"), ~[]);
        assert_eq!(glob_vec("aa[]]"), ~[]);

        assert_eq!(glob_vec("aa[!b]"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("aa[!bcd]"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("a[!bcd]a"), ~[abs_path("aaa")]);
        assert_eq!(glob_vec("aa[!a]"), ~[]);
        assert_eq!(glob_vec("aa[!abc]"), ~[]);

        assert_eq!(glob_vec("bbb/specials/[[]"), ~[abs_path("bbb/specials/[")]);
        assert_eq!(glob_vec("bbb/specials/!"), ~[abs_path("bbb/specials/!")]);
        assert_eq!(glob_vec("bbb/specials/[]]"), ~[abs_path("bbb/specials/]")]);

        if os::consts::FAMILY != os::consts::windows::FAMILY {
            assert_eq!(glob_vec("bbb/specials/[*]"), ~[abs_path("bbb/specials/*")]);
            assert_eq!(glob_vec("bbb/specials/[?]"), ~[abs_path("bbb/specials/?")]);
        }

        if os::consts::FAMILY == os::consts::windows::FAMILY {

            assert_eq!(glob_vec("bbb/specials/[![]"), ~[
                abs_path("bbb/specials/!"),
                abs_path("bbb/specials/]")]);

            assert_eq!(glob_vec("bbb/specials/[!]]"), ~[
                abs_path("bbb/specials/!"),
                abs_path("bbb/specials/[")]);

            assert_eq!(glob_vec("bbb/specials/[!!]"), ~[
                abs_path("bbb/specials/["),
                abs_path("bbb/specials/]")]);

        } else {

            assert_eq!(glob_vec("bbb/specials/[![]"), ~[
                abs_path("bbb/specials/!"),
                abs_path("bbb/specials/*"),
                abs_path("bbb/specials/?"),
                abs_path("bbb/specials/]")]);

            assert_eq!(glob_vec("bbb/specials/[!]]"), ~[
                abs_path("bbb/specials/!"),
                abs_path("bbb/specials/*"),
                abs_path("bbb/specials/?"),
                abs_path("bbb/specials/[")]);

            assert_eq!(glob_vec("bbb/specials/[!!]"), ~[
                abs_path("bbb/specials/*"),
                abs_path("bbb/specials/?"),
                abs_path("bbb/specials/["),
                abs_path("bbb/specials/]")]);

            assert_eq!(glob_vec("bbb/specials/[!*]"), ~[
                abs_path("bbb/specials/!"),
                abs_path("bbb/specials/?"),
                abs_path("bbb/specials/["),
                abs_path("bbb/specials/]")]);

            assert_eq!(glob_vec("bbb/specials/[!?]"), ~[
                abs_path("bbb/specials/!"),
                abs_path("bbb/specials/*"),
                abs_path("bbb/specials/["),
                abs_path("bbb/specials/]")]);

        }
    };
}
Unixcoder Score: 0.014718590304255486
--------------------------------------------------
C_Code: 
CDECL uintptr_t
rust_try(rust_try_fn f, void *fptr, void *env) {
    try {
        f(fptr, env);
    } catch (uintptr_t token) {
        assert(token != 0);
        return token;
    }
    return 0;
}
Function: 
pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),
                                              data: *mut u8,
                                              data_ptr: *mut usize,
                                              vtable_ptr: *mut usize)
                                              -> u32 {
    let mut payload = imp::payload();
    if intrinsics::try(f, data, &mut payload as *mut _ as *mut _) == 0 {
        0
    } else {
        let obj = mem::transmute::<_, raw::TraitObject>(imp::cleanup(payload));
        *data_ptr = obj.data as usize;
        *vtable_ptr = obj.vtable as usize;
        1
    }
}
Unixcoder Score: 0.013782324269413948
--------------------------------------------------
C_Code: 
CDECL uintptr_t
rust_try(rust_try_fn f, void *fptr, void *env) {
    try {
        f(fptr, env);
    } catch (uintptr_t token) {
        assert(token != 0);
        return token;
    }
    return 0;
}
Function: 
fn expect(tokens: &mut token_stream::IntoIter, expected: &str) -> TokenTree {
    match tokens.next() {
        Some(token) if token.to_string() == expected => token,
        wrong => panic!("unexpected token: {:?}, expected `{}`", wrong, expected),
    }
}
Unixcoder Score: 0.013606461696326733
--------------------------------------------------
