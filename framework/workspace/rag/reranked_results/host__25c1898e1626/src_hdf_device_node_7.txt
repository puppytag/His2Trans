C_Code: 
PublishedDataNode::PublishedDataNode() : VersionData(-1) {}
Function: 
fn read(&mut self, msg_parcel: &mut MsgParcel) -> Result<(), Error> {
        if msg_parcel
            .read::<i32>()
            .map_err(|_| Error::ReadMsgParcelFailed)?
            == 0
        {
            self.version = msg_parcel
                .read::<i32>()
                .map_err(|_| Error::ReadMsgParcelFailed)?;
            self.bundle_name = msg_parcel
                .read_string16()
                .map_err(|_| Error::ReadMsgParcelFailed)?;
            self.databases = msg_parcel
                .read::<Databases>()
                .map_err(|_| Error::ReadMsgParcelFailed)?;
            Ok(())
        } else {
            Err(Error::ReadMsgParcelFailed)
        }
    }
Unixcoder Score: 0.022121084854006767
--------------------------------------------------
C_Code: 
static DWORD WINAPI getaddrinfo_thread_proc(void* parameter) {
  uv_getaddrinfo_t* handle = (uv_getaddrinfo_t*)parameter;
  int ret;

  assert(handle != NULL);

  if (handle != NULL) {
    /* call OS function on this thread */
    ret = GetAddrInfoW(handle->node, handle->service, handle->hints, &handle->res);
    handle->retcode = ret;

    /* post getaddrinfo completed */
    if (!PostQueuedCompletionStatus(uv_iocp_,
                                  0,
                                  0,
                                  &handle->getadddrinfo_req.overlapped)) {
      uv_fatal_error(GetLastError(), "PostQueuedCompletionStatus");
    }
  }

  return 0;
}
Function: 
pub unsafe fn getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,
               getaddrinfo_cb: uv_getaddrinfo_cb,
               node: *c_char, service: *c_char,
               hints: *addrinfo) -> c_int {
    #[fixed_stack_segment]; #[inline(never)];
    return rust_uv_getaddrinfo(loop_, req, getaddrinfo_cb, node, service, hints);
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__Marshal__idx5179_rank1.c", "source_rust_file": "API_Mapping__Marshal__idx5179_rank1.rs", "c_api": "SetValue(node[GET_NAME(name)], name)", "rust_api": "Database { name, ... }", "mapping_type": "pattern", "description": "Assigning a value to a field in a data structure", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node, while Rust code is a constructor for a Database struct. [Similarity] Names don't match ('Marshal' vs 'new'), and the domains are different (serialization vs struct construction). [Knowledge Extraction] No full structural match, but there are API mappings related to field assignment and data structure creation."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__Marshal__idx5179_rank1.c", "source_rust_file": "API_Mapping__Marshal__idx5179_rank1.rs", "c_api": "SetValue(node[GET_NAME(tables)], tables)", "rust_api": "Database { tables, ... }", "mapping_type": "pattern", "description": "Assigning a value to a field in a data structure", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node, while Rust code is a constructor for a Database struct. [Similarity] Names don't match ('Marshal' vs 'new'), and the domains are different (serialization vs struct construction). [Knowledge Extraction] No full structural match, but there are API mappings related to field assignment and data structure creation."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__Marshal__idx5179_rank1.c", "source_rust_file": "API_Mapping__Marshal__idx5179_rank1.rs", "c_api": "SetValue(node[GET_NAME(alias)], alias)", "rust_api": "Database { alias, ... }", "mapping_type": "pattern", "description": "Assigning a value to a field in a data structure", "reasoning": "[Task Analysis] C code is a marshaling function that sets values in a JSON node, while Rust code is a constructor for a Database struct. [Similarity] Names don't match ('Marshal' vs 'new'), and the domains are different (serialization vs struct construction). [Knowledge Extraction] No full structural match, but there are API mappings related to field assignment and data structure creation."}]
Unixcoder Score: 0.0014714637072756886
--------------------------------------------------
C_Code: 
int uv_getaddrinfo(uv_loop_t* loop,
                   uv_getaddrinfo_t* handle,
                   uv_getaddrinfo_cb getaddrinfo_cb,
                   const char* node,
                   const char* service,
                   const struct addrinfo* hints) {
  int nodesize = 0;
  int servicesize = 0;
  int hintssize = 0;
  char* alloc_ptr = NULL;

  if (handle == NULL || getaddrinfo_cb == NULL ||
     (node == NULL && service == NULL)) {
    uv__set_sys_error(loop, WSAEINVAL);
    goto error;
  }

  uv_req_init(loop, (uv_req_t*)handle);

  handle->getaddrinfo_cb = getaddrinfo_cb;
  handle->res = NULL;
  handle->type = UV_GETADDRINFO;
  handle->loop = loop;

  /* calculate required memory size for all input values */
  if (node != NULL) {
    nodesize = ALIGNED_SIZE(uv_utf8_to_utf16(node, NULL, 0) * sizeof(wchar_t));
    if (nodesize == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
  }

  if (service != NULL) {
    servicesize = ALIGNED_SIZE(uv_utf8_to_utf16(service, NULL, 0) *
                               sizeof(wchar_t));
    if (servicesize == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
  }
  if (hints != NULL) {
    hintssize = ALIGNED_SIZE(sizeof(struct addrinfoW));
  }

  /* allocate memory for inputs, and partition it as needed */
  alloc_ptr = (char*)malloc(nodesize + servicesize + hintssize);
  if (!alloc_ptr) {
    uv__set_sys_error(loop, WSAENOBUFS);
    goto error;
  }

  /* save alloc_ptr now so we can free if error */
  handle->alloc = (void*)alloc_ptr;

  /* convert node string to UTF16 into allocated memory and save pointer in */
  /* handle */
  if (node != NULL) {
    handle->node = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(node,
                         (wchar_t*) alloc_ptr,
                         nodesize / sizeof(wchar_t)) == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
    alloc_ptr += nodesize;
  } else {
    handle->node = NULL;
  }

  /* convert service string to UTF16 into allocated memory and save pointer */
  /* in handle */
  if (service != NULL) {
    handle->service = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(service,
                         (wchar_t*) alloc_ptr,
                         servicesize / sizeof(wchar_t)) == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
    alloc_ptr += servicesize;
  } else {
    handle->service = NULL;
  }

  /* copy hints to allocated memory and save pointer in handle */
  if (hints != NULL) {
    handle->hints = (struct addrinfoW*)alloc_ptr;
    handle->hints->ai_family = hints->ai_family;
    handle->hints->ai_socktype = hints->ai_socktype;
    handle->hints->ai_protocol = hints->ai_protocol;
    handle->hints->ai_flags = hints->ai_flags;
    handle->hints->ai_addrlen = 0;
    handle->hints->ai_canonname = NULL;
    handle->hints->ai_addr = NULL;
    handle->hints->ai_next = NULL;
  } else {
    handle->hints = NULL;
  }

  /* init request for Post handling */
  uv_req_init(loop, &handle->getadddrinfo_req);
  handle->getadddrinfo_req.data = handle;
  handle->getadddrinfo_req.type = UV_GETADDRINFO_REQ;

  /* Ask thread to run. Treat this as a long operation */
  if (QueueUserWorkItem(&getaddrinfo_thread_proc,
                        handle,
                        WT_EXECUTELONGFUNCTION) == 0) {
    uv__set_sys_error(loop, GetLastError());
    goto error;
  }

  uv_ref(loop);

  return 0;

error:
  if (handle != NULL && handle->alloc != NULL) {
    free(handle->alloc);
  }
  return -1;
}
Function: 
fn main() {
    unsafe {
        let x = alloc(Layout::from_size_align_unchecked(1, 1));
        dealloc(x, Layout::from_size_align_unchecked(1, 1));
        let _z = realloc(x, Layout::from_size_align_unchecked(1, 1), 1);
    }
}
Unixcoder Score: -0.0016692870995029807
--------------------------------------------------
C_Code: 
static DWORD WINAPI getaddrinfo_thread_proc(void* parameter) {
  uv_getaddrinfo_t* handle = (uv_getaddrinfo_t*)parameter;
  int ret;

  assert(handle != NULL);

  if (handle != NULL) {
    /* call OS function on this thread */
    ret = GetAddrInfoW(handle->node, handle->service, handle->hints, &handle->res);
    handle->retcode = ret;

    /* post getaddrinfo completed */
    if (!PostQueuedCompletionStatus(uv_iocp_,
                                  0,
                                  0,
                                  &handle->getadddrinfo_req.overlapped)) {
      uv_fatal_error(GetLastError(), "PostQueuedCompletionStatus");
    }
  }

  return 0;
}
Function: 
pub unsafe fn getaddrinfo(
        node: *const c_char,
        service: *const c_char,
        hints: *const ADDRINFOA,
        res: *mut *mut ADDRINFOA,
    ) -> c_int {
        unsafe { c::getaddrinfo(node.cast::<u8>(), service.cast::<u8>(), hints, res) }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5178_rank3.c", "source_rust_file": "Partial__Unmarshal__idx5178_rank3.rs", "c_api": "GetValue(node, GET_NAME(alias), alias)", "rust_api": "value.alias.to_string()", "mapping_type": "field_access", "description": "Extracting a string field from a source structure and converting it to a target string.", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls. Rust code is a try_from function that builds a new Database struct from an existing one, converting tables and cloning fields. [Similarity] Names don't match exactly but both perform data extraction/serialization logic. [Knowledge Extraction] Full match blocked by domain mismatch (JSON deserialization vs struct construction), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5178_rank3.c", "source_rust_file": "Partial__Unmarshal__idx5178_rank3.rs", "c_api": "GetValue(node, GET_NAME(name), name)", "rust_api": "value.name.clone()", "mapping_type": "field_access", "description": "Extracting a field from a source structure and assigning it to a target field.", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls. Rust code is a try_from function that builds a new Database struct from an existing one, converting tables and cloning fields. [Similarity] Names don't match exactly but both perform data extraction/serialization logic. [Knowledge Extraction] Full match blocked by domain mismatch (JSON deserialization vs struct construction), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5178_rank3.c", "source_rust_file": "Partial__Unmarshal__idx5178_rank3.rs", "c_api": "GetValue(node, GET_NAME(tables), tables)", "rust_api": "for table in value.tables.values() {\n            tables.push(table.try_into()?);\n        }", "mapping_type": "pattern", "description": "Iterating over a collection and converting each element to a new type.", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls. Rust code is a try_from function that builds a new Database struct from an existing one, converting tables and cloning fields. [Similarity] Names don't match exactly but both perform data extraction/serialization logic. [Knowledge Extraction] Full match blocked by domain mismatch (JSON deserialization vs struct construction), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Unmarshal__idx5178_rank3.c", "source_rust_file": "Partial__Unmarshal__idx5178_rank3.rs", "c_fragment": "GetValue(node, GET_NAME(name), name);\n    GetValue(node, GET_NAME(alias), alias);\n    GetValue(node, GET_NAME(tables), tables);\n    GetValue(node, GET_NAME(dbName), name);\n    GetValue(node, GET_NAME(autoSyncType), autoSyncType);\n    GetValue(node, GET_NAME(user), user);\n    GetValue(node, GET_NAME(deviceId), deviceId);\n    GetValue(node, GET_NAME(version), version);\n    GetValue(node, GET_NAME(bundleName), bundleName);", "rust_fragment": "let mut tables = vec![];\n        for table in value.tables.values() {\n            tables.push(table.try_into()?);\n        }", "description": "Both extract data from a source structure (JSON or struct) and populate fields in a target structure.", "reasoning": "[Task Analysis] C code is a Unmarshal function that extracts fields from a JSON node using GetValue calls. Rust code is a try_from function that builds a new Database struct from an existing one, converting tables and cloning fields. [Similarity] Names don't match exactly but both perform data extraction/serialization logic. [Knowledge Extraction] Full match blocked by domain mismatch (JSON deserialization vs struct construction), but partial fragments and API mappings can be extracted."}]
Unixcoder Score: -0.0031877520959824324
--------------------------------------------------
C_Code: 
int uv_getaddrinfo(uv_getaddrinfo_t* handle,
                   uv_getaddrinfo_cb getaddrinfo_cb,
                   const char* node,
                   const char* service,
                   const struct addrinfo* hints) {
  int nodesize = 0;
  int servicesize = 0;
  int hintssize = 0;
  char* alloc_ptr = NULL;

  if (handle == NULL || getaddrinfo_cb == NULL ||
     (node == NULL && service == NULL)) {
    uv_set_sys_error(WSAEINVAL);
    goto error;
  }

  handle->getaddrinfo_cb = getaddrinfo_cb;
  handle->res = NULL;
  handle->type = UV_GETADDRINFO;

  /* calculate required memory size for all input values */
  if (node != NULL) {
    nodesize = ALIGNED_SIZE(uv_utf8_to_utf16(node, NULL, 0) * sizeof(wchar_t));
    if (nodesize == 0) {
      uv_set_sys_error(GetLastError());
      goto error;
    }
  }

  if (service != NULL) {
    servicesize = ALIGNED_SIZE(uv_utf8_to_utf16(service, NULL, 0) * sizeof(wchar_t));
    if (servicesize == 0) {
      uv_set_sys_error(GetLastError());
      goto error;
    }
  }
  if (hints != NULL) {
    hintssize = ALIGNED_SIZE(sizeof(struct addrinfoW));
  }

  /* allocate memory for inputs, and partition it as needed */
  alloc_ptr = (char*)malloc(nodesize + servicesize + hintssize);
  if (!alloc_ptr) {
    uv_set_sys_error(WSAENOBUFS);
    goto error;
  }

  /* save alloc_ptr now so we can free if error */
  handle->alloc = (void*)alloc_ptr;

  /* convert node string to UTF16 into allocated memory and save pointer in handle */
  if (node != NULL) {
    handle->node = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(node, (wchar_t*)alloc_ptr, nodesize / sizeof(wchar_t)) == 0) {
      uv_set_sys_error(GetLastError());
      goto error;
    }
    alloc_ptr += nodesize;
  } else {
    handle->node = NULL;
  }

  /* convert service string to UTF16 into allocated memory and save pointer in handle */
  if (service != NULL) {
    handle->service = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(service, (wchar_t*)alloc_ptr, servicesize / sizeof(wchar_t)) == 0) {
      uv_set_sys_error(GetLastError());
      goto error;
    }
    alloc_ptr += servicesize;
  } else {
    handle->service = NULL;
  }

  /* copy hints to allocated memory and save pointer in handle */
  if (hints != NULL) {
    handle->hints = (struct addrinfoW*)alloc_ptr;
    handle->hints->ai_family = hints->ai_family;
    handle->hints->ai_socktype = hints->ai_socktype;
    handle->hints->ai_protocol = hints->ai_protocol;
    handle->hints->ai_flags = hints->ai_flags;
    handle->hints->ai_addrlen = 0;
    handle->hints->ai_canonname = NULL;
    handle->hints->ai_addr = NULL;
    handle->hints->ai_next = NULL;
  } else {
    handle->hints = NULL;
  }

  /* init request for Post handling */
  uv_req_init(&handle->getadddrinfo_req, (uv_handle_t*)handle, NULL);
  handle->getadddrinfo_req.type = UV_WAKEUP;

  /* Ask thread to run. Treat this as a long operation */
  if (QueueUserWorkItem(&getaddrinfo_thread_proc, handle, WT_EXECUTELONGFUNCTION) == 0) {
    uv_set_sys_error(GetLastError());
    goto error;
  }

  uv_refs_++;

  return 0;

error:
  if (handle != NULL && handle->alloc != NULL) {
    free(handle->alloc);
  }
  return -1;
}
Function: 
pub unsafe fn getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,
               getaddrinfo_cb: uv_getaddrinfo_cb,
               node: *c_char, service: *c_char,
               hints: *addrinfo) -> c_int {
    #[fixed_stack_segment]; #[inline(never)];
    return rust_uv_getaddrinfo(loop_, req, getaddrinfo_cb, node, service, hints);
}
Unixcoder Score: -0.005307569168508053
--------------------------------------------------
C_Code: 
int uv_getaddrinfo(uv_loop_t* loop,
                   uv_getaddrinfo_t* handle,
                   uv_getaddrinfo_cb getaddrinfo_cb,
                   const char* node,
                   const char* service,
                   const struct addrinfo* hints) {
  int nodesize = 0;
  int servicesize = 0;
  int hintssize = 0;
  char* alloc_ptr = NULL;

  if (handle == NULL || getaddrinfo_cb == NULL ||
     (node == NULL && service == NULL)) {
    uv__set_sys_error(loop, WSAEINVAL);
    goto error;
  }

  uv_req_init(loop, (uv_req_t*)handle);

  handle->getaddrinfo_cb = getaddrinfo_cb;
  handle->res = NULL;
  handle->type = UV_GETADDRINFO;
  handle->loop = loop;

  /* calculate required memory size for all input values */
  if (node != NULL) {
    nodesize = ALIGNED_SIZE(uv_utf8_to_utf16(node, NULL, 0) * sizeof(wchar_t));
    if (nodesize == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
  }

  if (service != NULL) {
    servicesize = ALIGNED_SIZE(uv_utf8_to_utf16(service, NULL, 0) *
                               sizeof(wchar_t));
    if (servicesize == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
  }
  if (hints != NULL) {
    hintssize = ALIGNED_SIZE(sizeof(struct addrinfoW));
  }

  /* allocate memory for inputs, and partition it as needed */
  alloc_ptr = (char*)malloc(nodesize + servicesize + hintssize);
  if (!alloc_ptr) {
    uv__set_sys_error(loop, WSAENOBUFS);
    goto error;
  }

  /* save alloc_ptr now so we can free if error */
  handle->alloc = (void*)alloc_ptr;

  /* convert node string to UTF16 into allocated memory and save pointer in */
  /* handle */
  if (node != NULL) {
    handle->node = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(node,
                         (wchar_t*) alloc_ptr,
                         nodesize / sizeof(wchar_t)) == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
    alloc_ptr += nodesize;
  } else {
    handle->node = NULL;
  }

  /* convert service string to UTF16 into allocated memory and save pointer */
  /* in handle */
  if (service != NULL) {
    handle->service = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(service,
                         (wchar_t*) alloc_ptr,
                         servicesize / sizeof(wchar_t)) == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
    alloc_ptr += servicesize;
  } else {
    handle->service = NULL;
  }

  /* copy hints to allocated memory and save pointer in handle */
  if (hints != NULL) {
    handle->hints = (struct addrinfoW*)alloc_ptr;
    handle->hints->ai_family = hints->ai_family;
    handle->hints->ai_socktype = hints->ai_socktype;
    handle->hints->ai_protocol = hints->ai_protocol;
    handle->hints->ai_flags = hints->ai_flags;
    handle->hints->ai_addrlen = 0;
    handle->hints->ai_canonname = NULL;
    handle->hints->ai_addr = NULL;
    handle->hints->ai_next = NULL;
  } else {
    handle->hints = NULL;
  }

  /* init request for Post handling */
  uv_req_init(loop, &handle->getadddrinfo_req);
  handle->getadddrinfo_req.data = handle;
  handle->getadddrinfo_req.type = UV_GETADDRINFO_REQ;

  /* Ask thread to run. Treat this as a long operation */
  if (QueueUserWorkItem(&getaddrinfo_thread_proc,
                        handle,
                        WT_EXECUTELONGFUNCTION) == 0) {
    uv__set_sys_error(loop, GetLastError());
    goto error;
  }

  uv_ref(loop);

  return 0;

error:
  if (handle != NULL && handle->alloc != NULL) {
    free(handle->alloc);
  }
  return -1;
}
Function: 
pub fn getaddrinfo(&mut self, loop_: &Loop, node: Option<&str>,
                       service: Option<&str>, hints: Option<ai::Hint>,
                       cb: GetAddrInfoCallback) {

        assert!(node.is_some() || service.is_some());

        let (c_node, c_node_ptr) = match node {
            Some(n) => {
                let c_node = n.to_c_str();
                let c_node_ptr = c_node.with_ref(|r| r);
                (Some(c_node), c_node_ptr)
            }
            None => (None, null())
        };

        let (c_service, c_service_ptr) = match service {
            Some(s) => {
                let c_service = s.to_c_str();
                let c_service_ptr = c_service.with_ref(|r| r);
                (Some(c_service), c_service_ptr)
            }
            None => (None, null())
        };

        let cb = Cell::new(cb);
        let wrapper_cb: GetAddrInfoCallback = |req, addrinfo, err| {
            // Capture some heap values that need to stay alive for the
            // getaddrinfo call
            let _ = &c_node;
            let _ = &c_service;

            let cb = cb.take();
            cb(req, addrinfo, err)
        };

        let hint = hints.map(|hint| {
            let mut flags = 0;
            do each_ai_flag |cval, aival| {
                if hint.flags & (aival as uint) != 0 {
                    flags |= cval as i32;
                }
            }
            /* XXX: do we really want to support these?
            let socktype = match hint.socktype {
                Some(ai::Stream) => uvll::rust_SOCK_STREAM(),
                Some(ai::Datagram) => uvll::rust_SOCK_DGRAM(),
                Some(ai::Raw) => uvll::rust_SOCK_RAW(),
                None => 0,
            };
            let protocol = match hint.protocol {
                Some(ai::UDP) => uvll::rust_IPPROTO_UDP(),
                Some(ai::TCP) => uvll::rust_IPPROTO_TCP(),
                _ => 0,
            };
            */
            let socktype = 0;
            let protocol = 0;

            uvll::addrinfo {
                ai_flags: flags,
                ai_family: hint.family as c_int,
                ai_socktype: socktype,
                ai_protocol: protocol,
                ai_addrlen: 0,
                ai_canonname: null(),
                ai_addr: null(),
                ai_next: null(),
            }
        });
        let hint_ptr = hint.as_ref().map_default(null(), |x| x as *uvll::addrinfo);

        self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);

        unsafe {
            assert!(0 == uvll::getaddrinfo(loop_.native_handle(),
                                           self.native_handle(),
                                           getaddrinfo_cb,
                                           c_node_ptr,
                                           c_service_ptr,
                                           hint_ptr));
        }

        extern "C" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,
                                     status: c_int,
                                     res: *uvll::addrinfo) {
            let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);
            let err = status_to_maybe_uv_error(status);
            let addrinfo = net::UvAddrInfo(res);
            let data = req.get_req_data();
            (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);
            unsafe {
                uvll::freeaddrinfo(res);
            }
        }
    }
Unixcoder Score: -0.007907984778285027
--------------------------------------------------
C_Code: 
int uv_getaddrinfo(uv_loop_t* loop,
                   uv_getaddrinfo_t* handle,
                   uv_getaddrinfo_cb getaddrinfo_cb,
                   const char* node,
                   const char* service,
                   const struct addrinfo* hints) {
  int nodesize = 0;
  int servicesize = 0;
  int hintssize = 0;
  char* alloc_ptr = NULL;

  if (handle == NULL || getaddrinfo_cb == NULL ||
     (node == NULL && service == NULL)) {
    uv__set_sys_error(loop, WSAEINVAL);
    goto error;
  }

  uv_req_init(loop, (uv_req_t*)handle);

  handle->getaddrinfo_cb = getaddrinfo_cb;
  handle->res = NULL;
  handle->type = UV_GETADDRINFO;
  handle->loop = loop;

  /* calculate required memory size for all input values */
  if (node != NULL) {
    nodesize = ALIGNED_SIZE(uv_utf8_to_utf16(node, NULL, 0) * sizeof(wchar_t));
    if (nodesize == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
  }

  if (service != NULL) {
    servicesize = ALIGNED_SIZE(uv_utf8_to_utf16(service, NULL, 0) *
                               sizeof(wchar_t));
    if (servicesize == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
  }
  if (hints != NULL) {
    hintssize = ALIGNED_SIZE(sizeof(struct addrinfoW));
  }

  /* allocate memory for inputs, and partition it as needed */
  alloc_ptr = (char*)malloc(nodesize + servicesize + hintssize);
  if (!alloc_ptr) {
    uv__set_sys_error(loop, WSAENOBUFS);
    goto error;
  }

  /* save alloc_ptr now so we can free if error */
  handle->alloc = (void*)alloc_ptr;

  /* convert node string to UTF16 into allocated memory and save pointer in */
  /* handle */
  if (node != NULL) {
    handle->node = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(node,
                         (wchar_t*) alloc_ptr,
                         nodesize / sizeof(wchar_t)) == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
    alloc_ptr += nodesize;
  } else {
    handle->node = NULL;
  }

  /* convert service string to UTF16 into allocated memory and save pointer */
  /* in handle */
  if (service != NULL) {
    handle->service = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(service,
                         (wchar_t*) alloc_ptr,
                         servicesize / sizeof(wchar_t)) == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
    alloc_ptr += servicesize;
  } else {
    handle->service = NULL;
  }

  /* copy hints to allocated memory and save pointer in handle */
  if (hints != NULL) {
    handle->hints = (struct addrinfoW*)alloc_ptr;
    handle->hints->ai_family = hints->ai_family;
    handle->hints->ai_socktype = hints->ai_socktype;
    handle->hints->ai_protocol = hints->ai_protocol;
    handle->hints->ai_flags = hints->ai_flags;
    handle->hints->ai_addrlen = 0;
    handle->hints->ai_canonname = NULL;
    handle->hints->ai_addr = NULL;
    handle->hints->ai_next = NULL;
  } else {
    handle->hints = NULL;
  }

  /* init request for Post handling */
  uv_req_init(loop, &handle->getadddrinfo_req);
  handle->getadddrinfo_req.data = handle;
  handle->getadddrinfo_req.type = UV_GETADDRINFO_REQ;

  /* Ask thread to run. Treat this as a long operation */
  if (QueueUserWorkItem(&getaddrinfo_thread_proc,
                        handle,
                        WT_EXECUTELONGFUNCTION) == 0) {
    uv__set_sys_error(loop, GetLastError());
    goto error;
  }

  uv_ref(loop);

  return 0;

error:
  if (handle != NULL && handle->alloc != NULL) {
    free(handle->alloc);
  }
  return -1;
}
Function: 
pub unsafe fn getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,
               getaddrinfo_cb: uv_getaddrinfo_cb,
               node: *c_char, service: *c_char,
               hints: *addrinfo) -> c_int {
    #[fixed_stack_segment]; #[inline(never)];
    return rust_uv_getaddrinfo(loop_, req, getaddrinfo_cb, node, service, hints);
}
Unixcoder Score: -0.017902730032801628
--------------------------------------------------
C_Code: 
int uv_getaddrinfo(uv_loop_t* loop,
                   uv_getaddrinfo_t* handle,
                   uv_getaddrinfo_cb getaddrinfo_cb,
                   const char* node,
                   const char* service,
                   const struct addrinfo* hints) {
  int nodesize = 0;
  int servicesize = 0;
  int hintssize = 0;
  char* alloc_ptr = NULL;

  if (handle == NULL || getaddrinfo_cb == NULL ||
     (node == NULL && service == NULL)) {
    uv__set_sys_error(loop, WSAEINVAL);
    goto error;
  }

  uv_req_init(loop, (uv_req_t*)handle);

  handle->getaddrinfo_cb = getaddrinfo_cb;
  handle->res = NULL;
  handle->type = UV_GETADDRINFO;
  handle->loop = loop;

  /* calculate required memory size for all input values */
  if (node != NULL) {
    nodesize = ALIGNED_SIZE(uv_utf8_to_utf16(node, NULL, 0) * sizeof(wchar_t));
    if (nodesize == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
  }

  if (service != NULL) {
    servicesize = ALIGNED_SIZE(uv_utf8_to_utf16(service, NULL, 0) *
                               sizeof(wchar_t));
    if (servicesize == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
  }
  if (hints != NULL) {
    hintssize = ALIGNED_SIZE(sizeof(struct addrinfoW));
  }

  /* allocate memory for inputs, and partition it as needed */
  alloc_ptr = (char*)malloc(nodesize + servicesize + hintssize);
  if (!alloc_ptr) {
    uv__set_sys_error(loop, WSAENOBUFS);
    goto error;
  }

  /* save alloc_ptr now so we can free if error */
  handle->alloc = (void*)alloc_ptr;

  /* convert node string to UTF16 into allocated memory and save pointer in */
  /* handle */
  if (node != NULL) {
    handle->node = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(node,
                         (wchar_t*) alloc_ptr,
                         nodesize / sizeof(wchar_t)) == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
    alloc_ptr += nodesize;
  } else {
    handle->node = NULL;
  }

  /* convert service string to UTF16 into allocated memory and save pointer */
  /* in handle */
  if (service != NULL) {
    handle->service = (wchar_t*)alloc_ptr;
    if (uv_utf8_to_utf16(service,
                         (wchar_t*) alloc_ptr,
                         servicesize / sizeof(wchar_t)) == 0) {
      uv__set_sys_error(loop, GetLastError());
      goto error;
    }
    alloc_ptr += servicesize;
  } else {
    handle->service = NULL;
  }

  /* copy hints to allocated memory and save pointer in handle */
  if (hints != NULL) {
    handle->hints = (struct addrinfoW*)alloc_ptr;
    handle->hints->ai_family = hints->ai_family;
    handle->hints->ai_socktype = hints->ai_socktype;
    handle->hints->ai_protocol = hints->ai_protocol;
    handle->hints->ai_flags = hints->ai_flags;
    handle->hints->ai_addrlen = 0;
    handle->hints->ai_canonname = NULL;
    handle->hints->ai_addr = NULL;
    handle->hints->ai_next = NULL;
  } else {
    handle->hints = NULL;
  }

  /* init request for Post handling */
  uv_req_init(loop, &handle->getadddrinfo_req);
  handle->getadddrinfo_req.data = handle;
  handle->getadddrinfo_req.type = UV_GETADDRINFO_REQ;

  /* Ask thread to run. Treat this as a long operation */
  if (QueueUserWorkItem(&getaddrinfo_thread_proc,
                        handle,
                        WT_EXECUTELONGFUNCTION) == 0) {
    uv__set_sys_error(loop, GetLastError());
    goto error;
  }

  uv_ref(loop);

  return 0;

error:
  if (handle != NULL && handle->alloc != NULL) {
    free(handle->alloc);
  }
  return -1;
}
Function: 
pub fn getaddrinfo(&mut self, loop_: &Loop, node: Option<&str>,
                       service: Option<&str>, hints: Option<UvAddrInfo>,
                       cb: GetAddrInfoCallback) {

        assert!(node.is_some() || service.is_some());

        let (c_node, c_node_ptr) = match node {
            Some(n) => {
                let c_node = n.to_c_str();
                let c_node_ptr = c_node.with_ref(|r| r);
                (Some(c_node), c_node_ptr)
            }
            None => (None, null())
        };

        let (c_service, c_service_ptr) = match service {
            Some(s) => {
                let c_service = s.to_c_str();
                let c_service_ptr = c_service.with_ref(|r| r);
                (Some(c_service), c_service_ptr)
            }
            None => (None, null())
        };

        let cb = Cell::new(cb);
        let wrapper_cb: GetAddrInfoCallback = |req, addrinfo, err| {
            // Capture some heap values that need to stay alive for the
            // getaddrinfo call
            let _ = &c_node;
            let _ = &c_service;

            let cb = cb.take();
            cb(req, addrinfo, err)
        };

        // XXX: Implement hints
        assert!(hints.is_none());

        self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);

        unsafe {
            assert!(0 == uvll::getaddrinfo(loop_.native_handle(),
                                           self.native_handle(),
                                           getaddrinfo_cb,
                                           c_node_ptr,
                                           c_service_ptr,
                                           null()));
        }

        extern "C" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,
                                     status: c_int,
                                     res: *uvll::addrinfo) {
            let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);
            let loop_ = req.get_loop();
            let err = status_to_maybe_uv_error_with_loop(loop_.native_handle(), status);
            let addrinfo = UvAddrInfo(res);
            let data = req.get_req_data();
            (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);
            unsafe {
                uvll::freeaddrinfo(res);
            }
        }
    }
Unixcoder Score: -0.018873048946261406
--------------------------------------------------
C_Code: 
struct TraversalInfo {
    ConstructInfo cinfo;
    uint32_t merge_node;
    uint32_t continue_node;
  }
Function: 
struct DispatchInfo {
        use_large_path_scan: bool,

        // Dispatch workgroup counts for each pipeline
        path_reduce: WorkgroupSize,
        path_reduce2: WorkgroupSize,
        path_scan1: WorkgroupSize,
        path_scan: WorkgroupSize,
        bbox_clear: WorkgroupSize,
        flatten: WorkgroupSize,
        draw_reduce: WorkgroupSize,
        draw_leaf: WorkgroupSize,
        clip_reduce: WorkgroupSize,
        clip_leaf: WorkgroupSize,
        binning: WorkgroupSize,
        tile_alloc: WorkgroupSize,
        path_count_setup: WorkgroupSize,
        // Note: `path_count` must use an indirect dispatch
        backdrop: WorkgroupSize,
        coarse: WorkgroupSize,
        path_tiling_setup: WorkgroupSize,
        // Note: `path_tiling` must use an indirect dispatch
        fine: WorkgroupSize,
    }
Unixcoder Score: -0.019046738743782043
--------------------------------------------------
C_Code: 
bool CloudInfo::Unmarshal(const Serializable::json &node)
{
    GetValue(node, GET_NAME(user), user);
    GetValue(node, GET_NAME(id), id);
    GetValue(node, GET_NAME(totalSpace), totalSpace);
    GetValue(node, GET_NAME(remainSpace), remainSpace);
    GetValue(node, GET_NAME(enableCloud), enableCloud);
    GetValue(node, GET_NAME(apps), apps);
    if (!GetValue(node, GET_NAME(maxNumber), maxNumber) || maxNumber == 0) {
        maxNumber = DEFAULT_BATCH_NUMBER;
    }
    if (!GetValue(node, GET_NAME(maxSize), maxSize) || maxSize == 0) {
        maxSize = DEFAULT_BATCH_SIZE;
    }
    return true;
}
Function: 
fn from(value: &ipc_conn::ServiceInfo) -> Self {
        CloudInfo {
            user: value.user,
            id: value.account_id.clone(),
            total_space: value.total_space,
            remain_space: value.remain_space,
            enable_cloud: value.enable_cloud,
            apps: Default::default(),
        }
    }
Unixcoder Score: -0.019175907596945763
--------------------------------------------------
