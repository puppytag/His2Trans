C_Code: 
int main(int argc, char **argv) {
  if (argc == 2 && strcmp(argv[1], "-v") == 0) {
    verbose = 1;
  } else {
    verbose = 0;
  }
  int ret = 0;
  struct node *tmp;
  memset(pushback, '\0', PUSHBACK_LEN);
  ret = rsparse();
  print("--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\n", ret, n_nodes);
  if (nodes) {
    print_node(nodes, 0);
  }
  while (nodes) {
    tmp = nodes;
    nodes = tmp->next;
    if (tmp->own_string) {
      free((void*)tmp->name);
    }
    free(tmp);
  }
  return ret;
}
Function: 
pub fn visit_mod<E:Clone>(m: &_mod,
                          _sp: span,
                          _id: NodeId,
                          (e, v): (E, vt<E>)) {
    for m.view_items.iter().advance |vi| {
        (v.visit_view_item)(vi, (e.clone(), v));
    }
    for m.items.iter().advance |i| {
        (v.visit_item)(*i, (e.clone(), v));
    }
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__main__idx131047_rank3.c", "source_rust_file": "API_Mapping__main__idx131047_rank3.rs", "c_api": "while (nodes) { tmp = nodes; nodes = tmp->next; ... }", "rust_api": "for m.items.iter().advance |i| { ... }", "mapping_type": "pattern", "description": "Iterating over a linked list structure in C and iterating over a collection in Rust", "reasoning": "[Task Analysis] C code is a main function handling command-line args, parsing, and memory cleanup; Rust code is a visitor function iterating over AST nodes. [Similarity] No structural similarity at the function level due to different domains (CLI parsing vs AST traversal). [Knowledge Extraction] No full match, no partial match, but there are API mappings between loop iteration patterns and memory management patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__main__idx131047_rank3.c", "source_rust_file": "API_Mapping__main__idx131047_rank3.rs", "c_api": "free((void*)tmp->name); free(tmp);", "rust_api": "(v.visit_item)(*i, (e.clone(), v));", "mapping_type": "pattern", "description": "Memory deallocation in C and recursive visitation in Rust", "reasoning": "[Task Analysis] C code is a main function handling command-line args, parsing, and memory cleanup; Rust code is a visitor function iterating over AST nodes. [Similarity] No structural similarity at the function level due to different domains (CLI parsing vs AST traversal). [Knowledge Extraction] No full match, no partial match, but there are API mappings between loop iteration patterns and memory management patterns."}]
Unixcoder Score: 0.008859550580382347
--------------------------------------------------
C_Code: 
struct pointer_t {
        node_t *node;
        uint32_t count;
        pointer_t() : node(NULL), count(0) {
        }
        pointer_t(node_t *node, uint32_t count) {
            this->node = node;
            this->count = count;
        }
        bool equals(pointer_t &other) {
            return node == other.node && count == other.count;
        }
    };

    struct node_t {
        T value;
        pointer_t next;

        node_t() {
            next.node = NULL;
            next.count = 0;
        }

        node_t(pointer_t next, T value) {
            this->next = next;
            this->value = value;
        }
    };

    // Always points to the first node in the list.
    pointer_t head;

    // Always points to a node in the list, (not necessarily the last).
    pointer_t tail;

    // Compare and swap counted pointers, we can only do this if pointr_t is
    // 8 bytes or less since that the maximum size CAS can handle.
    bool compare_and_swap(pointer_t *address,
        pointer_t *oldValue,
        pointer_t newValue) {

        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing
        // to GCC (possibly there are other, similar problems)
        if (sync::compare_and_swap(
                (uint64_t*) address,
                *(uint64_t*) oldValue,
                *(uint64_t*) &newValue)) {
            return true;
        }
        return false;
    }

public:
    lock_free_queue() {
        // We can only handle 64bit CAS for counted pointers, so this will
        // not work with 64bit pointers.
        assert (sizeof(pointer_t) == sizeof(uint64_t));

        // Allocate a dummy node to be used as the first node in the list.
        node_t *node = new node_t();

        // Head and tail both start out pointing to the dummy node.
        head.node = node;
        tail.node = node;
    }

    virtual ~lock_free_queue() {
        // Delete dummy node.
        delete head.node;
    }
Function: 
pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {
        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {
            Ok(x) => x,
            Err(x) => x,
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__lock_free_queue__idx119477_rank2.h", "source_rust_file": "API_Mapping__lock_free_queue__idx119477_rank2.rs", "c_api": "pointer_t::equals", "rust_api": "fn eq(&self, other: &Self) -> bool", "mapping_type": "function", "description": "Pointer equality comparison", "reasoning": "[Task Analysis] C code defines a lock-free queue with counted pointers and CAS operations; Rust code shows a single method for pointer equality comparison. [Similarity] No structural similarity at the function level; C has complex memory management and concurrency logic while Rust has a simple equality check. [Knowledge Extraction] No full match, no partial match, but there is a potential API mapping for pointer equality comparison."}]
Unixcoder Score: -0.04668222740292549
--------------------------------------------------
C_Code: 
bool Database::Marshal(Serializable::json &node) const
{
    SetValue(node[GET_NAME(name)], name);
    SetValue(node[GET_NAME(alias)], alias);
    SetValue(node[GET_NAME(tables)], tables);
    SetValue(node[GET_NAME(version)], version);
    SetValue(node[GET_NAME(bundleName)], bundleName);
    SetValue(node[GET_NAME(user)], user);
    SetValue(node[GET_NAME(deviceId)], deviceId);
    SetValue(node[GET_NAME(autoSyncType)], autoSyncType);
    return true;
}
Function: 
fn try_from(value: &Database) -> Result<Self, SyncError> {
        let mut tables = vec![];
        for table in value.tables.values() {
            tables.push(table.try_into()?);
        }

        Ok(ipc_conn::Database {
            name: value.name.clone(),
            alias: value.alias.to_string(),
            tables: ipc_conn::SchemaOrderTables(tables),
        })
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5178_rank1.c", "source_rust_file": "Partial__Marshal__idx5178_rank1.rs", "c_api": "SetValue(node[GET_NAME(alias)], alias)", "rust_api": "alias: value.alias.to_string()", "mapping_type": "field_access", "description": "Copying a field value from source to destination.", "reasoning": "[Task Analysis] C code is a marshaling function that serializes database fields into a JSON node; Rust code is a conversion function that builds an IPC-compatible struct from a Database. [Similarity] Names don't match exactly but both perform data transformation/serialization logic. [Knowledge Extraction] Full match blocked due to different domains (JSON serialization vs IPC struct building), but partial structural fragments and API mappings can be extracted."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5178_rank1.c", "source_rust_file": "Partial__Marshal__idx5178_rank1.rs", "c_fragment": "SetValue(node[GET_NAME(name)], name);\n    SetValue(node[GET_NAME(alias)], alias);\n    SetValue(node[GET_NAME(tables)], tables);\n    SetValue(node[GET_NAME(version)], version);\n    SetValue(node[GET_NAME(bundleName)], bundleName);\n    SetValue(node[GET_NAME(user)], user);\n    SetValue(node[GET_NAME(deviceId)], deviceId);\n    SetValue(node[GET_NAME(autoSyncType)], autoSyncType);", "rust_fragment": "let mut tables = vec![];\n        for table in value.tables.values() {\n            tables.push(table.try_into()?);\n        }\n\n        Ok(ipc_conn::Database {\n            name: value.name.clone(),\n            alias: value.alias.to_string(),\n            tables: ipc_conn::SchemaOrderTables(tables),\n        })", "description": "Both perform field-by-field data copying/mapping from source to destination, though in different formats (JSON vs struct).", "reasoning": "[Task Analysis] C code is a marshaling function that serializes database fields into a JSON node; Rust code is a conversion function that builds an IPC-compatible struct from a Database. [Similarity] Names don't match exactly but both perform data transformation/serialization logic. [Knowledge Extraction] Full match blocked due to different domains (JSON serialization vs IPC struct building), but partial structural fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5178_rank1.c", "source_rust_file": "Partial__Marshal__idx5178_rank1.rs", "c_api": "SetValue(node[GET_NAME(tables)], tables)", "rust_api": "tables: ipc_conn::SchemaOrderTables(tables)", "mapping_type": "field_access", "description": "Mapping a collection field from source to destination with transformation.", "reasoning": "[Task Analysis] C code is a marshaling function that serializes database fields into a JSON node; Rust code is a conversion function that builds an IPC-compatible struct from a Database. [Similarity] Names don't match exactly but both perform data transformation/serialization logic. [Knowledge Extraction] Full match blocked due to different domains (JSON serialization vs IPC struct building), but partial structural fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5178_rank1.c", "source_rust_file": "Partial__Marshal__idx5178_rank1.rs", "c_api": "SetValue(node[GET_NAME(name)], name)", "rust_api": "name: value.name.clone()", "mapping_type": "field_access", "description": "Copying a field value from source to destination.", "reasoning": "[Task Analysis] C code is a marshaling function that serializes database fields into a JSON node; Rust code is a conversion function that builds an IPC-compatible struct from a Database. [Similarity] Names don't match exactly but both perform data transformation/serialization logic. [Knowledge Extraction] Full match blocked due to different domains (JSON serialization vs IPC struct building), but partial structural fragments and API mappings can be extracted."}]
Unixcoder Score: -0.04760586842894554
--------------------------------------------------
C_Code: 
struct pointer_t {
        node_t *node;
        uint32_t count;
        pointer_t() : node(NULL), count(0) {
        }
        pointer_t(node_t *node, uint32_t count) {
            this->node = node;
            this->count = count;
        }
        bool equals(pointer_t &other) {
            return node == other.node && count == other.count;
        }
    };

    struct node_t {
        T value;
        pointer_t next;

        node_t() {
            next.node = NULL;
            next.count = 0;
        }

        node_t(pointer_t next, T value) {
            this->next = next;
            this->value = value;
        }
    };

    // Always points to the first node in the list.
    pointer_t head;

    // Always points to a node in the list, (not necessarily the last).
    pointer_t tail;

    // Compare and swap counted pointers, we can only do this if pointr_t is
    // 8 bytes or less since that the maximum size CAS can handle.
    bool compare_and_swap(pointer_t *address,
        pointer_t *oldValue,
        pointer_t newValue) {

        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing
        // to GCC (possibly there are other, similar problems)
        if (sync::compare_and_swap(
                (uint64_t*) address,
                *(uint64_t*) oldValue,
                *(uint64_t*) &newValue)) {
            return true;
        }
        return false;
    }

public:
    lock_free_queue() {
        // We can only handle 64bit CAS for counted pointers, so this will
        // not work with 64bit pointers.
        assert (sizeof(pointer_t) == sizeof(uint64_t));

        // Allocate a dummy node to be used as the first node in the list.
        node_t *node = new node_t();

        // Head and tail both start out pointing to the dummy node.
        head.node = node;
        tail.node = node;
    }

    virtual ~lock_free_queue() {
        // Delete dummy node.
        delete head.node;
    }
Function: 
unsafe fn push_back_node(&mut self, node: Unique<Node<T>>) {
        // This method takes care not to create mutable references to whole nodes,
        // to maintain validity of aliasing pointers into `element`.
        unsafe {
            (*node.as_ptr()).next = None;
            (*node.as_ptr()).prev = self.tail;
            let node = Some(NonNull::from(node));

            match self.tail {
                None => self.head = node,
                // Not creating new mutable (unique!) references overlapping `element`.
                Some(tail) => (*tail.as_ptr()).next = node,
            }

            self.tail = node;
            self.len += 1;
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__lock_free_queue__idx140373_rank2.h", "source_rust_file": "Partial__lock_free_queue__idx140373_rank2.rs", "c_api": "pointer_t *address,\n        pointer_t *oldValue,\n        pointer_t newValue", "rust_api": "sync::compare_and_swap(\n                (uint64_t*) address,\n                *(uint64_t*) oldValue,\n                *(uint64_t*) &newValue)", "mapping_type": "function", "description": "Compare-and-swap operation for atomic updates of counted pointers in C and Rust.", "reasoning": "[Task Analysis] C code defines a lock-free queue with counted pointers and CAS operations; Rust code performs unsafe traversal and linking of nodes to find a tail. [Similarity] No full structural similarity due to different domains (memory management vs traversal/linking), different data structures (C-style linked list with counted pointers vs Rust-style node with prev/next/tail), and different control flow. [Knowledge Extraction] Extract partial structural fragments and API mappings based on shared logic patterns like pointer traversal and node linking, but not full equivalence."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__lock_free_queue__idx140373_rank2.h", "source_rust_file": "Partial__lock_free_queue__idx140373_rank2.rs", "c_api": "node_t *node = new node_t();", "rust_api": "let next = c.next.get().unwrap_unchecked();", "mapping_type": "function", "description": "Node allocation in C and node access in Rust, both representing creation/access of nodes in a linked list.", "reasoning": "[Task Analysis] C code defines a lock-free queue with counted pointers and CAS operations; Rust code performs unsafe traversal and linking of nodes to find a tail. [Similarity] No full structural similarity due to different domains (memory management vs traversal/linking), different data structures (C-style linked list with counted pointers vs Rust-style node with prev/next/tail), and different control flow. [Knowledge Extraction] Extract partial structural fragments and API mappings based on shared logic patterns like pointer traversal and node linking, but not full equivalence."}, {"knowledge_type": "Partial", "source_c_file": "Partial__lock_free_queue__idx140373_rank2.h", "source_rust_file": "Partial__lock_free_queue__idx140373_rank2.rs", "c_fragment": "node_t *node = new node_t();\n\n        // Head and tail both start out pointing to the dummy node.\n        head.node = node;\n        tail.node = node;", "rust_fragment": "unsafe {\n        head.as_ref().tail.set(Some(tail));\n        tail\n    }", "description": "Both initialize a dummy node and set up initial head/tail pointers, though Rust uses unsafe operations to set the tail field.", "reasoning": "[Task Analysis] C code defines a lock-free queue with counted pointers and CAS operations; Rust code performs unsafe traversal and linking of nodes to find a tail. [Similarity] No full structural similarity due to different domains (memory management vs traversal/linking), different data structures (C-style linked list with counted pointers vs Rust-style node with prev/next/tail), and different control flow. [Knowledge Extraction] Extract partial structural fragments and API mappings based on shared logic patterns like pointer traversal and node linking, but not full equivalence."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__lock_free_queue__idx140373_rank2.h", "source_rust_file": "Partial__lock_free_queue__idx140373_rank2.rs", "c_api": "head.node = node;\n        tail.node = node;", "rust_api": "unsafe { current.as_ref() };", "mapping_type": "pattern", "description": "Initialization of head/tail pointers in C and dereferencing of node in Rust.", "reasoning": "[Task Analysis] C code defines a lock-free queue with counted pointers and CAS operations; Rust code performs unsafe traversal and linking of nodes to find a tail. [Similarity] No full structural similarity due to different domains (memory management vs traversal/linking), different data structures (C-style linked list with counted pointers vs Rust-style node with prev/next/tail), and different control flow. [Knowledge Extraction] Extract partial structural fragments and API mappings based on shared logic patterns like pointer traversal and node linking, but not full equivalence."}, {"knowledge_type": "Partial", "source_c_file": "Partial__lock_free_queue__idx140373_rank2.h", "source_rust_file": "Partial__lock_free_queue__idx140373_rank2.rs", "c_fragment": "pointer_t head;\n\n    // Always points to a node in the list, (not necessarily the last).\n    pointer_t tail;", "rust_fragment": "let mut current = head;\n    let tail = loop {", "description": "Both represent pointers to nodes in a linked list, with one tracking the head and another tracking a position (tail) in the list.", "reasoning": "[Task Analysis] C code defines a lock-free queue with counted pointers and CAS operations; Rust code performs unsafe traversal and linking of nodes to find a tail. [Similarity] No full structural similarity due to different domains (memory management vs traversal/linking), different data structures (C-style linked list with counted pointers vs Rust-style node with prev/next/tail), and different control flow. [Knowledge Extraction] Extract partial structural fragments and API mappings based on shared logic patterns like pointer traversal and node linking, but not full equivalence."}]
Unixcoder Score: -0.05378670617938042
--------------------------------------------------
C_Code: 
bool Database::Unmarshal(const Serializable::json &node)
{
    GetValue(node, GET_NAME(name), name);
    GetValue(node, GET_NAME(alias), alias);
    GetValue(node, GET_NAME(tables), tables);
    GetValue(node, GET_NAME(dbName), name);
    GetValue(node, GET_NAME(autoSyncType), autoSyncType);
    GetValue(node, GET_NAME(user), user);
    GetValue(node, GET_NAME(deviceId), deviceId);
    GetValue(node, GET_NAME(version), version);
    GetValue(node, GET_NAME(bundleName), bundleName);
    return true;
}
Function: 
pub fn new(name: String, alias: String, tables: HashMap<String, Table>) -> Database {
        Database {
            name,
            alias,
            tables,
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_api": "SetValue(node[GET_NAME(fields)], fields)", "rust_api": "typ: ipc_conn::FieldType::try_from(value.typ)?", "mapping_type": "pattern", "description": "Field assignment with type conversion in data transformation", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_api": "SetValue(node[GET_NAME(name)], name)", "rust_api": "col_name: value.col_name.clone()", "mapping_type": "pattern", "description": "Field assignment with cloning in data transformation", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_api": "SetValue(node[GET_NAME(alias)], alias)", "rust_api": "alias: value.alias.clone()", "mapping_type": "pattern", "description": "Field assignment with cloning in data transformation", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_fragment": "SetValue(node[GET_NAME(fields)], fields);", "rust_fragment": "typ: ipc_conn::FieldType::try_from(value.typ)?,", "description": "Copying a type field from source to destination with conversion.", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_fragment": "SetValue(node[GET_NAME(name)], name);", "rust_fragment": "col_name: value.col_name.clone(),", "description": "Copying a field value from source to destination in a data structure.", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5190_rank4.c", "source_rust_file": "Partial__Marshal__idx5190_rank4.rs", "c_fragment": "SetValue(node[GET_NAME(alias)], alias);", "rust_fragment": "alias: value.alias.clone(),", "description": "Copying an alias field from source to destination in a data structure.", "reasoning": "[Task Analysis] C function 'Table::Marshal' serializes table data into a JSON node, while Rust function 'try_from' converts a Field into an ipc_conn::Field. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both involve data transformation and field copying. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted based on field copying logic and data transformation patterns."}]
Unixcoder Score: -0.053952302783727646
--------------------------------------------------
C_Code: 
bool Table::Marshal(Serializable::json &node) const
{
    SetValue(node[GET_NAME(name)], name);
    SetValue(node[GET_NAME(sharedTableName)], sharedTableName);
    SetValue(node[GET_NAME(alias)], alias);
    SetValue(node[GET_NAME(fields)], fields);
    SetValue(node[GET_NAME(deviceSyncFields)], deviceSyncFields);
    SetValue(node[GET_NAME(cloudSyncFields)], cloudSyncFields);
    return true;
}
Function: 
fn from(value: &ipc_conn::OrderTable) -> Self {
        let mut fields = vec![];
        for fd in &value.fields.0 {
            fields.push(Field::from(fd));
        }
        Table {
            name: value.table_name.clone(),
            alias: value.alias.clone(),
            fields,
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__Unmarshal__idx5187_rank4.c", "source_rust_file": "Partial__Unmarshal__idx5187_rank4.rs", "c_fragment": "for fd in &value.fields.0 {\n            fields.push(Field::from(fd));\n        }", "rust_fragment": "GetValue(node, GET_NAME(fields), fields);", "description": "Both iterate over a collection and populate a target field.", "reasoning": "[Task Analysis] C function processes JSON deserialization, Rust function converts IPC struct to Table. [Similarity] Names don't match but both perform data extraction/translation. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for field assignment."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5187_rank4.c", "source_rust_file": "Partial__Unmarshal__idx5187_rank4.rs", "c_api": "GetValue(node, GET_NAME(name), name)", "rust_api": "name: value.table_name.clone()", "mapping_type": "field_access", "description": "Extracts and assigns a string field from JSON to struct field.", "reasoning": "[Task Analysis] C function processes JSON deserialization, Rust function converts IPC struct to Table. [Similarity] Names don't match but both perform data extraction/translation. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for field assignment."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5187_rank4.c", "source_rust_file": "Partial__Unmarshal__idx5187_rank4.rs", "c_api": "GetValue(node, GET_NAME(fields), fields)", "rust_api": "fields.push(Field::from(fd))", "mapping_type": "pattern", "description": "Populates a collection with transformed elements from source.", "reasoning": "[Task Analysis] C function processes JSON deserialization, Rust function converts IPC struct to Table. [Similarity] Names don't match but both perform data extraction/translation. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for field assignment."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5187_rank4.c", "source_rust_file": "Partial__Unmarshal__idx5187_rank4.rs", "c_api": "GetValue(node, GET_NAME(alias), alias)", "rust_api": "alias: value.alias.clone()", "mapping_type": "field_access", "description": "Extracts and assigns a string field from JSON to struct field.", "reasoning": "[Task Analysis] C function processes JSON deserialization, Rust function converts IPC struct to Table. [Similarity] Names don't match but both perform data extraction/translation. [Knowledge Extraction] Found partial structural match in loop logic and API mapping for field assignment."}]
Unixcoder Score: -0.06232215836644173
--------------------------------------------------
C_Code: 
struct pointer_t {
        node_t *node;
        uint32_t count;
        pointer_t() : node(NULL), count(0) {
        }
        pointer_t(node_t *node, uint32_t count) {
            this->node = node;
            this->count = count;
        }
        bool equals(pointer_t &other) {
            return node == other.node && count == other.count;
        }
    };

    struct node_t {
        T value;
        pointer_t next;

        node_t() {
            next.node = NULL;
            next.count = 0;
        }

        node_t(pointer_t next, T value) {
            this->next = next;
            this->value = value;
        }
    };

    // Always points to the first node in the list.
    pointer_t head;

    // Always points to a node in the list, (not necessarily the last).
    pointer_t tail;

    // Compare and swap counted pointers, we can only do this if pointr_t is
    // 8 bytes or less since that the maximum size CAS can handle.
    bool compare_and_swap(pointer_t *address,
        pointer_t *oldValue,
        pointer_t newValue) {

        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing
        // to GCC (possibly there are other, similar problems)
        if (sync::compare_and_swap(
                (uint64_t*) address,
                *(uint64_t*) oldValue,
                *(uint64_t*) &newValue)) {
            return true;
        }
        return false;
    }

public:
    lock_free_queue() {
        // We can only handle 64bit CAS for counted pointers, so this will
        // not work with 64bit pointers.
        assert (sizeof(pointer_t) == sizeof(uint64_t));

        // Allocate a dummy node to be used as the first node in the list.
        node_t *node = new node_t();

        // Head and tail both start out pointing to the dummy node.
        head.node = node;
        tail.node = node;
    }

    virtual ~lock_free_queue() {
        // Delete dummy node.
        delete head.node;
    }
Function: 
pub fn new() -> Queue<T> {
        Queue {
            head: atomics::AtomicUint::new(0),
            tail: 0 as *mut Node<T>,
            stub: DummyNode {
                next: atomics::AtomicUint::new(0),
            },
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__lock_free_queue__idx70600_rank1.h", "source_rust_file": "API_Mapping__lock_free_queue__idx70600_rank1.rs", "c_api": "lock_free_queue()", "rust_api": "pub fn new() -> Self", "mapping_type": "function", "description": "Queue initialization logic", "reasoning": "[Task Analysis] C code defines a lock-free queue with counted pointers using C++ structs and memory management; Rust code defines a similar queue with Option-based linked list. [Similarity] Names and domains do not match (C uses raw pointers, C++ structs, malloc/free; Rust uses Option, owned data). [Knowledge Extraction] No full structural match due to domain mismatch and different data structures. However, there are API mappings for queue initialization logic and conceptual equivalence in queue creation patterns."}]
Unixcoder Score: -0.06299349665641785
--------------------------------------------------
C_Code: 
bool Table::Marshal(Serializable::json &node) const
{
    SetValue(node[GET_NAME(name)], name);
    SetValue(node[GET_NAME(sharedTableName)], sharedTableName);
    SetValue(node[GET_NAME(alias)], alias);
    SetValue(node[GET_NAME(fields)], fields);
    SetValue(node[GET_NAME(deviceSyncFields)], deviceSyncFields);
    SetValue(node[GET_NAME(cloudSyncFields)], cloudSyncFields);
    return true;
}
Function: 
fn from(value: &ipc_conn::Database) -> Self {
        let mut tables = HashMap::new();
        for t in &value.tables.0 {
            tables.insert(t.table_name.clone(), Table::from(t));
        }
        Database {
            name: value.name.clone(),
            alias: value.alias.clone(),
            tables,
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5188_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5188_rank2.rs", "c_api": "GetValue(node, GET_NAME(tableName), name)", "rust_api": "value.name.clone()", "mapping_type": "field_access", "description": "Accessing and copying the 'tableName' field from a struct.", "reasoning": "[Task Analysis] C function 'Unmarshal' deserializes JSON into a Table struct; Rust function 'try_from' converts a Table into an OrderTable. [Similarity] Names don't match ('Unmarshal' vs 'try_from'), but both perform data transformation from one format to another. [Knowledge Extraction] No full structural match due to different logic and data flow. Partial match exists in the loop pattern (C: GetValue calls, Rust: for loop over fields). API mappings found for field access and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5188_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5188_rank2.rs", "c_api": "GetValue(node, GET_NAME(sharedTableName), sharedTableName)", "rust_api": "value.shared_table_name", "mapping_type": "field_access", "description": "Accessing the 'sharedTableName' field from a struct.", "reasoning": "[Task Analysis] C function 'Unmarshal' deserializes JSON into a Table struct; Rust function 'try_from' converts a Table into an OrderTable. [Similarity] Names don't match ('Unmarshal' vs 'try_from'), but both perform data transformation from one format to another. [Knowledge Extraction] No full structural match due to different logic and data flow. Partial match exists in the loop pattern (C: GetValue calls, Rust: for loop over fields). API mappings found for field access and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5188_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5188_rank2.rs", "c_api": "GetValue(node, GET_NAME(deviceSyncFields), deviceSyncFields)", "rust_api": "value.device_sync_fields", "mapping_type": "field_access", "description": "Accessing the 'deviceSyncFields' field from a struct.", "reasoning": "[Task Analysis] C function 'Unmarshal' deserializes JSON into a Table struct; Rust function 'try_from' converts a Table into an OrderTable. [Similarity] Names don't match ('Unmarshal' vs 'try_from'), but both perform data transformation from one format to another. [Knowledge Extraction] No full structural match due to different logic and data flow. Partial match exists in the loop pattern (C: GetValue calls, Rust: for loop over fields). API mappings found for field access and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5188_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5188_rank2.rs", "c_api": "GetValue(node, GET_NAME(fields), fields)", "rust_api": "value.fields", "mapping_type": "field_access", "description": "Accessing the 'fields' field from a struct.", "reasoning": "[Task Analysis] C function 'Unmarshal' deserializes JSON into a Table struct; Rust function 'try_from' converts a Table into an OrderTable. [Similarity] Names don't match ('Unmarshal' vs 'try_from'), but both perform data transformation from one format to another. [Knowledge Extraction] No full structural match due to different logic and data flow. Partial match exists in the loop pattern (C: GetValue calls, Rust: for loop over fields). API mappings found for field access and data transformation patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__Unmarshal__idx5188_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5188_rank2.rs", "c_fragment": "for fd in &value.fields", "rust_fragment": "for fd in &value.fields", "description": "Iterating over fields in both C and Rust code.", "reasoning": "[Task Analysis] C function 'Unmarshal' deserializes JSON into a Table struct; Rust function 'try_from' converts a Table into an OrderTable. [Similarity] Names don't match ('Unmarshal' vs 'try_from'), but both perform data transformation from one format to another. [Knowledge Extraction] No full structural match due to different logic and data flow. Partial match exists in the loop pattern (C: GetValue calls, Rust: for loop over fields). API mappings found for field access and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5188_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5188_rank2.rs", "c_api": "GetValue(node, GET_NAME(name), name)", "rust_api": "value.name.clone()", "mapping_type": "field_access", "description": "Accessing and copying the 'name' field from a struct.", "reasoning": "[Task Analysis] C function 'Unmarshal' deserializes JSON into a Table struct; Rust function 'try_from' converts a Table into an OrderTable. [Similarity] Names don't match ('Unmarshal' vs 'try_from'), but both perform data transformation from one format to another. [Knowledge Extraction] No full structural match due to different logic and data flow. Partial match exists in the loop pattern (C: GetValue calls, Rust: for loop over fields). API mappings found for field access and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5188_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5188_rank2.rs", "c_api": "GetValue(node, GET_NAME(alias), alias)", "rust_api": "value.alias.clone()", "mapping_type": "field_access", "description": "Accessing and copying the 'alias' field from a struct.", "reasoning": "[Task Analysis] C function 'Unmarshal' deserializes JSON into a Table struct; Rust function 'try_from' converts a Table into an OrderTable. [Similarity] Names don't match ('Unmarshal' vs 'try_from'), but both perform data transformation from one format to another. [Knowledge Extraction] No full structural match due to different logic and data flow. Partial match exists in the loop pattern (C: GetValue calls, Rust: for loop over fields). API mappings found for field access and data transformation patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Unmarshal__idx5188_rank2.c", "source_rust_file": "Partial__Unmarshal__idx5188_rank2.rs", "c_api": "GetValue(node, GET_NAME(cloudSyncFields), cloudSyncFields)", "rust_api": "value.cloud_sync_fields", "mapping_type": "field_access", "description": "Accessing the 'cloudSyncFields' field from a struct.", "reasoning": "[Task Analysis] C function 'Unmarshal' deserializes JSON into a Table struct; Rust function 'try_from' converts a Table into an OrderTable. [Similarity] Names don't match ('Unmarshal' vs 'try_from'), but both perform data transformation from one format to another. [Knowledge Extraction] No full structural match due to different logic and data flow. Partial match exists in the loop pattern (C: GetValue calls, Rust: for loop over fields). API mappings found for field access and data transformation patterns."}]
Unixcoder Score: -0.06446478515863419
--------------------------------------------------
C_Code: 
int main(int argc, char **argv) {
  if (argc == 2 && strcmp(argv[1], "-v") == 0) {
    verbose = 1;
  } else {
    verbose = 0;
  }
  int ret = 0;
  struct node *tmp;
  memset(pushback, '\0', PUSHBACK_LEN);
  ret = rsparse();
  print("--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\n", ret, n_nodes);
  if (nodes) {
    print_node(nodes, 0);
  }
  while (nodes) {
    tmp = nodes;
    nodes = tmp->next;
    if (tmp->own_string) {
      free((void*)tmp->name);
    }
    free(tmp);
  }
  return ret;
}
Function: 
pub fn parse_config(args: ~[~str]) -> config {
    let opts =
        ~[getopts::reqopt("compile-lib-path"),
          getopts::reqopt("run-lib-path"),
          getopts::reqopt("rustc-path"), getopts::reqopt("src-base"),
          getopts::reqopt("build-base"), getopts::reqopt("aux-base"),
          getopts::reqopt("stage-id"),
          getopts::reqopt("mode"), getopts::optflag("ignored"),
          getopts::optopt("runtool"), getopts::optopt("rustcflags"),
          getopts::optflag("verbose"),
          getopts::optopt("logfile"),
          getopts::optflag("jit"),
          getopts::optflag("newrt"),
          getopts::optopt("target"),
          getopts::optopt("adb-path"),
          getopts::optopt("adb-test-dir")
         ];

    assert!(!args.is_empty());
    let args_ = vec::tail(args);
    let matches =
        &match getopts::getopts(args_, opts) {
          Ok(m) => m,
          Err(f) => fail!(getopts::fail_str(f))
        };

    fn opt_path(m: &getopts::Matches, nm: &str) -> Path {
        Path(getopts::opt_str(m, nm))
    }

    config {
        compile_lib_path: getopts::opt_str(matches, "compile-lib-path"),
        run_lib_path: getopts::opt_str(matches, "run-lib-path"),
        rustc_path: opt_path(matches, "rustc-path"),
        src_base: opt_path(matches, "src-base"),
        build_base: opt_path(matches, "build-base"),
        aux_base: opt_path(matches, "aux-base"),
        stage_id: getopts::opt_str(matches, "stage-id"),
        mode: str_mode(getopts::opt_str(matches, "mode")),
        run_ignored: getopts::opt_present(matches, "ignored"),
        filter:
             if !matches.free.is_empty() {
                 option::Some(copy matches.free[0])
             } else { option::None },
        logfile: getopts::opt_maybe_str(matches, "logfile").map(|s| Path(*s)),
        runtool: getopts::opt_maybe_str(matches, "runtool"),
        rustcflags: getopts::opt_maybe_str(matches, "rustcflags"),
        jit: getopts::opt_present(matches, "jit"),
        newrt: getopts::opt_present(matches, "newrt"),
        target: opt_str2(getopts::opt_maybe_str(matches, "target")).to_str(),
        adb_path: opt_str2(getopts::opt_maybe_str(matches, "adb-path")).to_str(),
        adb_test_dir:
            opt_str2(getopts::opt_maybe_str(matches, "adb-test-dir")).to_str(),
        adb_device_status:
            if (opt_str2(getopts::opt_maybe_str(matches, "target")) ==
                ~"arm-linux-androideabi") {
                if (opt_str2(getopts::opt_maybe_str(matches, "adb-test-dir")) !=
                    ~"(none)" &&
                    opt_str2(getopts::opt_maybe_str(matches, "adb-test-dir")) !=
                    ~"") { true }
                else { false }
            } else { false },
        verbose: getopts::opt_present(matches, "verbose")
    }
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__main__idx131949_rank1.c", "source_rust_file": "Partial__main__idx131949_rank1.rs", "c_api": "getopts::getopts(args_, opts)", "rust_api": "getopts::opt_str(matches, \"compile-lib-path\")", "mapping_type": "function", "description": "Parsing command-line options using getopts library.", "reasoning": "[Task Analysis] C code is a main function handling command-line args, parsing, and memory cleanup; Rust code is a config parsing function using getopts. [Similarity] Names don't refer to same concept (main vs parse_config), and domains are different (CLI handling vs config parsing). [Knowledge Extraction] No full structural match, but there are partial matching fragments and API mappings related to argument parsing and conditional logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__main__idx131949_rank1.c", "source_rust_file": "Partial__main__idx131949_rank1.rs", "c_api": "free(tmp)", "rust_api": "config { ... }", "mapping_type": "pattern", "description": "Cleanup of allocated memory structures.", "reasoning": "[Task Analysis] C code is a main function handling command-line args, parsing, and memory cleanup; Rust code is a config parsing function using getopts. [Similarity] Names don't refer to same concept (main vs parse_config), and domains are different (CLI handling vs config parsing). [Knowledge Extraction] No full structural match, but there are partial matching fragments and API mappings related to argument parsing and conditional logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__main__idx131949_rank1.c", "source_rust_file": "Partial__main__idx131949_rank1.rs", "c_api": "free((void*)tmp->name)", "rust_api": "Path(*s)", "mapping_type": "function", "description": "Memory deallocation for string data.", "reasoning": "[Task Analysis] C code is a main function handling command-line args, parsing, and memory cleanup; Rust code is a config parsing function using getopts. [Similarity] Names don't refer to same concept (main vs parse_config), and domains are different (CLI handling vs config parsing). [Knowledge Extraction] No full structural match, but there are partial matching fragments and API mappings related to argument parsing and conditional logic."}, {"knowledge_type": "Partial", "source_c_file": "Partial__main__idx131949_rank1.c", "source_rust_file": "Partial__main__idx131949_rank1.rs", "c_fragment": "while (nodes) {\n    tmp = nodes;\n    nodes = tmp->next;\n    if (tmp->own_string) {\n      free((void*)tmp->name);\n    }\n    free(tmp);\n  }", "rust_fragment": "config {\n        compile_lib_path: getopts::opt_str(matches, \"compile-lib-path\"),\n        run_lib_path: getopts::opt_str(matches, \"run-lib-path\"),\n        rustc_path: opt_path(matches, \"rustc-path\"),\n        src_base: opt_path(matches, \"src-base\"),\n        build_base: opt_path(matches, \"build-base\"),\n        aux_base: opt_path(matches, \"aux-base\"),\n        stage_id: getopts::opt_str(matches, \"stage-id\"),\n        mode: str_mode(getopts::opt_str(matches, \"mode\")),\n        run_ignored: getopts::opt_present(matches, \"ignored\"),\n        filter:\n             if !matches.free.is_empty() {\n                 option::Some(copy matches.free[0])\n             } else { option::None },\n        logfile: getopts::opt_maybe_str(matches, \"logfile\").map(|s| Path(*s)),\n        runtool: getopts::opt_maybe_str(matches, \"runtool\"),\n        rustcflags: getopts::opt_maybe_str(matches, \"rustcflags\"),\n        jit: getopts::opt_present(matches, \"jit\"),\n        newrt: getopts::opt_present(matches, \"newrt\"),\n        target: opt_str2(getopts::opt_maybe_str(matches, \"target\")).to_str(),\n        adb_path: opt_str2(getopts::opt_maybe_str(matches, \"adb-path\")).to_str(),\n        adb_test_dir:\n            opt_str2(getopts::opt_maybe_str(matches, \"adb-test-dir\")).to_str(),\n        adb_device_status:\n            if (opt_str2(getopts::opt_maybe_str(matches, \"target\")) ==\n                ~\"arm-linux-androideabi\") {\n                if (opt_str2(getopts::opt_maybe_str(matches, \"adb-test-dir\")) !=\n                    ~\"(none)\" &&\n                    opt_str2(getopts::opt_maybe_str(matches, \"adb-test-dir\")) !=\n                    ~\"\") { true }\n                else { false }\n            } else { false },\n        verbose: getopts::opt_present(matches, \"verbose\")\n    }", "description": "Both process command-line arguments and build configuration structures, though in different ways.", "reasoning": "[Task Analysis] C code is a main function handling command-line args, parsing, and memory cleanup; Rust code is a config parsing function using getopts. [Similarity] Names don't refer to same concept (main vs parse_config), and domains are different (CLI handling vs config parsing). [Knowledge Extraction] No full structural match, but there are partial matching fragments and API mappings related to argument parsing and conditional logic."}, {"knowledge_type": "Partial", "source_c_file": "Partial__main__idx131949_rank1.c", "source_rust_file": "Partial__main__idx131949_rank1.rs", "c_fragment": "if (argc == 2 && strcmp(argv[1], \"-v\") == 0) {\n    verbose = 1;\n  } else {\n    verbose = 0;\n  }", "rust_fragment": "verbose: getopts::opt_present(matches, \"verbose\")", "description": "Both handle checking for a verbose flag from command-line arguments.", "reasoning": "[Task Analysis] C code is a main function handling command-line args, parsing, and memory cleanup; Rust code is a config parsing function using getopts. [Similarity] Names don't refer to same concept (main vs parse_config), and domains are different (CLI handling vs config parsing). [Knowledge Extraction] No full structural match, but there are partial matching fragments and API mappings related to argument parsing and conditional logic."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__main__idx131949_rank1.c", "source_rust_file": "Partial__main__idx131949_rank1.rs", "c_api": "strcmp(argv[1], \"-v\")", "rust_api": "getopts::opt_present(matches, \"verbose\")", "mapping_type": "function", "description": "Checking for a verbose flag in command-line arguments.", "reasoning": "[Task Analysis] C code is a main function handling command-line args, parsing, and memory cleanup; Rust code is a config parsing function using getopts. [Similarity] Names don't refer to same concept (main vs parse_config), and domains are different (CLI handling vs config parsing). [Knowledge Extraction] No full structural match, but there are partial matching fragments and API mappings related to argument parsing and conditional logic."}]
Unixcoder Score: -0.06664926558732986
--------------------------------------------------
C_Code: 
bool Database::Unmarshal(const Serializable::json &node)
{
    GetValue(node, GET_NAME(name), name);
    GetValue(node, GET_NAME(alias), alias);
    GetValue(node, GET_NAME(tables), tables);
    GetValue(node, GET_NAME(dbName), name);
    GetValue(node, GET_NAME(autoSyncType), autoSyncType);
    GetValue(node, GET_NAME(user), user);
    GetValue(node, GET_NAME(deviceId), deviceId);
    GetValue(node, GET_NAME(version), version);
    GetValue(node, GET_NAME(bundleName), bundleName);
    return true;
}
Function: 
fn from(value: &ipc_conn::Database) -> Self {
        let mut tables = HashMap::new();
        for t in &value.tables.0 {
            tables.insert(t.table_name.clone(), Table::from(t));
        }
        Database {
            name: value.name.clone(),
            alias: value.alias.clone(),
            tables,
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_fragment": "for fd in &value.fields", "rust_fragment": "for fd in &value.fields", "description": "Iterates over fields in the table structure.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_api": "SetValue(node[GET_NAME(name)], name)", "rust_api": "table_name: value.name.clone()", "mapping_type": "field_access", "description": "Assigns the name field from source to destination.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_api": "SetValue(node[GET_NAME(alias)], alias)", "rust_api": "alias: value.alias.clone()", "mapping_type": "field_access", "description": "Assigns the alias field from source to destination.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_api": "SetValue(node[GET_NAME(fields)], fields)", "rust_api": "fields: ipc_conn::Fields(fields)", "mapping_type": "function", "description": "Converts and assigns fields to a new structure.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__Marshal__idx5188_rank1.c", "source_rust_file": "Partial__Marshal__idx5188_rank1.rs", "c_api": "ipc_conn::Field::try_from(fd)?", "rust_api": "ipc_conn::Field::try_from(fd)?", "mapping_type": "function", "description": "Converts a field using a fallible conversion.", "reasoning": "[Task Analysis] C function 'Marshal' serializes a Table object into a JSON node; Rust function 'try_from' converts a Table into an OrderTable struct. [Similarity] Names don't match ('Marshal' vs 'try_from'), but both represent data transformation logic. [Knowledge Extraction] No full structural match due to different domains (serialization vs conversion), but partial fragments and API mappings can be extracted."}]
Unixcoder Score: -0.07048028707504272
--------------------------------------------------
