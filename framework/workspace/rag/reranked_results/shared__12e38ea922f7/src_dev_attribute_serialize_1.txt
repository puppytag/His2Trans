C_Code: 
struct PhysicalDeviceVertexAttributeDivisorFeatures
Function: 
struct BufferSizes {
        // Known size buffers
        path_reduced: u32,
        path_reduced2: u32,
        path_reduced_scan: u32,
        path_monoids: u32,
        path_bboxes: u32,
        draw_reduced: u32,
        draw_monoids: u32,
        info: u32,
        clip_inps: u32,
        clip_els: u32,
        clip_bics: u32,
        clip_bboxes: u32,
        draw_bboxes: u32,
        bump_alloc: u32,
        indirect_count: u32,
        bin_headers: u32,
        paths: u32,
        // Bump allocated buffers
        lines: u32,
        bin_data: u32,
        tiles: u32,
        seg_counts: u32,
        segments: u32,
        ptcl: u32,
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__AddAttributes__idx17813_rank3.c", "source_rust_file": "API_Mapping__AddAttributes__idx17813_rank3.rs", "c_api": "t->setAttributes(PALNew)", "rust_api": "llvm::AddFunctionAttributes(llfn, idx, attrs)", "mapping_type": "function", "description": "Apply attributes to an LLVM function", "reasoning": "[Task Analysis] C function modifies LLVM function attributes by building a new attribute list and setting it; Rust function applies attributes to an LLVM function if they exist. [Similarity] Names don't match but both perform attribute application to LLVM functions. [Knowledge Extraction] Found API mapping for attribute application, no full structural match due to different control flow and logic scope."}]
Unixcoder Score: -0.04517023265361786
--------------------------------------------------
C_Code: 
int32_t AddAsset(const AssetAttr *attributes, uint32_t attrCnt)
{
    return AddAssetC2Rust(attributes, attrCnt);
}
Function: 
pub extern "C" fn add_asset(attributes: *const Asset_Attr, attr_cnt: u32) -> i32 {
    let map = match into_map(attributes, attr_cnt) {
        Some(map) => map,
        None => return ErrCode::InvalidArgument as i32,
    };

    let manager = match Manager::build() {
        Ok(manager) => manager,
        Err(e) => return e as i32,
    };

    if let Err(e) = manager.add(&map) {
        e as i32
    } else {
        RESULT_CODE_SUCCESS
    }
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__fromRust__idx12861_rank1.c", "source_rust_file": "Partial__fromRust__idx12861_rank1.rs", "c_api": "switch (Kind)", "rust_api": "filter_by_name(attrs, name).next()", "mapping_type": "pattern", "description": "Enum value mapping pattern: switch-case in C vs filtering iterator in Rust.", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum to Attribute::AttrKind enum; Rust function filters attributes by name. [Similarity] Names don't match but both perform mapping/logic lookup. [Knowledge Extraction] No full structural match due to different domains (enum mapping vs filtering). Partial match in control flow logic (switch vs iterator). API mappings found for enum conversion and filtering patterns."}, {"knowledge_type": "Partial", "source_c_file": "Partial__fromRust__idx12861_rank1.c", "source_rust_file": "Partial__fromRust__idx12861_rank1.rs", "c_fragment": "switch (Kind) {\n  case AlwaysInline:\n    return Attribute::AlwaysInline;\n  case ByVal:\n    return Attribute::ByVal;\n  case Cold:\n    return Attribute::Cold;\n  case InlineHint:\n    return Attribute::InlineHint;\n  case MinSize:\n    return Attribute::MinSize;\n  case Naked:\n    return Attribute::Naked;\n  case NoAlias:\n    return Attribute::NoAlias;\n  case NoCapture:\n    return Attribute::NoCapture;\n  case NoCfCheck:\n    return Attribute::NoCfCheck;\n  case NoInline:\n    return Attribute::NoInline;\n  case NonNull:\n    return Attribute::NonNull;\n  case NoRedZone:\n    return Attribute::NoRedZone;\n  case NoReturn:\n    return Attribute::NoReturn;\n  case NoUnwind:\n    return Attribute::NoUnwind;\n  case OptimizeForSize:\n    return Attribute::OptimizeForSize;\n  case ReadOnly:\n    return Attribute::ReadOnly;\n  case SExt:\n    return Attribute::SExt;\n  case StructRet:\n    return Attribute::StructRet;\n  case UWTable:\n    return Attribute::UWTable;\n  case ZExt:\n    return Attribute::ZExt;\n  case InReg:\n    return Attribute::InReg;\n  case SanitizeThread:\n    return Attribute::SanitizeThread;\n  case SanitizeAddress:\n    return Attribute::SanitizeAddress;\n  case SanitizeMemory:\n    return Attribute::SanitizeMemory;\n  case NonLazyBind:\n    return Attribute::NonLazyBind;\n  case OptimizeNone:\n    return Attribute::OptimizeNone;\n  case ReturnsTwice:\n    return Attribute::ReturnsTwice;\n  case ReadNone:\n    return Attribute::ReadNone;\n  case SanitizeHWAddress:\n    return Attribute::SanitizeHWAddress;\n  case WillReturn:\n    return Attribute::WillReturn;\n  case StackProtectReq:\n    return Attribute::StackProtectReq;\n  case StackProtectStrong:\n    return Attribute::StackProtectStrong;\n  case StackProtect:\n    return Attribute::StackProtect;\n  case NoUndef:\n    return Attribute::NoUndef;\n  case SanitizeMemTag:\n    return Attribute::SanitizeMemTag;\n  case ShadowCallStack:\n    return Attribute::ShadowCallStack;\n  case AllocSize:\n    return Attribute::AllocSize;\n#if LLVM_VERSION_GE(15, 0)\n  case AllocatedPointer:\n    return Attribute::AllocatedPointer;\n  case AllocAlign:\n    return Attribute::AllocAlign;\n#endif\n  case SanitizeSafeStack:\n    return Attribute::SafeStack;\n  }", "rust_fragment": "pub fn find_by_name(attrs: &[Attribute], name: Symbol) -> Option<&Attribute> {\n    filter_by_name(attrs, name).next()\n}", "description": "Control flow logic for mapping/lookup: C uses switch-case to map enum values, Rust uses filtering with next().", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum to Attribute::AttrKind enum; Rust function filters attributes by name. [Similarity] Names don't match but both perform mapping/logic lookup. [Knowledge Extraction] No full structural match due to different domains (enum mapping vs filtering). Partial match in control flow logic (switch vs iterator). API mappings found for enum conversion and filtering patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__fromRust__idx12861_rank1.c", "source_rust_file": "Partial__fromRust__idx12861_rank1.rs", "c_api": "return Attribute::AlwaysInline;", "rust_api": "filter_by_name(attrs, name).next()", "mapping_type": "pattern", "description": "Value return pattern: C returns mapped enum value, Rust returns filtered result.", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum to Attribute::AttrKind enum; Rust function filters attributes by name. [Similarity] Names don't match but both perform mapping/logic lookup. [Knowledge Extraction] No full structural match due to different domains (enum mapping vs filtering). Partial match in control flow logic (switch vs iterator). API mappings found for enum conversion and filtering patterns."}]
Unixcoder Score: -0.07747653871774673
--------------------------------------------------
C_Code: 
struct VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           legacyVertexAttributes;
}
Function: 
struct BufferSizes {
        // Known size buffers
        path_reduced: u32,
        path_reduced2: u32,
        path_reduced_scan: u32,
        path_monoids: u32,
        path_bboxes: u32,
        draw_reduced: u32,
        draw_monoids: u32,
        info: u32,
        clip_inps: u32,
        clip_els: u32,
        clip_bics: u32,
        clip_bboxes: u32,
        draw_bboxes: u32,
        bump_alloc: u32,
        indirect_count: u32,
        bin_headers: u32,
        paths: u32,
        // Bump allocated buffers
        lines: u32,
        bin_data: u32,
        tiles: u32,
        seg_counts: u32,
        segments: u32,
        ptcl: u32,
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "Partial__AddAttributes__idx17814_rank3.c", "source_rust_file": "Partial__AddAttributes__idx17814_rank3.rs", "c_api": "PAL.addAttributesAtIndex(t->getContext(), Index, B)", "rust_api": "llvm::AddCallSiteAttributes(callsite, idx, attrs)", "mapping_type": "function", "description": "Adding attributes to a specific index in LLVM IR in C vs applying attributes to a callsite in Rust.", "reasoning": "[Task Analysis] C function modifies LLVM IR attributes via a builder pattern; Rust function applies attributes to a callsite using an LLVM FFI call. [Similarity] Names don't match but both operate on LLVM attributes in a similar logical context. [Knowledge Extraction] Found API mapping between attribute application logic, partial structural match in conditional application, and domain mismatch (LLVM IR manipulation vs FFI call)."}, {"knowledge_type": "Partial", "source_c_file": "Partial__AddAttributes__idx17814_rank3.c", "source_rust_file": "Partial__AddAttributes__idx17814_rank3.rs", "c_fragment": "if (!attrs.is_empty()) {\n        llvm::AddCallSiteAttributes(callsite, idx, attrs);\n    }", "rust_fragment": "if (!attrs.is_empty()) {\n        llvm::AddCallSiteAttributes(callsite, idx, attrs);\n    }", "description": "Conditional check for non-empty attributes followed by an LLVM attribute application call.", "reasoning": "[Task Analysis] C function modifies LLVM IR attributes via a builder pattern; Rust function applies attributes to a callsite using an LLVM FFI call. [Similarity] Names don't match but both operate on LLVM attributes in a similar logical context. [Knowledge Extraction] Found API mapping between attribute application logic, partial structural match in conditional application, and domain mismatch (LLVM IR manipulation vs FFI call)."}, {"knowledge_type": "API_Mapping", "source_c_file": "Partial__AddAttributes__idx17814_rank3.c", "source_rust_file": "Partial__AddAttributes__idx17814_rank3.rs", "c_api": "B.addAttribute(unwrap(Attr))", "rust_api": "llvm::AddCallSiteAttributes(callsite, idx, attrs)", "mapping_type": "function", "description": "Adding individual attribute to a builder/list in C vs applying a set of attributes to a callsite in Rust.", "reasoning": "[Task Analysis] C function modifies LLVM IR attributes via a builder pattern; Rust function applies attributes to a callsite using an LLVM FFI call. [Similarity] Names don't match but both operate on LLVM attributes in a similar logical context. [Knowledge Extraction] Found API mapping between attribute application logic, partial structural match in conditional application, and domain mismatch (LLVM IR manipulation vs FFI call)."}]
Unixcoder Score: -0.08607867360115051
--------------------------------------------------
C_Code: 
static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {
  switch (Kind) {
  case AlwaysInline:
    return Attribute::AlwaysInline;
  case ByVal:
    return Attribute::ByVal;
  case Cold:
    return Attribute::Cold;
  case InlineHint:
    return Attribute::InlineHint;
  case MinSize:
    return Attribute::MinSize;
  case Naked:
    return Attribute::Naked;
  case NoAlias:
    return Attribute::NoAlias;
  case NoCapture:
    return Attribute::NoCapture;
  case NoCfCheck:
    return Attribute::NoCfCheck;
  case NoInline:
    return Attribute::NoInline;
  case NonNull:
    return Attribute::NonNull;
  case NoRedZone:
    return Attribute::NoRedZone;
  case NoReturn:
    return Attribute::NoReturn;
  case NoUnwind:
    return Attribute::NoUnwind;
  case OptimizeForSize:
    return Attribute::OptimizeForSize;
  case ReadOnly:
    return Attribute::ReadOnly;
  case SExt:
    return Attribute::SExt;
  case StructRet:
    return Attribute::StructRet;
  case UWTable:
    return Attribute::UWTable;
  case ZExt:
    return Attribute::ZExt;
  case InReg:
    return Attribute::InReg;
  case SanitizeThread:
    return Attribute::SanitizeThread;
  case SanitizeAddress:
    return Attribute::SanitizeAddress;
  case SanitizeMemory:
    return Attribute::SanitizeMemory;
  case NonLazyBind:
    return Attribute::NonLazyBind;
  case OptimizeNone:
    return Attribute::OptimizeNone;
  case ReturnsTwice:
    return Attribute::ReturnsTwice;
  case ReadNone:
    return Attribute::ReadNone;
  case SanitizeHWAddress:
    return Attribute::SanitizeHWAddress;
  case WillReturn:
    return Attribute::WillReturn;
  case StackProtectReq:
    return Attribute::StackProtectReq;
  case StackProtectStrong:
    return Attribute::StackProtectStrong;
  case StackProtect:
    return Attribute::StackProtect;
  case NoUndef:
    return Attribute::NoUndef;
  case SanitizeMemTag:
    return Attribute::SanitizeMemTag;
  case ShadowCallStack:
    return Attribute::ShadowCallStack;
  case AllocSize:
    return Attribute::AllocSize;
#if LLVM_VERSION_GE(15, 0)
  case AllocatedPointer:
    return Attribute::AllocatedPointer;
  case AllocAlign:
    return Attribute::AllocAlign;
#endif
  case SanitizeSafeStack:
    return Attribute::SafeStack;
  }
  report_fatal_error("bad AttributeKind");
}
Function: 
fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {
    for attr in get_attr(sess, attrs, name) {
        if let Some(ref value) = attr.value_str() {
            if let Ok(value) = FromStr::from_str(value.as_str()) {
                f(value);
            } else {
                sess.span_err(attr.span, "not a number");
            }
        } else {
            sess.span_err(attr.span, "bad clippy attribute");
        }
    }
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__fromRust__idx14827_rank4.c", "source_rust_file": "API_Mapping__fromRust__idx14827_rank4.rs", "c_api": "switch (Kind) { ... case AlwaysInline: return Attribute::AlwaysInline; ... }", "rust_api": "if target != allowed_target { ... }", "mapping_type": "pattern", "description": "Attribute kind mapping and validation logic", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum to LLVM Attribute::AttrKind; Rust function checks attribute target compatibility. [Similarity] No structural similarity in control flow or logic. [Knowledge Extraction] No full match, no partial match, but both involve attribute handling - C maps enum values, Rust validates attribute targets. Extract API mapping for attribute validation logic."}]
Unixcoder Score: -0.0911550372838974
--------------------------------------------------
C_Code: 
static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {
  switch (Kind) {
  case AlwaysInline:
    return Attribute::AlwaysInline;
  case ByVal:
    return Attribute::ByVal;
  case Cold:
    return Attribute::Cold;
  case InlineHint:
    return Attribute::InlineHint;
  case MinSize:
    return Attribute::MinSize;
  case Naked:
    return Attribute::Naked;
  case NoAlias:
    return Attribute::NoAlias;
  case NoCapture:
    return Attribute::NoCapture;
  case NoCfCheck:
    return Attribute::NoCfCheck;
  case NoInline:
    return Attribute::NoInline;
  case NonNull:
    return Attribute::NonNull;
  case NoRedZone:
    return Attribute::NoRedZone;
  case NoReturn:
    return Attribute::NoReturn;
  case NoUnwind:
    return Attribute::NoUnwind;
  case OptimizeForSize:
    return Attribute::OptimizeForSize;
  case ReadOnly:
    return Attribute::ReadOnly;
  case SExt:
    return Attribute::SExt;
  case StructRet:
    return Attribute::StructRet;
  case UWTable:
    return Attribute::UWTable;
  case ZExt:
    return Attribute::ZExt;
  case InReg:
    return Attribute::InReg;
  case SanitizeThread:
    return Attribute::SanitizeThread;
  case SanitizeAddress:
    return Attribute::SanitizeAddress;
  case SanitizeMemory:
    return Attribute::SanitizeMemory;
  case NonLazyBind:
    return Attribute::NonLazyBind;
  case OptimizeNone:
    return Attribute::OptimizeNone;
  case ReturnsTwice:
    return Attribute::ReturnsTwice;
  case ReadNone:
    return Attribute::ReadNone;
  case SanitizeHWAddress:
    return Attribute::SanitizeHWAddress;
  case WillReturn:
    return Attribute::WillReturn;
  case StackProtectReq:
    return Attribute::StackProtectReq;
  case StackProtectStrong:
    return Attribute::StackProtectStrong;
  case StackProtect:
    return Attribute::StackProtect;
  case NoUndef:
    return Attribute::NoUndef;
  case SanitizeMemTag:
    return Attribute::SanitizeMemTag;
  case ShadowCallStack:
    return Attribute::ShadowCallStack;
  case AllocSize:
    return Attribute::AllocSize;
#if LLVM_VERSION_GE(15, 0)
  case AllocatedPointer:
    return Attribute::AllocatedPointer;
  case AllocAlign:
    return Attribute::AllocAlign;
#endif
  case SanitizeSafeStack:
    return Attribute::SafeStack;
  }
  report_fatal_error("bad AttributeKind");
}
Function: 
pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {
    let Attribute { kind, id: _, style: _, span } = attr;
    match kind {
        AttrKind::Normal(normal) => {
            let NormalAttr { item: AttrItem { path, args, tokens }, tokens: attr_tokens } =
                &mut **normal;
            vis.visit_path(path);
            visit_attr_args(args, vis);
            visit_lazy_tts(tokens, vis);
            visit_lazy_tts(attr_tokens, vis);
        }
        AttrKind::DocComment(..) => {}
    }
    vis.visit_span(span);
}
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__fromRust__idx12222_rank3.c", "source_rust_file": "API_Mapping__fromRust__idx12222_rank3.rs", "c_api": "return Attribute::XXX", "rust_api": "attr.is_doc_comment() || attr.ident().is_some_and(|ident| ...)", "mapping_type": "function", "description": "Attribute validation logic in C vs Rust", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum values to LLVM Attribute::AttrKind, while Rust function checks if attributes are doc comments or builtin attributes. [Similarity] Names don't match (fromRust vs is_complete), and domains are different (LLVM attribute mapping vs Rust attribute validation). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to attribute handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__fromRust__idx12222_rank3.c", "source_rust_file": "API_Mapping__fromRust__idx12222_rank3.rs", "c_api": "switch (Kind)", "rust_api": "attrs.iter().all(|attr| ...)", "mapping_type": "pattern", "description": "Enum dispatch pattern in C vs iterator with predicate in Rust", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum values to LLVM Attribute::AttrKind, while Rust function checks if attributes are doc comments or builtin attributes. [Similarity] Names don't match (fromRust vs is_complete), and domains are different (LLVM attribute mapping vs Rust attribute validation). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to attribute handling."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__fromRust__idx12222_rank3.c", "source_rust_file": "API_Mapping__fromRust__idx12222_rank3.rs", "c_api": "Attribute::AttrKind", "rust_api": "ast::Attribute", "mapping_type": "type", "description": "Attribute kind representation in LLVM vs Rust AST", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum values to LLVM Attribute::AttrKind, while Rust function checks if attributes are doc comments or builtin attributes. [Similarity] Names don't match (fromRust vs is_complete), and domains are different (LLVM attribute mapping vs Rust attribute validation). [Knowledge Extraction] No full structural match, no partial match, but there are API mappings related to attribute handling."}]
Unixcoder Score: -0.09737484157085419
--------------------------------------------------
C_Code: 
int32_t AddAsset(const AssetAttr *attributes, uint32_t attrCnt)
{
    return AddAssetC2Rust(attributes, attrCnt);
}
Function: 
pub unsafe extern "C" fn AddAssetC2Rust(attributes: *const AssetAttr, attr_cnt: u32) -> i32 {
    loge!("[YZT] enter AddAssetC2Rust!");
    if attributes.is_null() || attr_cnt == 0 {
        loge!("[YZT] null pointer");
        return ErrCode::InvalidArgument as i32;
    }

    let mut map = AssetMap::with_capacity(attr_cnt as usize);
    for i in 0..attr_cnt {
        let attr = attributes.offset(i as isize);
        let attr_tag = match Tag::try_from((*attr).tag) {
            Ok(tag) => tag,
            Err(err_code) => return err_code as i32,
        };
        match attr_tag.data_type() {
            DataType::Bool => {
                map.insert(attr_tag, Value::Bool((*attr).value.boolean));
            }
            DataType::Uint32 => {
                map.insert(attr_tag, Value::Number((*attr).value.uint32));
            },
            DataType::Bytes => {
                let blob_slice = slice::from_raw_parts((*attr).value.blob.data, (*attr).value.blob.size as usize);
                let blob_vec = blob_slice.to_vec();
                map.insert(attr_tag, Value::Bytes(blob_vec));
            },
        }
    }
    loge!("[YZT] end AddAssetC2Rust!");
    match Manager::build() {
        Ok(manager) => {
            if let Err(e) = manager.add(&map) {
                e as i32
            } else {
                0
            }
        },
        Err(e) => e as i32
    }
}
Extracted_Knowledge: 
[{"knowledge_type": "Partial", "source_c_file": "Partial__fromRust__idx12859_rank3.c", "source_rust_file": "Partial__fromRust__idx12859_rank3.rs", "c_fragment": "switch (Kind) {\n  case AlwaysInline:\n    return Attribute::AlwaysInline;\n  case ByVal:\n    return Attribute::ByVal;\n  case Cold:\n    return Attribute::Cold;\n  case InlineHint:\n    return Attribute::InlineHint;\n  case MinSize:\n    return Attribute::MinSize;\n  case Naked:\n    return Attribute::Naked;\n  case NoAlias:\n    return Attribute::NoAlias;\n  case NoCapture:\n    return Attribute::NoCapture;\n  case NoCfCheck:\n    return Attribute::NoCfCheck;\n  case NoInline:\n    return Attribute::NoInline;\n  case NonNull:\n    return Attribute::NonNull;\n  case NoRedZone:\n    return Attribute::NoRedZone;\n  case NoReturn:\n    return Attribute::NoReturn;\n  case NoUnwind:\n    return Attribute::NoUnwind;\n  case OptimizeForSize:\n    return Attribute::OptimizeForSize;\n  case ReadOnly:\n    return Attribute::ReadOnly;\n  case SExt:\n    return Attribute::SExt;\n  case StructRet:\n    return Attribute::StructRet;\n  case UWTable:\n    return Attribute::UWTable;\n  case ZExt:\n    return Attribute::ZExt;\n  case InReg:\n    return Attribute::InReg;\n  case SanitizeThread:\n    return Attribute::SanitizeThread;\n  case SanitizeAddress:\n    return Attribute::SanitizeAddress;\n  case SanitizeMemory:\n    return Attribute::SanitizeMemory;\n  case NonLazyBind:\n    return Attribute::NonLazyBind;\n  case OptimizeNone:\n    return Attribute::OptimizeNone;\n  case ReturnsTwice:\n    return Attribute::ReturnsTwice;\n  case ReadNone:\n    return Attribute::ReadNone;\n  case SanitizeHWAddress:\n    return Attribute::SanitizeHWAddress;\n  case WillReturn:\n    return Attribute::WillReturn;\n  case StackProtectReq:\n    return Attribute::StackProtectReq;\n  case StackProtectStrong:\n    return Attribute::StackProtectStrong;\n  case StackProtect:\n    return Attribute::StackProtect;\n  case NoUndef:\n    return Attribute::NoUndef;\n  case SanitizeMemTag:\n    return Attribute::SanitizeMemTag;\n  case ShadowCallStack:\n    return Attribute::ShadowCallStack;\n  case AllocSize:\n    return Attribute::AllocSize;\n#if LLVM_VERSION_GE(15, 0)\n  case AllocatedPointer:\n    return Attribute::AllocatedPointer;\n  case AllocAlign:\n    return Attribute::AllocAlign;\n#endif\n  case SanitizeSafeStack:\n    return Attribute::SafeStack;\n  }", "rust_fragment": "pub fn mk_attr_name_value_str(\n    g: &AttrIdGenerator,\n    style: AttrStyle,\n    name: Symbol,\n    val: Symbol,\n    span: Span,\n) -> Attribute {\n    let lit = token::Lit::new(token::Str, escape_string_symbol(val), None);\n    let expr = P(Expr {\n        id: DUMMY_NODE_ID,\n        kind: ExprKind::Lit(lit),\n        span,\n        attrs: AttrVec::new(),\n        tokens: None,\n    });\n    let path = Path::from_ident(Ident::new(name, span));\n    let args = AttrArgs::Eq(span, AttrArgsEq::Ast(expr));\n    mk_attr(g, style, path, args, span)\n}", "description": "Both functions map input values to output attributes, though with different domains and structures.", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum values to LLVM Attribute::AttrKind, while Rust function creates an Attribute from name/value parts. [Similarity] Names don't match but both perform enum/attribute mapping logic. [Knowledge Extraction] No full structural match due to different domains (LLVM IR vs Rust AST), but partial matching in control flow pattern (switch/case vs function call). No API mappings due to domain mismatch and different operations."}]
Unixcoder Score: -0.10008856654167175
--------------------------------------------------
C_Code: 
PhysicalDeviceVertexAttributeDivisorPropertiesEXT( VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT const & rhs ) VULKAN_HPP_NOEXCEPT
      : PhysicalDeviceVertexAttributeDivisorPropertiesEXT( *reinterpret_cast<PhysicalDeviceVertexAttributeDivisorPropertiesEXT const *>( &rhs ) )
    {
    }
Function: 
fn from(src: &vello_encoding::BufferSizes) -> Self {
        Self {
            path_reduced: src.path_reduced.size_in_bytes(),
            path_reduced2: src.path_reduced2.size_in_bytes(),
            path_reduced_scan: src.path_reduced_scan.size_in_bytes(),
            path_monoids: src.path_monoids.size_in_bytes(),
            path_bboxes: src.path_bboxes.size_in_bytes(),
            draw_reduced: src.draw_reduced.size_in_bytes(),
            draw_monoids: src.draw_monoids.size_in_bytes(),
            info: src.info.size_in_bytes(),
            clip_inps: src.clip_inps.size_in_bytes(),
            clip_els: src.clip_els.size_in_bytes(),
            clip_bics: src.clip_bics.size_in_bytes(),
            clip_bboxes: src.clip_bboxes.size_in_bytes(),
            draw_bboxes: src.draw_bboxes.size_in_bytes(),
            bump_alloc: src.bump_alloc.size_in_bytes(),
            indirect_count: src.indirect_count.size_in_bytes(),
            bin_headers: src.bin_headers.size_in_bytes(),
            paths: src.paths.size_in_bytes(),
            lines: src.lines.size_in_bytes(),
            bin_data: src.bin_data.size_in_bytes(),
            tiles: src.tiles.size_in_bytes(),
            seg_counts: src.seg_counts.size_in_bytes(),
            segments: src.segments.size_in_bytes(),
            ptcl: src.ptcl.size_in_bytes(),
        }
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__AddAttributes__idx18071_rank2.c", "source_rust_file": "API_Mapping__AddAttributes__idx18071_rank2.rs", "c_api": "B.addAttribute(unwrap(Attr))", "rust_api": "LLVMRustAddFunctionAttributes(...)", "mapping_type": "function", "description": "Adding attributes to a function in LLVM IR", "reasoning": "[Task Analysis] C function modifies LLVM IR attributes via unwrapping and building; Rust function calls an FFI wrapper to apply attributes. [Similarity] Names don't match but both perform attribute addition to functions. [Knowledge Extraction] Found API mapping for attribute application, no full/partial structural match due to domain mismatch (LLVM IR manipulation vs FFI wrapper)."}]
Unixcoder Score: -0.10075956583023071
--------------------------------------------------
C_Code: 
int32_t AssetAdd(const AssetAttr *attributes, uint32_t attrCnt)
{
    return add_asset(attributes, attrCnt);
}
Function: 
pub fn add(&mut self, attributes: &AssetMap) -> Result<()> {
        self.process_one_agr_request(attributes, IpcCode::Add)?;
        Ok(())
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__AssetAdd__idx4620_rank2.c", "source_rust_file": "API_Mapping__AssetAdd__idx4620_rank2.rs", "c_api": "add_asset(attributes, attrCnt)", "rust_api": "serialize_map(attributes, &mut parcel)?", "mapping_type": "function", "description": "Adding asset with attributes", "reasoning": "[Task Analysis] C function calls a helper function with same signature; Rust function handles IPC request with serialization and error handling. [Similarity] No full structural match due to different domains (low-level asset management vs high-level IPC communication). [Knowledge Extraction] Extract API mappings for serialization and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__AssetAdd__idx4620_rank2.c", "source_rust_file": "API_Mapping__AssetAdd__idx4620_rank2.rs", "c_api": "Err(e)", "rust_api": "Err(e)", "mapping_type": "pattern", "description": "Error propagation", "reasoning": "[Task Analysis] C function calls a helper function with same signature; Rust function handles IPC request with serialization and error handling. [Similarity] No full structural match due to different domains (low-level asset management vs high-level IPC communication). [Knowledge Extraction] Extract API mappings for serialization and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__AssetAdd__idx4620_rank2.c", "source_rust_file": "API_Mapping__AssetAdd__idx4620_rank2.rs", "c_api": "return add_asset(attributes, attrCnt);", "rust_api": "Ok(msg)", "mapping_type": "pattern", "description": "Return success result", "reasoning": "[Task Analysis] C function calls a helper function with same signature; Rust function handles IPC request with serialization and error handling. [Similarity] No full structural match due to different domains (low-level asset management vs high-level IPC communication). [Knowledge Extraction] Extract API mappings for serialization and error handling patterns."}, {"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__AssetAdd__idx4620_rank2.c", "source_rust_file": "API_Mapping__AssetAdd__idx4620_rank2.rs", "c_api": "serialize_map(attributes, &mut parcel)?", "rust_api": "serialize_map(attributes, &mut parcel)?", "mapping_type": "function", "description": "Serializing asset map into parcel", "reasoning": "[Task Analysis] C function calls a helper function with same signature; Rust function handles IPC request with serialization and error handling. [Similarity] No full structural match due to different domains (low-level asset management vs high-level IPC communication). [Knowledge Extraction] Extract API mappings for serialization and error handling patterns."}]
Unixcoder Score: -0.10084444284439087
--------------------------------------------------
C_Code: 
static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {
  switch (Kind) {
  case AlwaysInline:
    return Attribute::AlwaysInline;
  case ByVal:
    return Attribute::ByVal;
  case Cold:
    return Attribute::Cold;
  case InlineHint:
    return Attribute::InlineHint;
  case MinSize:
    return Attribute::MinSize;
  case Naked:
    return Attribute::Naked;
  case NoAlias:
    return Attribute::NoAlias;
  case NoCapture:
    return Attribute::NoCapture;
  case NoCfCheck:
    return Attribute::NoCfCheck;
  case NoInline:
    return Attribute::NoInline;
  case NonNull:
    return Attribute::NonNull;
  case NoRedZone:
    return Attribute::NoRedZone;
  case NoReturn:
    return Attribute::NoReturn;
  case NoUnwind:
    return Attribute::NoUnwind;
  case OptimizeForSize:
    return Attribute::OptimizeForSize;
  case ReadOnly:
    return Attribute::ReadOnly;
  case SExt:
    return Attribute::SExt;
  case StructRet:
    return Attribute::StructRet;
  case UWTable:
    return Attribute::UWTable;
  case ZExt:
    return Attribute::ZExt;
  case InReg:
    return Attribute::InReg;
  case SanitizeThread:
    return Attribute::SanitizeThread;
  case SanitizeAddress:
    return Attribute::SanitizeAddress;
  case SanitizeMemory:
    return Attribute::SanitizeMemory;
  case NonLazyBind:
    return Attribute::NonLazyBind;
  case OptimizeNone:
    return Attribute::OptimizeNone;
  case ReturnsTwice:
    return Attribute::ReturnsTwice;
  case ReadNone:
    return Attribute::ReadNone;
  case SanitizeHWAddress:
    return Attribute::SanitizeHWAddress;
  case WillReturn:
    return Attribute::WillReturn;
  case StackProtectReq:
    return Attribute::StackProtectReq;
  case StackProtectStrong:
    return Attribute::StackProtectStrong;
  case StackProtect:
    return Attribute::StackProtect;
  case NoUndef:
    return Attribute::NoUndef;
  case SanitizeMemTag:
    return Attribute::SanitizeMemTag;
  case ShadowCallStack:
    return Attribute::ShadowCallStack;
  case AllocSize:
    return Attribute::AllocSize;
#if LLVM_VERSION_GE(15, 0)
  case AllocatedPointer:
    return Attribute::AllocatedPointer;
  case AllocAlign:
    return Attribute::AllocAlign;
#endif
  case SanitizeSafeStack:
    return Attribute::SafeStack;
  }
  report_fatal_error("bad AttributeKind");
}
Function: 
fn do_not_inline(&mut self, llret: &'ll Value) {
        let noinline = llvm::AttributeKind::NoInline.create_attr(self.llcx);
        attributes::apply_to_callsite(llret, llvm::AttributePlace::Function, &[noinline]);
    }
Extracted_Knowledge: 
[{"knowledge_type": "API_Mapping", "source_c_file": "API_Mapping__fromRust__idx14757_rank5.c", "source_rust_file": "API_Mapping__fromRust__idx14757_rank5.rs", "c_api": "switch (Kind) { ... case AlwaysInline: return Attribute::AlwaysInline; ... }", "rust_api": "attrs.iter().find_map(|attr| { if attr.has_name(sym::rustc_diagnostic_item) { attr.value_str() } else { None } })", "mapping_type": "pattern", "description": "Enum/attribute mapping with conditional logic", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum to LLVM Attribute::AttrKind; Rust function extracts diagnostic item from AST attributes. [Similarity] Names don't refer to same concept (fromRust vs extract), domains are different (LLVM attribute mapping vs AST diagnostic item extraction). [Knowledge Extraction] No full or partial structural match. API mappings identified: C switch-case logic maps to Rust iterator with find_map and conditional logic."}]
Unixcoder Score: -0.10255035758018494
--------------------------------------------------
C_Code: 
int32_t OH_Asset_Add(const Asset_Attr *attributes, uint32_t attrCnt)
{
    return AssetAdd((const AssetAttr *)attributes, attrCnt);
}
Function: 
fn into_map(attributes: *const AssetAttr, attr_cnt: u32) -> Option<AssetMap> {
    if attributes.is_null() && attr_cnt != 0 {
        loge!("[FATAL][RUST SDK]Attributes is null.");
        return None;
    }
    if attr_cnt > MAX_MAP_CAPACITY {
        loge!("[FATAL][RUST SDK]Number of attributes exceeds limit.");
        return None;
    }

    let mut map = AssetMap::with_capacity(attr_cnt as usize);
    for i in 0..attr_cnt {
        unsafe {
            let attr = attributes.add(i as usize);
            let attr_tag = match Tag::try_from((*attr).tag) {
                Ok(tag) => tag,
                Err(_) => return None,
            };
            match attr_tag.data_type() {
                DataType::Bool => {
                    map.insert(attr_tag, Value::Bool((*attr).value.boolean));
                },
                DataType::Number => {
                    map.insert(attr_tag, Value::Number((*attr).value.uint32));
                },
                DataType::Bytes => {
                    if (*attr).value.blob.data.is_null() || (*attr).value.blob.size == 0 {
                        loge!("[FATAL][RUST SDK]Blob data is empty.");
                        return None;
                    }
                    let blob_slice = slice::from_raw_parts((*attr).value.blob.data, (*attr).value.blob.size as usize);
                    let blob_vec = blob_slice.to_vec();
                    map.insert(attr_tag, Value::Bytes(blob_vec));
                },
            };
        }
    }
    Some(map)
}
Extracted_Knowledge: 
[{"knowledge_type": "Full", "source_c_file": "Full__fromRust__idx12546_rank1.c", "source_rust_file": "Full__fromRust__idx12546_rank1.rs", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum values to LLVM Attribute::AttrKind enum values; Rust function returns a slice of Attribute objects from self.kind.attrs(). [Similarity] Names do not match (fromRust vs attrs), but both represent mapping/lookup logic for attribute kinds. [Knowledge Extraction] Full structural similarity in terms of enum mapping logic; API mappings found for attribute kind conversion.", "description": "Full structural translation"}, {"knowledge_type": "Partial", "source_c_file": "Full__fromRust__idx12546_rank1.c", "source_rust_file": "Full__fromRust__idx12546_rank1.rs", "c_fragment": "static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n  switch (Kind) {\n  case AlwaysInline:\n    return Attribute::AlwaysInline;\n  case ByVal:\n    return Attribute::ByVal;\n  case Cold:\n    return Attribute::Cold;\n  case InlineHint:\n    return Attribute::InlineHint;\n  case MinSize:\n    return Attribute::MinSize;\n  case Naked:\n    return Attribute::Naked;\n  case NoAlias:\n    return Attribute::NoAlias;\n  case NoCapture:\n    return Attribute::NoCapture;\n  case NoCfCheck:\n    return Attribute::NoCfCheck;\n  case NoInline:\n    return Attribute::NoInline;\n  case NonNull:\n    return Attribute::NonNull;\n  case NoRedZone:\n    return Attribute::NoRedZone;\n  case NoReturn:\n    return Attribute::NoReturn;\n  case NoUnwind:\n    return Attribute::NoUnwind;\n  case OptimizeForSize:\n    return Attribute::OptimizeForSize;\n  case ReadOnly:\n    return Attribute::ReadOnly;\n  case SExt:\n    return Attribute::SExt;\n  case StructRet:\n    return Attribute::StructRet;\n  case UWTable:\n    return Attribute::UWTable;\n  case ZExt:\n    return Attribute::ZExt;\n  case InReg:\n    return Attribute::InReg;\n  case SanitizeThread:\n    return Attribute::SanitizeThread;\n  case SanitizeAddress:\n    return Attribute::SanitizeAddress;\n  case SanitizeMemory:\n    return Attribute::SanitizeMemory;\n  case NonLazyBind:\n    return Attribute::NonLazyBind;\n  case OptimizeNone:\n    return Attribute::OptimizeNone;\n  case ReturnsTwice:\n    return Attribute::ReturnsTwice;\n  case ReadNone:\n    return Attribute::ReadNone;\n  case SanitizeHWAddress:\n    return Attribute::SanitizeHWAddress;\n  case WillReturn:\n    return Attribute::WillReturn;\n  case StackProtectReq:\n    return Attribute::StackProtectReq;\n  case StackProtectStrong:\n    return Attribute::StackProtectStrong;\n  case StackProtect:\n    return Attribute::StackProtect;\n  case NoUndef:\n    return Attribute::NoUndef;\n  case SanitizeMemTag:\n    return Attribute::SanitizeMemTag;\n  case ShadowCallStack:\n    return Attribute::ShadowCallStack;\n  case AllocSize:\n    return Attribute::AllocSize;\n#if LLVM_VERSION_GE(15, 0)\n  case AllocatedPointer:\n    return Attribute::AllocatedPointer;\n  case AllocAlign:\n    return Attribute::AllocAlign;\n#endif\n  case SanitizeSafeStack:\n    return Attribute::SafeStack;\n  }\n  report_fatal_error(\"bad AttributeKind\");\n}", "rust_fragment": "fn attrs(&self) -> &[Attribute] {\n        self.kind.attrs()\n    }", "description": "C function performs enum mapping from LLVMRustAttribute to Attribute::AttrKind; Rust function retrieves attributes from self.kind.", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum values to LLVM Attribute::AttrKind enum values; Rust function returns a slice of Attribute objects from self.kind.attrs(). [Similarity] Names do not match (fromRust vs attrs), but both represent mapping/lookup logic for attribute kinds. [Knowledge Extraction] Full structural similarity in terms of enum mapping logic; API mappings found for attribute kind conversion."}, {"knowledge_type": "API_Mapping", "source_c_file": "Full__fromRust__idx12546_rank1.c", "source_rust_file": "Full__fromRust__idx12546_rank1.rs", "c_api": "Attribute::AttrKind fromRust(LLVMRustAttribute Kind)", "rust_api": "self.kind.attrs()", "mapping_type": "function", "description": "Enum conversion from LLVMRustAttribute to Attribute::AttrKind in C, to attribute retrieval in Rust.", "reasoning": "[Task Analysis] C function maps LLVMRustAttribute enum values to LLVM Attribute::AttrKind enum values; Rust function returns a slice of Attribute objects from self.kind.attrs(). [Similarity] Names do not match (fromRust vs attrs), but both represent mapping/lookup logic for attribute kinds. [Knowledge Extraction] Full structural similarity in terms of enum mapping logic; API mappings found for attribute kind conversion."}]
Unixcoder Score: -0.10395275801420212
--------------------------------------------------
